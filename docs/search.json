[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Links & Weiterführendes",
    "section": "",
    "text": "%&gt;% vs. |&gt;\nIn diesem Kurs haben wir die Pipe %&gt;% aus {tidyverse} (streng genommen aus dem Paket {magrittr}) kennen gelernt. Mit dem Update auf R 4.1 wurde in base R ebenfalls eine Pipe |&gt; eingeführt und Hilfeseiten usw. ersetzen langsam, aber sicher %&gt;% durch |&gt;. Für (nahezu) alle Anwendungen, die wir kennengelernt haben, verhalten sich beide Pipes identisch - und nachdem am IAB R teilweise noch alte R-Versionen installiert sind, haben wir uns an ‘alte Variante’ gehalten. Letztlich spricht aber nichts dagegen, nach einem Update auf |&gt; umzusteigen - oder einfach bei %&gt;% zu bleiben.\nUnter anderem steht hier mehr zu den Unterschieden zwischen beiden Pipes. Außerdem bietet dieser Blogbeitrag einen guten Überblick zu den Fallstricken beim Umstieg von %&gt;% auf |&gt;.",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#anonymfun",
    "href": "references.html#anonymfun",
    "title": "Links & Weiterführendes",
    "section": "Anonyme Funktionen: .x vs. /(x)",
    "text": "Anonyme Funktionen: .x vs. /(x)\nMit R 4.1.0 wurde in base R eine neue ‘anonymous function short hand’ eingeführt, welche die ‘formula syntax’ Schreibweise ~mean(.x) ablöst, die wir in Kapitel 6 kennen gelernt haben. In der neuen base R wäre das \\(x) mean(x) geschrieben.\nAus der {purrr} release notes für Version 1.0.0 (Dezember 2022): We believe that it’s better to use these new base tools because they work everywhere: the base pipe doesn’t require that you load magrittr and the new function shorthand works everywhere, not just in purrr functions. Additionally, being able to specify the argument name for the anonymous function can often lead to clearer code.\nDementsprechend würde die Anwendung in across() wie folgt aussehen:\n\nsat_small &lt;- haven::read_dta(\"./data/BIBBBAuA_2018_suf1.0.dta\",n_max = 16) %&gt;% \n    select(F1450_04,F1450_05,F1450_06) %&gt;% \n    slice(12:16)\n\n# formula syntax\nsat_small %&gt;% \n  mutate(across(matches(\"F1450\"),~mean(.x)))\n# anonymous function short hand\nsat_small %&gt;% \n  mutate(across(matches(\"F1450\"),\\(x) mean(x) ))\n\nIn diesem Skript habe ich auf die bisherige ‘formula syntax’ Schreibweise zurück gegriffen, da aktuell noch die meisten Hilfeseite mit dieser Syntax arbeiten.",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#einführungen-in-r",
    "href": "references.html#einführungen-in-r",
    "title": "Links & Weiterführendes",
    "section": "Einführungen in R",
    "text": "Einführungen in R\nEine Sammlung von Lehrskripten und Unterlagen aus verschiedenen Kontexten zum selbst weiter lernen:\nR for Data Science das Standardwerk für Datenanalysen mit {tidyverse} - sehr intuitive Einführung, Fokus auf Data Science\nProblemorientiere Einführungen in spezifische Anwendungen “do more with R”\nTen simple rules for teaching yourself R\nModerne Datenanalyse mit R: Deutschsprachige Einführung in {tidyverse}\nR for the Rest of Us bietet viele Tutorials und freie Kurse an, unter anderem auch viele YouTube Videos.\nStata 2 R richtet sich alle Anwender*innen von Stata, die auf R umsteigen möchten. Allerdings wird hier anstelle des {tidyverse} das Paket {data.table} für die Datenaufbereitung gezeigt. {data.table} ist auf der einen Seite sehr schnell, jedoch von der Syntaxlogik her etwas umständlicher als das {tidyverse}. Für alle, die mit sehr großen Datensätzen arbeiten lohnt es sich aber, {data.table} auszuprobieren.",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#rmarkdown",
    "href": "references.html#rmarkdown",
    "title": "Links & Weiterführendes",
    "section": "RMarkdown",
    "text": "RMarkdown\n{rmarkdown} ermöglich es, formatierte Textelemente mit Markdown und R code bzw. Output zu kombinieren. Anders als ein R Script enthält ein RMarkdown-Dokument nicht nur Befehle, sondern auch Text - welcher mit Hilfe von Markdown-Befehlen formatiert werden kann. So können Grafiken, Tabellen, usw. direkt und zeitgleich mit dem Begleittext erstellt werden. Mit R Markdown können wir HTML, PDF, Word Dokumente, PowerPoint und HTML Präsentationen, Webseiten und Bücher erstellen. Diese gesamte Webseite wurde mit {R Markdown} bzw. dem verwandten Paket {Quarto} erstellt.\nDie Hilfeseiten und Dokumentation für R Markdown ist extrem umfangreich und auch die Tutorials und Cheatsheets sind hervorragend. Daher hier nur eine kleiner Überblick.\n\nMarkdown Syntax\nEin RMarkdown-Dokument sieht in seiner Grundform ungefähr so aus:\n---\ntitle: \"Mein erstes RMarkdown-Dokument\"\nauthor: \"Mein Name\"\ndate: \"2022-09-11\"\noutput: pdf_document\n---\n  \n# Überschrift 1\n\n## Unterüberschrift 2\n\nDies ist ein R Markdown-Dokument. \nMarkdown ist eine einfache Syntax für die Erstellung von HTML-, PDF- und MS Word-Dokumenten. \nText kann **fett** und *kursiv* geschrieben werden. \n\nWenn wir auf die Schaltfläche **Knit** klicken, wird ein Dokument erstellt.\nDas sowohl den Inhalt als auch die Ausgabe aller eingebetteten R-Code-Bausteine innerhalb des Dokuments enthält. \nEin R-Code-Baustein (\"chunk\") sieht so aus:\n\n```{r cars}\n# hier kommt der R Code hin\nsummary(mtcars$qsec)\n```\n\n\n\n\n\n\n\n\n\n\n\nBeispiel\nPaper zu einem Beispieldatensatz, komplett in R Markdown geschrieben\nHier findet ihr den Source-Code",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#cheatsheets",
    "href": "references.html#cheatsheets",
    "title": "Links & Weiterführendes",
    "section": "Cheatsheets",
    "text": "Cheatsheets\nEine Sammlung an Cheatsheets für eine breite Palette an Anwendungen gibt es hier.\n\nDatenvisualisierung mit {ggplot2}\nDatensätze bearbeiten mit {dplyr}\nDatensätze erstellen/reshapen mit {tidyr}",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#ggplot2",
    "href": "references.html#ggplot2",
    "title": "Links & Weiterführendes",
    "section": "{ggplot2}",
    "text": "{ggplot2}\nEine große Stärke von ggplot2 sind die zahlreichen Erweiterungen, welche beispielsweise ermöglichen\n\nmehrere Grafiken zu kombinieren mit {patchwork}\nKarten zu erstellen mit sf, weitere Link\nfortgeschrittene Textformatierungen zu verwenden mit {ggtext}\nGrafiken als Animation zu erstellen {gganimate} - eine Einführung oder hier\nLogos in in {ggplot2} einfügen mit {ggpath}\n\nEine Übersicht zu Erweiterungspakteten für {ggplot2} findet sich hier\nAuch The R Graph Gallery bietet eine hervorragende Übersicht zu Darstellungsmöglichkeiten mit Syntaxbeispielen für {ggplot2}.\n\nTutorial von Cédric Scherer\nSession zu intuitiveren Grafiken von Cara Thompson",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#purrr",
    "href": "references.html#purrr",
    "title": "Links & Weiterführendes",
    "section": "Fortgeschrittene Anwendung von lapply()/map() mit selbstgeschriebenen Funktionen",
    "text": "Fortgeschrittene Anwendung von lapply()/map() mit selbstgeschriebenen Funktionen\n\nUmfangreiche Einführung in loops mit map() und weiteren Funktionen aus {purrr} Hendrik van Broekhuizen\nModellserien: Blog von Tim Tiefenbach zu eleganten Möglichkeiten",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#regex",
    "href": "references.html#regex",
    "title": "Links & Weiterführendes",
    "section": "regex",
    "text": "regex\nFür die Arbeit mit Textvariablen sind regular expressions (regex) eine große Hilfe. Damit lassen sich beispielsweise Textabschnitte nach bestimmten Zeichenfolgen durchsuchen, diese ersetzen usw. Der Blog von Joshua C. Fjelstul ist ein guter Einstieg. Darüber hinaus gibt es ein hilfreiches Cheatsheet zu regex in R und das regex -Paket {stringr}",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#weiteres",
    "href": "references.html#weiteres",
    "title": "Links & Weiterführendes",
    "section": "Weiteres",
    "text": "Weiteres\n{easystats} bietet eine Sammlung von Paketen, welche statische Auswertungen erleichtern und vereinheitlichen. Gleichzeitig geht diese Vereinheitlichung aber mit einer beschränkteren Flexibilität einher - das ist Geschmackssache und kommt auf den Anwendungsfall an. Wir haben aus dem easystats-Universum unter anderem {performance} und {effectsize} kennengelernt.\nEreigniszeitmodelle / Event History Modellung / Survival Analysis",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GradAB R Intro 2024",
    "section": "",
    "text": "Welcome!\nIntroduction to R for GradAB IAB.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#index",
    "href": "index.html#index",
    "title": "GradAB R Intro 2024",
    "section": "Course dates",
    "text": "Course dates\n\n   11.09. & 13.09.2024\n   9:00 – 15:00 Uhr\n   E09",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#course-dates",
    "href": "index.html#course-dates",
    "title": "GradAB R Intro 2024",
    "section": "Course dates",
    "text": "Course dates\n\n   11.09. & 13.09.2024\n   9:00 – 15:00\n   E09",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "1  Getting started with R",
    "section": "",
    "text": "1.1 Installing and Setting Up R & RStudio\nR is a completely free program that you can download from CRAN. The RStudio extension is also free and can be downloaded here. RStudio enhances R by providing a significantly more informative and appealing interface, help, and auto-completion when writing syntax, as well as an overall improved user interface. However, RStudio is an extension of R, so you need both programs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#installation-und-einrichten-von-r-rstudio",
    "href": "01_intro.html#installation-und-einrichten-von-r-rstudio",
    "title": "1  Einstieg in R",
    "section": "",
    "text": "Installieren Sie zuerst R und dann RStudio, dann erkennt RStudio die installierte R-Version und die beiden Programme verbinden sich in der Regel automatisch. R ist dabei sozusagen der Motor, RStudio unser Cockpit. Wir könnten direkt mit R arbeiten, aber mit RStudio haben wir eine komfortablere Option und einen besseren Überblick.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.1: R und RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einstieg in R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#rstudio-einrichten",
    "href": "01_intro.html#rstudio-einrichten",
    "title": "1  Einstieg in R",
    "section": "1.2 RStudio einrichten",
    "text": "1.2 RStudio einrichten\nÖffnen Sie nach erfolgreicher Installation die Anwendung RStudio  und Sie sollten folgende Ansicht vor sich sehen:\n\nUm Probleme bei der künftigen Arbeit mit R zu vermeiden, deaktivieren Sie bitte das automatische Speichern und Laden des Workspace. Rufen Sie dazu das entsprechende Menü unter dem Reiter “Tools -&gt; Global options” auf und deaktivieren Sie bitte “Restore .RData into workspace at startup” und setzen Sie “Save workspace to .RData on exit:” auf Never. RStudio speichert ansonsten alle geladenen Objekte wenn Sie die Sitzung beenden und lädt diese automatisch wenn Sie das Programm das nächste Mal öffnen. Dies führt erfahrungsgemäß zu Problemen.\n\nBestätigen Sie die Einstellungen mit “Apply” und schließen Sie das Fenster mit “OK”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einstieg in R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#erste-schritte-in-r",
    "href": "01_intro.html#erste-schritte-in-r",
    "title": "1  Einstieg in R",
    "section": "1.3 Erste Schritte in R",
    "text": "1.3 Erste Schritte in R\nNach diesen grundlegenden Einstellungen können wir uns an die ersten Schritte in R machen. Öffnen Sie dazu zunächst ein Script, indem Sie auf das weiße Symbol links oben klicken oder drücken Sie gleichzeitig STRG/Command + Shift + N .\n\nEs öffnet sich ein viertes Fenster, sodass Sie nun folgende Ansicht vor sich haben sollten:\n\nDieser Scripteditor ist der Ort, an dem wir Befehle erstellen und anschließend durchführen werden. Der Scripteditor dient dabei als Sammlung aller durchzuführenden Befehle. Wir können diese Sammlungen speichern, um sie später wieder aufzurufen und vor allem können wir so Befehlssammlungen mit anderen teilen oder Skripte von anderen für uns selbst nutzen. Wir entwerfen also zunächst im Scripteditor eine Rechnung:\n\nUm diese nun auszuführen, klicken wir in die auszuführende Zeile, sodass der Cursor in dieser Zeile ist und drücken gleichzeitig STRG und Enter (Mac-User Command und Enter):\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.2: Shortcuts für Berechnungen\n\n\n\nR gibt die Ergebnisse unten in der Console aus:\n\nDas funktioniert auch für mehrere Rechnungen auf einmal indem wir mehrere Zeilen markieren und dann wieder STRG und Enter (Mac-User Command und Enter) drücken:\n\nEingaben aus dem Script-Editor und Ergebnisse aus der Konsole werden in Zukunft so dargestellt:\n\n2+5\n\n[1] 7\n\n3-4\n\n[1] -1\n\n5*6\n\n[1] 30\n\n7/8\n\n[1] 0.875\n\n\nR beherrscht natürlich auch längere Berechnungen, zum Beispiel wird auch Punkt vor Strich beachtet:\n\n2+3*2\n\n[1] 8\n\n(2+3)*2\n\n[1] 10\n\n\nAuch weitere Operationen sind möglich:\n\n4^2 ## 4²\nsqrt(4) ## Wurzel \nexp(1) ## Exponentialfunktion (Eulersche Zahl)\nlog(5) ## Natürlicher Logarithmus\nlog(exp(5)) ## log und exp heben sich gegenseitig auf\n\nZahlenreihen können wir mit seq() oder : erstellen:\n\n2:6\n\n[1] 2 3 4 5 6\n\nseq(2,11,3)\n\n[1]  2  5  8 11\n\n\n\n1.3.1 Objekte erstellen\nBisher haben wir uns unsere Berechnungen immer direkt ausgeben lassen. Für umfangreichere Berechnungen - wir wollen ja ab dem nächsten Kapitel mit Datensätzen arbeiten - wollen wir aber die Zwischenschritte speichern.\nErgebnisse lassen sich mit einem &lt;- unter einem beliebigen Namen als Objekt speichern. Dann wird R uns nicht das Ergebnis anzeigen, sondern den Befehl in der Konsole wiederholen:\n\nx &lt;- 4/2\n\nIm Fenster “Environment” rechts oben sehen wir jetzt das abgelegte Objekt x:\n\nWir können es später wieder aufrufen:\n\nx\n\n[1] 2\n\n\nAußerdem können wir Objekte in Rechnungen weiter verwenden - wir setzen einfach x ein und erstellen zB. y:\n\ny &lt;- x * 5\ny\n\n[1] 10\n\n\n\n\n\n1.3.2 Mehrere Werte ablegen\nMit c() lassen sich mehrere Werte unter einem Objekt ablegen und auch mit diesen lässt sich rechnen:\n\nx1 &lt;- c(1,2,3)\nx1\n\n[1] 1 2 3\n\nx1* 2\n\n[1] 2 4 6\n\n\nMit length() können wir die Anzahl der abgelegten Werte nachsehen:\n\nlength(x1)\n\n[1] 3\n\n\n\ny1 &lt;- c(10,11,9)\ny1\n\n[1] 10 11  9\n\ny1/x1\n\n[1] 10.0  5.5  3.0\n\n\n\n\n1.3.3 Werte löschen\nNatürlich können wir Objekte auch wieder löschen und zwar mit rm(). Wenn wir ein nicht existierendes Objekt aufrufen bekommen wir eine Fehlermeldung:\n\nrm(x1)\nx1\n\nError in eval(expr, envir, enclos): Objekt 'x1' nicht gefunden\n\n\nMit rm(list = ls()) können alle Objekte aus dem Environment gelöscht werden.\n\n\n1.3.4 Scripte speichern\nDas Script können wir speichern, um es später wieder aufzurufen.\n\nWichtig ist dabei, der gespeicherten Datei die Endung “.R” zu geben, also zum Beispiel “01_Script.R”.\n\n\n1.3.5 Kommentare\nNeben den eigentlichen Befehlen sind Kommentare ein zentraler Bestandteil einer Datenanalyse-Syntax. Nur so können künftige Nutzende (insbesondere wir selbst in 3 Wochen oder 2 Jahren) nachvollziehen was passiert. Kommentare in R können mit # eingefügt werden:\n\n2+ 5 # hier steht ein Kommentar\n\n[1] 7\n\n2+ # auch hier kann ein Kommentar stehen\n  5\n\n[1] 7\n\n\n\n( 2 + # ein\n    3) * # kommentar\n  2 # über mehrere Zeilen\n\n[1] 10\n\n\nTipp: Erstellen Sie sich am besten sofort einen Ordner, in dem Sie alle R Scripte und Datensätze aus dieser Veranstaltung gesammelt ablegen.\n\n\n1.3.6 Skripte strukturieren\n\n# Überschrift 1 ----\n\n## Abschnit 1.1 ----\n3+2*4\n3+2*3\n## Abschnit 1.2 ----\n3+2*sqrt(3)\n\n# Überschrift 2 ----\nx &lt;- c(2,6,8,2,35)\ny &lt;- seq(2,10,2)\n\ny/x",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einstieg in R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#übungen",
    "href": "01_intro.html#übungen",
    "title": "1  Einstieg in R",
    "section": "1.4 Übungen",
    "text": "1.4 Übungen\n\nLegen Sie eine Zahlenreihe von 7 bis 13 an. Wie können Sie die Zahlenreihe mit seq() anpassen, sodass nur die ungeraden Zahlen generiert werden?\nLegen Sie die Anzahl der Studierenden an der Uni Oldenburg (15643) unter stud ab.\nLegen Sie die Anzahl der Professuren an der Uni Oldenburg (210) unter prof ab.\nBerechnen Sie die Anzahl der Studierenden pro Professur an der Uni Oldenburg indem Sie die Objekte stud und prof verwenden.\nLegen Sie das Ergebnis unter studprof ab und rufen Sie das das Objekt noch einmal auf!\nSehen Sie die erstellten Variablen im Environment-Fenster?\nLegen Sie die Studierendenzahlen der Uni Bremen (19173), Uni Vechta (5333) und Uni Oldenburg (15643) zusammen unter studs ab.\nLegen Sie die Zahl der Profs der Uni Bremen (322), Uni Vechta (67) und Uni Oldenburg (210) zusammen unter profs ab.\nBerechnen die Anzahl der Studierenden pro Professur für alle drei Universitäten.\nSie möchten zusätzlich die Zahl der Studierenden (14000) und Professuren (217) der Uni Osnabrück in studs und profs ablegen. Wie gehen Sie vor?\nBerechnen Sie für alle vier Universitäten das Verhältnis von Studierenden und Professuren!\nLöschen Sie das Objekt stud. Woran erkennen Sie, dass das funktioniert hat?\nLöschen Sie alle Objekte aus dem Environment. Woran erkennen Sie, dass das funktioniert hat?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einstieg in R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#installing-and-setting-up-r-rstudio",
    "href": "01_intro.html#installing-and-setting-up-r-rstudio",
    "title": "1  Getting started with R",
    "section": "",
    "text": "Install R first and then RStudio, so that RStudio recognizes the installed R version, and the two programs usually connect automatically. R is essentially the engine, and RStudio is our cockpit. We could work directly with R, but RStudio offers a more comfortable option and a better overview.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.1: R and RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#setting-up-rstudio",
    "href": "01_intro.html#setting-up-rstudio",
    "title": "1  Getting started with R",
    "section": "1.2 Setting Up RStudio",
    "text": "1.2 Setting Up RStudio\nAfter successful installation, open the RStudio application  and you should see the following view:\n\nTo avoid problems when working with R in the future, please disable the automatic saving and loading of the workspace. To do this, go to the appropriate menu under the “Tools -&gt; Global options” tab, disable “Restore .RData into workspace at startup,” and set “Save workspace to .RData on exit:” to Never. Otherwise, RStudio will save all loaded objects when you end the session and automatically load them the next time you open the program, which can lead to problems.\n\nConfirm the settings with “Apply” and close the window with “OK.”",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#first-steps-in-r",
    "href": "01_intro.html#first-steps-in-r",
    "title": "1  Getting started with R",
    "section": "1.3 First Steps in R",
    "text": "1.3 First Steps in R\nAfter these basic settings, we can start with the first steps in R. To do this, first open a script by clicking on the white icon in the top left corner or pressing CTRL/Command + Shift + N simultaneously.\n\nA fourth window opens, so you should now see the following view:\n\nThis script editor is where we will create and execute commands. The script editor serves as a collection of all commands to be executed. We can save these collections to revisit them later, and, more importantly, we can share command collections with others or use scripts from others for ourselves. So, we first draft a calculation in the script editor:\n\nTo execute it, click on the line to be executed so that the cursor is in that line, and then press CTRL and Enter simultaneously (Mac users: Command and Enter):\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.2: Shortcuts for Calculations\n\n\n\nR outputs the results in the console below:\n\nThis also works for multiple calculations at once by selecting multiple lines and then pressing CTRL and Enter again (Mac users: Command and Enter):\n\nInputs from the script editor and results from the console will be presented like this in the future:\n\n2+5\n\n[1] 7\n\n3-4\n\n[1] -1\n\n5*6\n\n[1] 30\n\n7/8\n\n[1] 0.875\n\n\nOf course, R also handles longer calculations, such as following the order of operations:\n\n2+3*2\n\n[1] 8\n\n(2+3)*2\n\n[1] 10\n\n\nOther operations are also possible:\n\n4^2 ## 4²\nsqrt(4) ## Square root \nexp(1) ## Exponential function (Euler's number)\nlog(5) ## Natural logarithm\nlog(exp(5)) ## log and exp cancel each other out\n\nWe can create sequences of numbers using seq() or ::\n\n2:6\n\n[1] 2 3 4 5 6\n\nseq(2,11,3)\n\n[1]  2  5  8 11\n\n\n\n1.3.1 Creating Objects\nSo far, we have always displayed our calculations directly. For more extensive calculations—since we want to work with datasets starting in the next chapter—we want to save the intermediate steps.\nResults can be saved as objects under any name using &lt;-. R will then not display the result but will repeat the command in the console:\n\nx &lt;- 4/2\n\nIn the “Environment” window at the top right, you can now see the stored object x:\n\nWe can retrieve it later:\n\nx\n\n[1] 2\n\n\nAdditionally, we can use objects in calculations—we simply use x and create, for example, y:\n\ny &lt;- x * 5\ny\n\n[1] 10\n\n\n\n\n\n1.3.2 Storing Multiple Values\nWith c(), we can store multiple values under one object, and these can also be used in calculations:\n\nx1 &lt;- c(1,2,3)\nx1\n\n[1] 1 2 3\n\nx1* 2\n\n[1] 2 4 6\n\n\nWith length(), we can check the number of stored values:\n\nlength(x1)\n\n[1] 3\n\n\n\ny1 &lt;- c(10,11,9)\ny1\n\n[1] 10 11  9\n\ny1/x1\n\n[1] 10.0  5.5  3.0\n\n\n\n\n1.3.3 Deleting Values\nOf course, we can also delete objects using rm(). If we try to call a non-existent object, we will get an error message:\n\nrm(x1)\nx1\n\nError in eval(expr, envir, enclos): Objekt 'x1' nicht gefunden\n\n\nWith rm(list = ls()), all objects can be removed from the environment.\n\n\n1.3.4 Saving Scripts\nWe can save the script to call it again later.\n\nIt is important to give the saved file the extension “.R”, for example, “01_Script.R”.\n\n\n1.3.5 Comments\nBesides the actual commands, comments are a central part of a data analysis syntax. This allows future users (especially ourselves in 3 weeks or 2 years) to understand what is happening. Comments in R can be added with #:\n\n2+ 5 # this is a comment\n\n[1] 7\n\n2+ # a comment can also be placed here\n  5\n\n[1] 7\n\n\n\n( 2 + # a \n    3) * # comment\n  2 # across multiple lines\n\n[1] 10\n\n\nTip: It’s best to create a folder right away where you can store all R scripts and datasets from this course.\n\n\n1.3.6 Structuring Scripts\n\n# Heading 1 ----\n\n## Section 1.1 ----\n3+2*4\n3+2*3\n## Section 1.2 ----\n3+2*sqrt(3)\n\n# Heading 2 ----\nx &lt;- c(2,6,8,2,35)\ny &lt;- seq(2,10,2)\n\ny/x",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#exercises",
    "href": "01_intro.html#exercises",
    "title": "1  Getting started with R",
    "section": "1.4 Exercises",
    "text": "1.4 Exercises\n\nCreate a sequence of numbers from 7 to 13. How can you adjust the sequence with seq() so that only the odd numbers are generated?\nStore the number of students at the University of Oldenburg (15643) in stud.\nStore the number of professorships at the University of Oldenburg (210) in prof.\nCalculate the number of students per professorship at the University of Oldenburg using the objects stud and prof.\nStore the result in studprof and recall the object again!\nDo you see the created variables in the Environment window?\nStore the student numbers of the University of Bremen (19173), University of Vechta (5333), and University of Oldenburg (15643) together in studs.\nStore the number of professors at the University of Bremen (322), University of Vechta (67), and University of Oldenburg (210) together in profs.\nCalculate the number of students per professorship for all three universities.\nYou also want to include the student numbers (14000) and professorships (217) of the University of Osnabrück in studs and profs. How would you do that?\nCalculate the ratio of students to professorships for all four universities!\nDelete the object stud. How can you tell that it worked?\nDelete all objects from the Environment. How can you tell that it worked?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "02_intro.html",
    "href": "02_intro.html",
    "title": "2  Working with Datasets",
    "section": "",
    "text": "2.1 Data Structures in R: data.frame\nIn the previous chapter, we combined the student numbers of the University of Bremen (19173), University of Vechta (5333), and University of Oldenburg (15643) under studs and related them to the professor numbers stored in profs. While this works fine, it is more organized to store related values together. For this, R provides the data.frame. We can store the two objects in a dataset by entering them into data.frame and storing the new object under dat1. When we call dat1, we see that the values have been combined row by row:\nstuds &lt;- c(19173, 5333, 15643)  # Store student numbers under \"studs\"\nprofs &lt;- c(322, 67, 210)        # Store professor numbers under \"profs\"\ndat1_orig &lt;- data.frame(studs, profs)\ndat1_orig\n\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\ndat1 &lt;- data.frame(studs = c(19173, 5333, 15643), \n                   profs = c(322, 67, 210),\n                   gegr  = c(1971, 1830, 1973)) # Without intermediate objects\ndat1    # Display the entire dataset\n\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\nIn the first row, we see the values for the University of Bremen, in the second row for the University of Vechta, and so on. We can access the columns using dataset_name$variable_name. For example, we can display the profs column:\ndat1$profs \n\n[1] 322  67 210\nWe can display the variable/column names of the dataset with colnames()/names(). Additionally, we can call the number of rows and columns using nrow and ncol:\ncolnames(dat1) ## Display variable/column names\n\n[1] \"studs\" \"profs\" \"gegr\" \n\nnames(dat1) ## Display variable/column names\n\n[1] \"studs\" \"profs\" \"gegr\" \n\nncol(dat1) ## Number of columns/variables\n\n[1] 3\n\nnrow(dat1) ## Number of rows/cases\n\n[1] 3\nWe can add new variables to the dataset by using dataset_name$new_variable:\ndat1$stu_prof &lt;- dat1$studs/dat1$profs\n## dat1 now has one more column:\nncol(dat1) \n\n[1] 4\n\ndat1\n\n  studs profs gegr stu_prof\n1 19173   322 1971 59.54348\n2  5333    67 1830 79.59701\n3 15643   210 1973 74.49048\nWe can also store one or more words in a variable, but letters/words must always be enclosed in \"\".\ndat1$uni &lt;- c(\"Uni Bremen\", \"Uni Vechta\", \"Uni Oldenburg\")\ndat1\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\nWith View(dat1), a new window opens where we can view the entire dataset:\nView(dat1)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#data-types-in-r",
    "href": "02_intro.html#data-types-in-r",
    "title": "2  Working with Datasets",
    "section": "2.2 Data Types in R",
    "text": "2.2 Data Types in R\nSo far, we have encountered two variable types: numeric (contains numbers) and character (contains text or numbers that are understood as text). We also learned an organization method: data.frame.\nThe following variable types in R are important for us:2\n\n\n\n\n\n\n\n\n\n\n\n\nVectors\n\n\n\n\ninteger  double\nNumeric values (numeric)\n\n\ncharacter\nText (or numbers understood as text)\n\n\nfactor\nText or numbers understood as text with predefined sorting and fixed value universe\n\n\nlogical\nTRUE or FALSE—mostly the result of a comparison (greater/less/equal)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCombined Vectors\n\n\n\n\ndata.frame  tibble\nTwo-dimensional data structure organized in tabular form—tibble is an enhancement of data.frame in the tidyverse (more on this later)\n\n\nlist\nOrdered collection of vectors of different types—can contain other value types, data.frame, or even other lists\n\n\n\n\n\n\n\nFor now, we focus on character and numeric variables. We will discuss the other types when they are needed. With class(), we can examine the type of a variable, or with is.numeric() or is.character(), we can check whether a variable belongs to a certain type:\n\nclass(dat1$profs)\n\n[1] \"numeric\"\n\nclass(dat1$uni)\n\n[1] \"character\"\n\nis.numeric(dat1$profs)\n\n[1] TRUE\n\nis.character(dat1$profs)\n\n[1] FALSE\n\n\nWe can enforce a type change with as.character() or as.numeric():\n\nas.character(dat1$profs) ## The \"\" indicate that the variable is defined as character\n\n[1] \"322\" \"67\"  \"210\"\n\n\nThis does not change the original variable dat1$profs:\n\nclass(dat1$profs)\n\n[1] \"numeric\"\n\n\nIf we want to keep this conversion for dat1$profs, we need to overwrite the variable:\n\ndat1$profs &lt;- as.character(dat1$profs)\ndat1$profs \n\n[1] \"322\" \"67\"  \"210\"\n\nclass(dat1$profs)\n\n[1] \"character\"\n\n\nWe cannot perform calculations with character variables, even if they contain numbers:\n\ndat1$profs / 2 \n\nError in dat1$profs/2: nicht-numerisches Argument für binären Operator\n\n\nHowever, we can convert dat1$profs to numeric on the fly to perform calculations:\n\nas.numeric(dat1$profs)\n\n[1] 322  67 210\n\nas.numeric(dat1$profs) / 2\n\n[1] 161.0  33.5 105.0\n\n\nIf we convert text variables to numeric, calculations result in NA. NA in R stands for missing values:\n\nas.numeric(dat1$uni)\n\nWarning: NAs durch Umwandlung erzeugt\n\n\n[1] NA NA NA\n\n\nR, understandably, does not know how to convert university names into numbers.\n\n\n\n\n\n\nA common issue in calculations is due to incorrect variable types.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#selecting-rows-columns",
    "href": "02_intro.html#selecting-rows-columns",
    "title": "2  Working with Datasets",
    "section": "2.3 Selecting Rows & Columns",
    "text": "2.3 Selecting Rows & Columns\nA typical task when working with datasets is selecting rows (“cases”) and columns (“variables”).\nFor this, R in its base version3 provides a selection method using []. The basic structure is [row_selection, column_selection]. Leaving out the part before or after the comma selects all rows/columns. Be careful: forgetting the comma is a common source of errors in R.\n\ndat1 # complete dataset\ndat1[1,1] # first row, first column\ndat1[1,]  # first row, all columns\ndat1[,1]  # all rows, first column (equivalent to dat1$studs)\ndat1[,\"studs\"] # all rows, column named studs -&gt; note: \"\"\n\nIn these square brackets, you can also write conditions to make selections from dat1.\n\ndat1[dat1$studs &gt; 10000, ] # rows where studs is greater than 10000, all columns\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg\n\ndat1[dat1$studs &gt; 10000 & dat1$profs &lt; 300, ] # & means AND\n\n  studs profs gegr stu_prof           uni\n3 15643   210 1973 74.49048 Uni Oldenburg\n\ndat1$profs[dat1$studs &gt; 10000] # Only see the number of professors: no comma\n\n[1] \"322\" \"210\"\n\n\n\n2.3.1 Exercise\nRepetitive use of the dataset name in the [] makes the syntax quite long and somewhat tedious. Therefore, there is a better/more convenient solution. We use the {dplyr} package4.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#packages",
    "href": "02_intro.html#packages",
    "title": "2  Working with Datasets",
    "section": "2.4 Packages in R",
    "text": "2.4 Packages in R\nPackages are extensions for R that include additional functions.  Packages need to be installed once and then loaded before use in a new session (i.e., after every restart of R/RStudio). install.packages() performs the installation, and library() loads the packages:\n\ninstall.packages(\"Package\") # only needed once on your PC\nlibrary(Package) # needed after every restart\n\nOften, when using install.packages(), not only the specified package is downloaded but also a number of other packages, the so-called “dependencies”. These are packages used in the background to enable the functions of the desired package. So don’t be surprised if the installation takes a bit longer.\nWith install.packages() we essentially screw in the light bulb in R, with library() we flip the switch so we can use the functions from the package. Each restart turns the light bulb off again, and we need to turn it back on with library(). The advantage is that we don’t have to turn on all the light bulbs at once when starting R.\n\n\n\n\n\nSource: Dianne Cook\n\n\n\n\n\n\n\n\n\n\ninstall.packages() in the IAB Network\n\n\n\nPackages in R are typically installed from CRAN. This is not possible on the servers at IAB due to isolation from the internet. This restricts package installation in R to the collection maintained by DIM under N:/Ablagen/D01700-Allgemein/R/bin/windows/contrib/.\nA central challenge in installing from local zip files is handling dependencies: packages that the desired package relies on. When installing from the internet, dependencies are automatically installed, but with a local installation, this is not the case.\nAt IAB, some workarounds exist, and currently, I have a solution in progress at FDZ based on a .Rprofile file that provides the fdz_install() command, which behaves like the standard install.packages() command (or should, at least).\nThe most recent version of the .Rprofile file can be found under N:\\Ablagen\\D01700-Quickablage\\Filser\\R_2024\\prog.\nPlace the .Rprofile file in C:\\Users\\*YOUR_USERNAME*\\Documents and restart R (CTRL + F10), you should then see a similar message in the console:\n\n----------------------------------------\nIAB-FDZ .Rprofile\nVersion 0.5\n----------------------------------------\n- Local repository: N:/Ablagen/D01700-Allgemein/R/bin/windows/contrib/4.2\n- Working directory: N:/Ablagen/D01700-FDZ/Quickablage/AndreasF/R-Kurs\n \n- Default package library: C:/Users/FilserA001.IAB/AppData/Local/R/win-library/4.2\n- HOME directory: C:/Users/FilserA001.IAB/Documents\n- R_home directory: C:/PROGRA~1/R/R-4.2.1\n----------------------------------------\n\nMore about RProfile\n\n\n\n\n\n\n\n\nLoading packages once\n\n\n\n\n\nIn addition to library(), you can also call functions from packages using :::\n\npackage::function()\n\nThis option is often used when only one function from a package is used or to clarify which package the function comes from. It can also help with issues if a command from another package has the same name—this will override the previous command (usually with a warning), which might look like:\n\nThe following objects are masked from ‘package:dplyr’:\n\n    between, first, last\n\nThe following object is masked from ‘package:purrr’:\n\n    transpose\n\nThis can be avoided by not fully loading certain packages but only calling the necessary functions with ::.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#tidyverse",
    "href": "02_intro.html#tidyverse",
    "title": "2  Working with Datasets",
    "section": "2.5 {tidyverse}",
    "text": "2.5 {tidyverse}\nIn this course, we will mainly work with packages from the {tidyverse}. The tidyverse is a collection of packages that share common syntax logic and thus harmonize particularly well and cover a broad range of use cases. With\n\ninstall.packages(\"tidyverse\")\nfdz_install(\"tidyverse\") # on IAB servers with .Rprofile\n\nthe following packages are installed:\nbroom, conflicted, cli, dbplyr, dplyr, dtplyr, forcats, ggplot2, googledrive, googlesheets4, haven, hms, httr, jsonlite, lubridate, magrittr, modelr, pillar, purrr, ragg, readr, readxl, reprex, rlang, rstudioapi, rvest, stringr, tibble, tidyr, xml2, tidyverse\nWe will get to know some of them during the course. The initially most important one is {dplyr}, which makes selecting cases and variables easier:\n\n\n\n\n\nIllustration based on the {dplyr} Cheatsheet\n\n\n\n\nBut installation is only the first step; we need to load the package with library():\n\nlibrary(tidyverse) # after once using install.packages(\"tidyverse\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#selecting-rows-with-slice",
    "href": "02_intro.html#selecting-rows-with-slice",
    "title": "2  Working with Datasets",
    "section": "2.6 Selecting Rows with slice()",
    "text": "2.6 Selecting Rows with slice()\nA first function from {tidyverse} is slice(), which allows us to select rows:\n\nslice(dat1,1) # first row\nslice(dat1,2:3) # rows 2-3\nslice(dat1,c(1,3)) # rows 1 and 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#filter",
    "href": "02_intro.html#filter",
    "title": "2  Working with Datasets",
    "section": "2.7 Selecting Observations with filter()",
    "text": "2.7 Selecting Observations with filter()\nWith filter(), we can select rows from dat1 based on conditions:\n\nfilter(dat1,uni == \"Uni Oldenburg\", studs &gt; 1000)\n\n  studs profs gegr stu_prof           uni\n1 15643   210 1973 74.49048 Uni Oldenburg\n\n\nThe selection does not change the original object dat1:\n\ndat1\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n\n\nIf we want to keep the result of our selection with filter() for further steps, we can store it in a new data.frame object:\n\nover_10k &lt;- filter(dat1, studs &gt; 10000)\nover_10k\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n\n\n\n2.7.1 filter() helpers\n{dplyr} provides a number of helpers for filter():\n\ngreater/smaller than or equal to: &lt;= &gt;=\nor: |\none of: %in%\nwithin a given range: between()\n\n\nfilter(dat1, studs &gt;= 10000)\nfilter(dat1, studs &lt;= 10000)\nfilter(dat1,studs &gt; 10000 | profs &lt; 200) # more than 10.000 Students *or* less than 200 professors\nfilter(dat1, gegr %in% c(1971,1830)) # founded 1971 or 1830\nfilter(dat1, between(gegr,1971,1830)) # founded between 1971 and 1830 (including)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#mutate",
    "href": "02_intro.html#mutate",
    "title": "2  Working with Datasets",
    "section": "2.9 Mutate & Create New Variables",
    "text": "2.9 Mutate & Create New Variables\nmutate() adds new variables to a data frame or modifies existing ones:\n\ndat1 %&gt;%\n  mutate(studs2 = studs*2) %&gt;%\n  select(uni,studs,studs2)\n\n            uni studs studs2\n1    Uni Bremen 19173  38346\n2    Uni Vechta  5333  10666\n3 Uni Oldenburg 15643  31286\n\n\nIn the example above, studs2 is created as a new column where each value is twice the value in the studs column.\n\n2.9.1 Exercise\nUse the {dplyr} commands to extract rows where there are more than 10,000 students and less than 300 professors. Add a new variable to the dataset where each value in the studs column is doubled.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#zeilen-spalten-auswählen",
    "href": "02_intro.html#zeilen-spalten-auswählen",
    "title": "2  Working with Datasets",
    "section": "2.9 Zeilen & Spalten auswählen",
    "text": "2.9 Zeilen & Spalten auswählen\nEine typische Aufgabe in der Arbeit mit Datensätzen ist die Auswahl von Zeilen (“Fällen”) und Spalten (“Variablen”).\nDazu stellt uns R in der Basisversion5 eine Auswahlmöglichkeit zur Verfügung, welche [ ] verwendet. Die grundlegende Struktur ist dabei [Zeilenauswahl, Spaltenauswahl]. Lassen wir den Part vor oder nach dem Komma leer, werden alle Zeilen/Spalten ausgewählt. Achtung: das vergessene Komma ist wohl einer der Fehlerquellen in R.\n\ndat1 # vollständiger Datensatz\ndat1[1,1] # erste Zeile, erste Spalte\ndat1[1,]  # erste Zeile, alle Spalten\ndat1[,1]  # alle Zeilen, erste Spalte (entspricht hier dat1$studs)\ndat1[,\"studs\"] # alle Zeilen, Spalte mit Namen studs -&gt; achtung: \"\"\n\nIn diese eckigen Klammern können wir auch Bedingungen schreiben, um so Auswahlen aus dat1 zu treffen.\n\ndat1[dat1$studs &gt; 10000, ] # Zeilen in denen studs größer 10000, alle Spalten\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg\n\ndat1[dat1$studs &gt; 10000 & dat1$profs &lt; 300, ] # & bedeutet UND\n\n  studs profs gegr stu_prof           uni\n3 15643   210 1973 74.49048 Uni Oldenburg\n\ndat1$profs[dat1$studs &gt; 10000] # Nur Prof-Zahl nachsehen: kein Komma \n\n[1] \"322\" \"210\"\n\n\n\n2.9.1 Übung\nDie Wiederholung des Datensatznamens in den [ ] macht die Syntax aber recht lang und etwas schreibintensiv. Daher gibt es eine bessere/bequemere Lösung. Dazu verwenden wir das Paket {dplyr}6.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#zeilen-auswählen-mit-slice",
    "href": "02_intro.html#zeilen-auswählen-mit-slice",
    "title": "2  Working with Datasets",
    "section": "2.12 Zeilen auswählen mit slice()",
    "text": "2.12 Zeilen auswählen mit slice()\nEine erste Funktion aus dem {tidyverse} ist slice(), mit welcher wir Zeilen auswählen können:\n\nslice(dat1,1) # erste Zeile\nslice(dat1,2:3) # Zeile 2-3\nslice(dat1,c(1,3)) # Zeile 1 und 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#select",
    "href": "02_intro.html#select",
    "title": "2  Working with Datasets",
    "section": "2.8 Selecting variables with select()",
    "text": "2.8 Selecting variables with select()\nselect() allows us to select specific columns:\n\nselect(dat1,uni,studs) # columns uni and studs\n\n            uni studs\n1    Uni Bremen 19173\n2    Uni Vechta  5333\n3 Uni Oldenburg 15643\n\n\n\nselect(dat1, 1:3) # column 1-3\n\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n\nselect(dat1, !profs) # all but profs\n\n  studs gegr stu_prof           uni\n1 19173 1971 59.54348    Uni Bremen\n2  5333 1830 79.59701    Uni Vechta\n3 15643 1973 74.49048 Uni Oldenburg\n\n\nWe can also select columns by name or position and reorder them:\n\nselect(dat1,uni,studs,profs) # columns in a specific order\n\n            uni studs profs\n1    Uni Bremen 19173   322\n2    Uni Vechta  5333    67\n3 Uni Oldenburg 15643   210\n\nselect(dat1,-studs) # all columns except for \"studs\"\n\n  profs gegr stu_prof           uni\n1   322 1971 59.54348    Uni Bremen\n2    67 1830 79.59701    Uni Vechta\n3   210 1973 74.49048 Uni Oldenburg\n\n\nThe output of select() can be further modified by other functions:\n\ndat1 %&gt;% \n  select(uni,studs) %&gt;% \n  filter(studs &gt; 10000)\n\n            uni studs\n1    Uni Bremen 19173\n2 Uni Oldenburg 15643\n\n\n\n2.8.1 Chaining Commands with %&gt;%\nIn R, dplyr and other {tidyverse} packages use %&gt;% (the pipe operator) to chain commands. This is a way to streamline commands and improve readability:\n\ndat1 %&gt;%\n  filter(studs &gt; 10000) %&gt;%\n  select(uni,studs)\n\n            uni studs\n1    Uni Bremen 19173\n2 Uni Oldenburg 15643\n\n\nHere, %&gt;% takes the output of one function and passes it as an input to the next function. This operator allows you to read and write code that closely resembles natural language.\n\n\n\n\n\n\nEND\n\n\n\nWenn wir jetzt aber einige Zeilen und einige Spalten auswählen möchten, dann können wir filter() und select() kombinieren:\n\nselect(filter(dat1,studs &lt; 10000),uni)\n\n         uni\n1 Uni Vechta\n\n\nDiese Befehlsschachtel können wir mit der sog. Pipe %&gt;% auflösen. %&gt;% steht einfach für “und dann”. Die Pipe kommt aus dem Paket {magrittr}, welches wiederum Teil des tidyverse ist und automatisch mit {dplyr} geladen wird.\n\nfilter(dat1,studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\nHäufig wird die Pipe dann so verwendet, dass zu Beginn lediglich der zu bearbeitende Datensatz steht und sich dann die Schritte anschließen:\n\ndat1 %&gt;% filter(.,studs &lt; 10000) %&gt;% select(.,uni)\n\n         uni\n1 Uni Vechta\n\n\nDer Punkt . steht jeweils für das Ergebnis des vorherigen Schritts. Hier also:\n\nRufe dat1 auf und dann (%&gt;%)\nWähle nur Zeilen aus in denen studs &lt; 10000 und dann (%&gt;%)\nBehalte nur die Spalte uni\n\n\ndat1 %&gt;% filter(studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\n\n\n\n\n\n\nThe shortcut for %&gt;% is STRG+SHIFT+m (cmd+shift+m on Mac)\n\n\n\nIf we want to select both some rows and some columns, we can combine filter() and select():\n\nselect(filter(dat1, studs &lt; 10000), uni)\n\n         uni\n1 Uni Vechta\n\n\nWe can simplify this nested command with the so-called pipe %&gt;%. %&gt;% just means “and then”. The pipe comes from the {magrittr} package, which is part of the tidyverse and is automatically loaded with {dplyr}.\n\nfilter(dat1, studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\nOften, the pipe is used in a way that the dataset to be processed is specified at the beginning, followed by the steps to be performed:\n\ndat1 %&gt;% filter(., studs &lt; 10000) %&gt;% select(., uni)\n\n         uni\n1 Uni Vechta\n\n\nThe dot . represents the result of the previous step. Here:\n\nCall dat1 and then (%&gt;%)\nSelect only rows where studs &lt; 10000 and then (%&gt;%)\nKeep only the column uni\n\n\ndat1 %&gt;% filter(studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\n\n\n\n\n\n\nThe shortcut for %&gt;% is CTRL+SHIFT+m (cmd+shift+m on Mac)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#pipe",
    "href": "02_intro.html#pipe",
    "title": "2  Working with Datasets",
    "section": "2.9 Arbeiten mit der Pipe: filter() und select() kombinieren",
    "text": "2.9 Arbeiten mit der Pipe: filter() und select() kombinieren\nWenn wir jetzt aber einige Zeilen und einige Spalten auswählen möchten, dann können wir filter() und select() kombinieren:\n\nselect(filter(dat1,studs &lt; 10000),uni)\n\n         uni\n1 Uni Vechta\n\n\nDiese Befehlsschachtel können wir mit der sog. Pipe %&gt;% auflösen. %&gt;% steht einfach für “und dann”. Die Pipe kommt aus dem Paket {magrittr}, welches wiederum Teil des tidyverse ist und automatisch mit {dplyr} geladen wird.\n\nfilter(dat1,studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\nHäufig wird die Pipe dann so verwendet, dass zu Beginn lediglich der zu bearbeitende Datensatz steht und sich dann die Schritte anschließen:\n\ndat1 %&gt;% filter(.,studs &lt; 10000) %&gt;% select(.,uni)\n\n         uni\n1 Uni Vechta\n\n\nDer Punkt . steht jeweils für das Ergebnis des vorherigen Schritts. Hier also:\n\nRufe dat1 auf und dann (%&gt;%)\nWähle nur Zeilen aus in denen studs &lt; 10000 und dann (%&gt;%)\nBehalte nur die Spalte uni\n\n\ndat1 %&gt;% filter(studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\n\n\n\n\n\n\nThe shortcut for %&gt;% is STRG+SHIFT+m (cmd+shift+m on Mac)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#variablentyp-factor---eigene-reihenfolgen-festlegen",
    "href": "02_intro.html#variablentyp-factor---eigene-reihenfolgen-festlegen",
    "title": "2  Working with Datasets",
    "section": "2.9 Variablentyp factor - eigene Reihenfolgen festlegen",
    "text": "2.9 Variablentyp factor - eigene Reihenfolgen festlegen\nEin weitere häufige Aufgabe in der Datenanalyse ist das Sortieren von Datensätzen. Dazu haben wir arrange() zur Verfügung:\n\ndat1 %&gt;% arrange(studs)\n\n  studs profs gegr stu_prof           uni\n1  5333    67 1830 79.59701    Uni Vechta\n2 15643   210 1973 74.49048 Uni Oldenburg\n3 19173   322 1971 59.54348    Uni Bremen\n\n\nDas funktioniert auch für string-Variablen:\n\ndat1 %&gt;% arrange(uni)\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n3  5333    67 1830 79.59701    Uni Vechta\n\n\nWas aber, wenn wir eine fixe Ordnung vergeben möchten, die nicht der numerischen oder alphabetischen Ordnung entspricht? Hier bspw. wenn wir die Unis in folgende Ordnung bringen möchten: 1) Uni Oldenburg, 2) Uni Bremen und 3) Uni Vechta. Dabei hilft uns ein dritter Variablentyp: factor.\nMit dem Argument levels = können wir eine Reihenfolge festlegen:\n\nfactor(dat1$uni, levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\n[1] Uni Bremen    Uni Vechta    Uni Oldenburg\nLevels: Uni Oldenburg Uni Bremen Uni Vechta\n\ndat1$uni_fct &lt;- factor(dat1$uni,\n                       levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\nWenn wir nun nach uni_fct sortieren, dann wird die Reihenfolge der levels berücksichtigt:\n\nclass(dat1$uni_fct)\n\n[1] \"factor\"\n\ndat1 %&gt;% arrange(uni_fct)\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n\n\nMit desc() können wir in umgekehrter Reihenfolge sortieren:\n\ndat1 %&gt;% arrange(desc(uni_fct))\n\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\nDas mag für den Moment relativ trivial erscheinen, ist aber später sehr praktisch um in Grafiken Variablen in eine gewisse Ordnung zu bringen oder in Regressionsmodellen die Referenzkategorie festzulegen.\nNatürlich können wir auch nach mehreren Variablen sortieren, dazu fügen wir einfach weitere in arrange() ein:\n\ndat1 %&gt;% arrange(desc(uni_fct), gegr, studs)\n\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\n(Macht in diesem Beispiel aber wenig Sinn)\n\n2.9.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#rproj",
    "href": "02_intro.html#rproj",
    "title": "2  Working with Datasets",
    "section": "2.10 Setting up a project",
    "text": "2.10 Setting up a project\nIn general, it’s worth setting up projects in RStudio. Projects are .Rproj files  that automatically set the working directory to where they are saved. This simplifies collaborative work: no matter who is working on a project or on which device, the project file ensures all paths are always relative to the project directory. Furthermore, version control via git, e.g., github, and other functions can be set in the project file for all users. Also, the last open scripts remain open, making it easier to work on multiple projects.\n\n\n\n\n\n\n\n\n\nWith getwd(), we can check if it worked:\n\ngetwd()\n\n\n\n[1] \"D:/Courses/R-Course\"\n\n\n\n\n\n\n\n\n\n\n\nAlternatively, we could create an .Rproj project with the following command (here’s an example of calling a package with ::):\n\nrstudioapi::initializeProject(path = \"D:/Courses/R-Course\")\n\nWe can open the project with:\n\nrstudioapi::openProject(path = \"D:/Courses/R-Course\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#import",
    "href": "02_intro.html#import",
    "title": "2  Working with Datasets",
    "section": "2.11 Importing datasets",
    "text": "2.11 Importing datasets\nIn most cases, we’ll use datasets that are already saved in a file and just need to be imported. There are countless ways to do this.\nIn this seminar, we’ll work with the Campus-File of PASS, whose parts are available as Stata files.\nTo import the dataset into R, we need to tell R the file path where the dataset is located. The file path depends on your device’s folder structure; in this case, it would be “D:/Courses/R-Course/”.\nOf course, the file path depends on where you saved the dataset:\n\n\n\n\n\n\n\n\n\nWe need to inform R of this file path.\n\n2.11.1 The import command\nNow we can use the actual import command read.table. For the path, we can just enter the quotation marks after file = and press the Tab key. Then we’ll see all subdirectories and tables in the project folder.5\n\nlibrary(haven)\npend &lt;- read_dta(\"./orig/PENDDAT_cf_W13.dta\") \n\nThe import process consists of two parts: first, we specify the object name as pend, under which R will store the dataset. After the &lt;- is the actual read_dta() command, which contains several options. First, we specify the exact dataset name, including the file extension.\n\n\n\n\n\n\nR has problems with Windows-style \\ in file paths\n\n\n\n\n\nUnfortunately, Windows systems use \\ in file paths, which causes problems in R. Therefore, file paths must always be specified with / or alternatively with \\\\. RStudio can help a bit with the CTRL + F/Search & Replace function.\n\n\n\nThe object created is a data.frame:\n\nclass(pend)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nTechnically, it’s a tibble—an enhanced version of data.frame in the tidyverse that includes labels and provides additional information in its display, such as variable classes in the first row.\nIf we were to simply type pend here, the entire dataset would be displayed. For an overview, we can use head:\n\nhead(pend)\n\n# A tibble: 6 × 123\n         pnr      hnr welle   pintjahr pintmon pintmod  zpsex   palter PD0400   \n       &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+lbl&gt;\n1 1000001901 10000019 1 [Wel… 2007     5 [Mai]  1 [CAP… 2 [Wei… 36       2 [Ehe…\n2 1000001902 10000019 1 [Wel… 2007     5 [Mai] NA       1 [Mae… 39       2 [Ehe…\n3 1000001901 10000019 3 [Wel… 2009     3 [Mae…  1 [CAP… 2 [Wei… 38      -9 [Ite…\n4 1000002001 10000020 1 [Wel… 2007     4 [Apr…  1 [CAP… 1 [Mae… 66     -10 [Ite…\n5 1000002002 10000020 1 [Wel… 2007     4 [Apr…  1 [CAP… 2 [Wei… 61       3 [Ehe…\n6 1000002002 10000020 2 [Wel… 2008     5 [Mai]  1 [CAP… 2 [Wei… 62       3 [Ehe…\n# ℹ 114 more variables: PA0100 &lt;dbl+lbl&gt;, PA0200 &lt;dbl+lbl&gt;, PA0300 &lt;dbl+lbl&gt;,\n#   PA0445 &lt;dbl+lbl&gt;, PA0800 &lt;dbl+lbl&gt;, PA0900 &lt;dbl+lbl&gt;, PA1000 &lt;dbl+lbl&gt;,\n#   PSM0100 &lt;dbl+lbl&gt;, PEO0100a &lt;dbl+lbl&gt;, PEO0100b &lt;dbl+lbl&gt;,\n#   PEO0100c &lt;dbl+lbl&gt;, PEO0100d &lt;dbl+lbl&gt;, PEO0100e &lt;dbl+lbl&gt;,\n#   PEO0200a &lt;dbl+lbl&gt;, PEO0200b &lt;dbl+lbl&gt;, PEO0200c &lt;dbl+lbl&gt;,\n#   PEO0200d &lt;dbl+lbl&gt;, PEO0300a &lt;dbl+lbl&gt;, PEO0300b &lt;dbl+lbl&gt;,\n#   PEO0300c &lt;dbl+lbl&gt;, PEO0300d &lt;dbl+lbl&gt;, PEO0300e &lt;dbl+lbl&gt;, …\n\n\nWith nrow and ncol, we can check if it worked. The dataset should have 28424 rows and 123 columns:\n\nnrow(pend)\n\n[1] 28424\n\nncol(pend)\n\n[1] 123\n\n\nOf course, we can also select rows and columns from this much larger dataset as we did before. For example, we can select the data from 2006 and store it under pend06:\n\npend06 &lt;- pend %&gt;% filter(pintjahr == 2006)\n\nNaturally, pend06 has significantly fewer rows than pend:\n\nnrow(pend06)\n\n[1] 168\n\n\nIf we want to see the exact ages of the respondents from pend06, we can call up the corresponding column with pend06$palter:\n\npend06$palter\n\n&lt;labelled&lt;double&gt;[168]&gt;: Alter (Welle 1: gen. aus P1; ab Welle 2: beste Inf.), generiert\n  [1] 71 66 64 64 63 51 64 65 26 38 41 63 58 58 69 45 59 37 28 63 56 29 29 49 47\n [26] 66 34 22 21 37 36 58 56 80 44 65 61 66 40 53 34 70 69 54 65 62 58 54 51 57\n [51] 72 52 25 34 55 44 68 73 46 87 74 83 46 40 62 58 66 41 53 71 66 79 54 42 68\n [76] 68 81 92 70 66 68 77 44 66 66 67 62 43 35 35 52 54 20 48 48 20 41 24 22 33\n[101] 55 41 50 36 19 52 25 36 37 29 37 36 43 49 16 59 28 19 43 44 30 43 50 50 53\n[126] 52 71 43 58 58 58 38 49 30 27 50 58 26 36 44 28 19 42 44 23 20 33 24 31 32\n[151] 31 44 50 58 45 57 37 62 46 52 50 47 40 62 40 19 28 35\n\nLabels:\n value                                   label\n   -10 Item in Fragebogenversion nicht erhoben\n    -9             Item in Welle nicht erhoben\n    -8                       Unplausibler Wert\n    -4        Frage irrtuemlich nicht gestellt\n    -3                Trifft nicht zu (Filter)\n    -2                            Keine Angabe\n    -1                             Weiss nicht\n\n\nAs we’ve seen, there are many more variables in PASS than just palter, and not all have such meaningful names—like PD0400. To understand these variable names and the meaning of the values, we need the codebook.\nWe can also access a variable’s attributes()—more on labels later.\n\n\n2.11.2 Exercise",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#objekte-exportieren",
    "href": "02_intro.html#objekte-exportieren",
    "title": "2  Working with Datasets",
    "section": "2.12 Objekte exportieren",
    "text": "2.12 Objekte exportieren\n\n\n\n\n\n\nDer Begriff speichern kann in R bisweilen zu Missverständnissen führen: Ist gemeint, einen Datensatz o.ä. (1) auf der Festplatte als .csv, .dta, .sav für andere Programme zugänglich abzulegen oder (2) lediglich die Ergebnisse intern in R unter einem Objektnamen abzulegen? Ich vermeide daher das Wort speichern und spreche entweder von exportieren (Fall 1: in eine Datei schreiben) oder ablegen (Fall 2: Ergebnisse/Werte innerhalb von R in einem Objekt ablegen)\n\n\n\nWir können data.frames exportieren und später wieder einlesen, das R-eigene Format dafür ist .RData:\n\nsaveRDS(pend06, file = \"./data/pend06.RData\")\nrm(pend06)\n\npend06_neu &lt;- readRDS(file = \"./data/pend06.RData\")\nhead(pend06) # gibt es nicht mehr\n\nError in eval(expr, envir, enclos): Objekt 'pend06' nicht gefunden\n\nhead(pend06_neu) # das gibt es\n\n# A tibble: 6 × 123\n         pnr      hnr welle   pintjahr pintmon  pintmod zpsex   palter PD0400   \n       &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+lbl&gt;\n1 1000402601 10004026 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 71     -10 [Ite…\n2 1000402602 10004026 1 [Wel… 2006     12 [Dez… 0 [CAT… 2 [Wei… 66     -10 [Ite…\n3 1000409301 10004093 1 [Wel… 2006     12 [Dez… 0 [CAT… 2 [Wei… 64       3 [Ehe…\n4 1000421201 10004212 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 64       3 [Ehe…\n5 1000421202 10004212 1 [Wel… 2006     12 [Dez… 0 [CAT… 2 [Wei… 63       1 [Ueb…\n6 1000426401 10004264 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 51       1 [Ueb…\n# ℹ 114 more variables: PA0100 &lt;dbl+lbl&gt;, PA0200 &lt;dbl+lbl&gt;, PA0300 &lt;dbl+lbl&gt;,\n#   PA0445 &lt;dbl+lbl&gt;, PA0800 &lt;dbl+lbl&gt;, PA0900 &lt;dbl+lbl&gt;, PA1000 &lt;dbl+lbl&gt;,\n#   PSM0100 &lt;dbl+lbl&gt;, PEO0100a &lt;dbl+lbl&gt;, PEO0100b &lt;dbl+lbl&gt;,\n#   PEO0100c &lt;dbl+lbl&gt;, PEO0100d &lt;dbl+lbl&gt;, PEO0100e &lt;dbl+lbl&gt;,\n#   PEO0200a &lt;dbl+lbl&gt;, PEO0200b &lt;dbl+lbl&gt;, PEO0200c &lt;dbl+lbl&gt;,\n#   PEO0200d &lt;dbl+lbl&gt;, PEO0300a &lt;dbl+lbl&gt;, PEO0300b &lt;dbl+lbl&gt;,\n#   PEO0300c &lt;dbl+lbl&gt;, PEO0300d &lt;dbl+lbl&gt;, PEO0300e &lt;dbl+lbl&gt;, …\n\n\nAuch andere Objekte können wir exportieren und dann wieder einlesen - hier wird aber der Objektname wiederhergestellt:\n\nsave(studs, file = \"./data/stud_vektor.RData\")\nrm(studs)\nstuds\nload(file = \"./data/stud_vektor.RData\") # studs wieder mit selbem Namen zurück im environment\nstuds\n\nDas funktioniert auch für mehrere Objekte:\n\nsave(studs,profs, file = \"./data/meine_vektoren.RData\")\nrm(studs,profs)\nstuds\nprofs\nload(file = \"./data/meine_vektoren.RData\") # studs & profs mit selbem Namen zurück im environment\nstuds\nprofs\n\n\n2.12.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#überblick-einlesen-und-exportieren",
    "href": "02_intro.html#überblick-einlesen-und-exportieren",
    "title": "2  Working with Datasets",
    "section": "2.13 Überblick: Einlesen und Exportieren",
    "text": "2.13 Überblick: Einlesen und Exportieren\n\n2.13.1 Datensätze einlesen\n\nÜberblickCode\n\n\n\n\n\n\n\n\n\n\n\n\n\nDateityp\nR Funktion\nR Paket\nAnmerkung\n\n\n\n\n.csv\nread.table()\n-\nset delimiter with `sep = \";\"`\n\n\n.Rdata (R format)\nreadRDS\n-\n\n\n\ngroße .csv\nvroom()\n{vroom}\nset delimiter using `delim = \";\"`\n\n\n.dta (Stata)\nread_dta()\n{haven}\n\n\n\n.dta (Stata - große Dateien)\nread.dta13()\n{readstata13}\nuse convert.factors = F to import only numeric values\nalso imports files from newer Stata versions\n\n\n.dat (SPSS)\nread_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nread_xlsx()\n{readxl}\nuse `sheet = 1`to specifiy which sheet you want\n\n\n\n\n\n\n\n\n\n\n# csv Datei\ndat1 &lt;- read.table(file = \"Dateiname.csv\",sep = \";\")\n\n# Rdata\ndat1 &lt;- readRDS(file = \"Dateiname.Rdata\")\n\n# große csv\nlibrary(vroom)\ndat1 &lt;- vroom(file = \"Dateiname.csv\",delim = \";\")\n\n# Stata dta\nlibrary(haven)\ndat1 &lt;- read_dta(file = \"Dateiname.dta\")\n\n# Stata große Dateien\n# deutlich schneller als mit haven, aber data.frame hat dann keine Labels\nlibrary(readstata13)\ndat1 &lt;- read.dta13(file = \"Dateiname.dta\",convert.factors = F) \n\n# SPSS sav\ndat1 &lt;- read_sav(file = \"Dateiname.sav\")\n\n# Excel\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"1\")\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"Tabellenblatt1\")\n\n\n\n\n\n\n2.13.2 Datensätze exportieren\n\nÜberblickCode\n\n\n\n\n\n\n\nDateityp\nR Funktion\nR Paket\nAnmerkung\n\n\n\n\n.Rdata (R format)\nsaveRDS()\n-\nall variable properties remain\n\n\n.csv\nwrite.table()\n-\nuse `sep = \";\"` to set delimiter br&gt;use row.names= F to suppress row numbering\n\n\n.dta (Stata)\nwrite_dta()\n{haven}\n\n\n\n.dat (SPSS)\nwrite_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nwrite.xlsx()\n{xlsx}\nmit `sheetName` ggf. Tabellenblattname angeben\n\n\n\n\n\n\n\n\n\n\n# Rdata\nsaveRDS(dat1,file = \"Dateiname.Rdata\")\n# csv\nwrite.table(dat1,file = \"Dateiname.csv\",sep = \";\",row.names = F)\n# dta\nlibrary(haven)\nwrite_dta(dat1,path = \"Dateiname.dta\")\n# sav\nlibrary(haven)\nwrite_sav(dat1,path = \"Dateiname.sav\")\n# xlsx\nlibrary(xlsx)\nwrite.xlsx(dat1,file = \"Dateiname.xlsx\", sheetName = \"Tabellenblatt 1\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#hilfe-zu-paketen-und-funktionen",
    "href": "02_intro.html#hilfe-zu-paketen-und-funktionen",
    "title": "2  Working with Datasets",
    "section": "2.14 Hilfe zu Paketen und Funktionen",
    "text": "2.14 Hilfe zu Paketen und Funktionen\nR packages (often) come with very detailed help pages, which can either be called up directly from RStudio:\n\n# help for packages\nvignette(\"dplyr\")\nvignette(package = \"dplyr\")\nvignette(\"rowwise\")\nhelp(\"dplyr\")\nhelp(package = \"dplyr\")\n\n\n# help for a specific function\n?select()\n\nAlternatively, googling the package and function mostly gives you what you need R dplyr select()\nOr refer to the CRAN site:\n\n\n\n\n\nCRAN-Seite für {dplyr}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#übungen",
    "href": "02_intro.html#übungen",
    "title": "2  Working with Datasets",
    "section": "2.15 Übungen",
    "text": "2.15 Übungen\n\n2.15.1 Übung 1\n\nErstellen Sie den Datensatz mit den Studierenden- & Prof-Zahlen wie gezeigt:\n\n\ndat2 &lt;- data.frame(studs = c(14954,47269 ,23659,9415 ,38079), \n                   profs = c(250,553,438 ,150,636),\n                   prom_recht = c(FALSE,TRUE,TRUE,TRUE,FALSE),\n                   gegr  = c(1971,1870,1457,1818,1995))\n\n\nSehen Sie den dat2 in Ihrem Environment?\nLassen Sie sich dat2 in der Console ausgeben.\nFügen Sie die Namen der Unis als neue Spalte in den Datensatz ein. Diese sind in dieser Reihenfolge:\n\n\nc(\"FH Aachen\",\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Bonn-Rhein-Sieg\")\n\n\nLassen Sie sich dat2 anzeigen - in der Console oder mit View()\nBerechnen Sie das Verhältnis Studierende pro Professur und legen Sie die Ergebnisse in einer neuen Variable an. Sehen Sie sich das Ergebnis an.\nLassen Sie sich nur die dritte Zeile von dat2 anzeigen.\nLassen Sie sich nur die dritte Spalte von dat2 anzeigen.\nLassen Sie sich nur die Unis mit unter 10000 Studierenden anzeigen.\n\nZurück nach oben\n\n\n2.15.2 Übung 2\n\nLegen Sie .Rprofile für die Paketinstalltion in C:\\Users\\*KENNUNG*\\Documents\nInstallieren Sie die Pakete des tidyverse mit fdz_install(\"tidyverse\"), nachdem Sie die .Rprofile-Datei in unter PFAD abgelegt haben.\nVerwenden Sie wieder den data.frame dat2 aus Übung 1\nNutzen Sie filter, um sich nur die Unis mit unter 10000 Studierenden anzeigen zu lassen. (Denken Sie daran, {tidyverse} zu installieren und mit library() zu laden)\nLassen Sie sich nur die Spalte gegr anzeigen.\nLassen Sie sich nur Zeilen der Hochschulen mit Promotionsrecht (prom_recht) anzeigen.\n\nZurück nach oben\n\n\n2.15.3 Übung 3\n\nVerwenden Sie weiterhin den Datensatz aus Übung 1 & 2.\nLassen Sie sich nur Hochschulen anzeigen, die 1971, 1457 oder 1995 gegründet wurden - und für diese Fälle nur den Namen und das Gründungsjahr.\nSortieren Sie den Datensatz entsprechend dieser Reihenfolge. (Legen Sie dazu eine factor-Variable an, welche die entsprechende Reihenfolge festlegt.)\n\n\nc(\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Aachen\",\"FH Bonn-Rhein-Sieg\")\n\nZurück nach oben\n\n\n2.15.4 Übung 4\n\nErstellen Sie in Ihrem Verzeichnis für diesen Kurs ein R-Projekt\nSpeichern Sie die Personendaten des PASS-CampusFile (PENDDAT_cf_W13.dta) in Ihrem Verzeichnis im Unterordner orig.\nLesen Sie den Datensatz PENDDAT_cf_W13.dta wie oben gezeigt in R ein und legen Sie den Datensatz unter dem Objektnamen pend ab.\nNutzen Sie head() und View(), um sich einen Überblick über den Datensatz zu verschaffen.\nWie viele Befragte (Zeilen) enthält der Datensatz?\nLassen Sie sich die Variablennamen von pend mit names() anzeigen!\nWie können Sie sich die Zeilen anzeigen lassen, welche den/die Befragte*n mit der pnr 1000908201 enthält?\nWählen Sie alle Befragten aus, die älter als 60 (Alter: palter) sind legen Sie diese Auswahl unter ue_1960 ab.\nWie müssen Sie den Befehl anpassen, sodass ue_1960 nur die Variablen pnr, hnr, welle, pintjahr und palter enthält?\nWie viele Spalten hat ue_1960? Wie viele Zeilen?\n\nBonusübungen:\n\n\nWie alt ist der/die Befragte mit der pnr 1000908201 in welle 10 (im pintjahr 2016)?\nErstellen Sie eine neue Variable mit dem Geburtsjahr der Befragten (basierend auf dem Alter palter und dem Interviewjahr pintjahr).\n\n\nZurück nach oben\n\n\n2.15.5 Übung 5\n\nExportieren Sie den data.frame mit den in der vorherigen Übung erstellten kleineren Datensatz-Version (ue_1960) als .Rdata-Datei.\nLaden Sie die eben exportierte .Rdata-Datei unter einem beliebigen Namen, bspw. ue_1960_neu.\nHat alles geklappt? Vergleichen Sie das neu geladene mit dem ursprünglichen Objekt: identical(ue_1960,ue_1960_neu) - sind beide Objekte identisch?\n\nZurück nach oben",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#anhang",
    "href": "02_intro.html#anhang",
    "title": "2  Working with Datasets",
    "section": "2.16 Anhang",
    "text": "2.16 Anhang\n\n2.16.1 Alternativen zu R-Projekten\nNeben dem Einrichten eines Projekts können wir den Pfad auch mit setwd() setzen oder direkt in read_dta() bzw. anderen read...()-Befehlen angeben. Das hat allerdings den Nachteil, dass diese Strategie nicht auf andere Rechner übertragbar ist: wenn jemand anderes die .Rproj-Datei öffnet, wird R automatisch die Pfade relativ zum Speicherort der Datei setzen. Das gilt auch wenn wir das Verzeichnis verschieben auf unserem Gerät - R wird automatisch das Arbeitsverzeichnis auf den neuen Speicherort setzen.\nZum Setzen des Arbeitsverzeichnis mit setwd() setzen wir in die Klammern den Pfad des Ordners ein. Wichtig dabei ist dass Sie ggf. alle \\ durch /ersetzen müssen:\n\nsetwd(\"D:/Kurse/R_IAB\")\n\nMit getwd() lässt sich überprüfen, ob das funktioniert hat:\n\ngetwd()\n\nHier sollte der mit setwd() gesetzte Pfad erscheinen.\nAlternativ können wir auch in read_dta() den vollen Pfad angeben:\n\npend &lt;- haven::read_dta(\"C:/Kurse/R_IAB/orig/PENDDAT_cf_W13.dta\")\n\n\n\n2.16.2 Zeilen & Spaltenauswahl ohne {dplyr}\nNatürlich kann auch base R (also R ohne Erweiterungen wie {dplyr} Datensätze filtern usw.), dazu wird [ ] verwendet:\n\ndat1[1,1] # erste Zeile, erste Spalte\n\n[1] 19173\n\ndat1[1,]  # erste Zeile, alle Spalten\n\n  studs profs gegr stu_prof        uni    uni_fct\n1 19173   322 1971 59.54348 Uni Bremen Uni Bremen\n\ndat1[,1]  # alle Zeilen, erste Spalte (entspricht hier dat1$studs)\n\n[1] 19173  5333 15643\n\ndat1[,\"studs\"] # alle Zeilen, Spalte mit Namen studs -&gt; achtung: \"\"\n\n[1] 19173  5333 15643\n\n\nNatürlich können wir auch mehrere Zeilen oder Spalten auswählen. Dafür müssen wir wieder auf c( ) zurückgreifen:\n\ndat1[c(1,2),]  ## 1. & 2. Zeile, alle Spalten\ndat1[,c(1,3)]  ## alle Zeilen, 1. & 3. Spalte (entspricht dat1$studs & dat1$stu_prof)\ndat1[,c(\"studs\",\"uni\")] ## alle Zeilen, Spalten mit Namen studs und uni\n\nIn diese eckigen Klammern können wir auch Bedingungen schreiben, um so Auswahlen aus dat1 zu treffen.\n\ndat1 # vollständiger Datensatz\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\ndat1[dat1$uni == \"Uni Oldenburg\", ] # Zeilen in denen uni gleich \"Uni Oldenburg\", alle Spalten\n\n  studs profs gegr stu_prof           uni       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\ndat1$studs[dat1$uni == \"Uni Oldenburg\" ] # Nur Studi-Zahl nachsehen: kein Komma \n\n[1] 15643\n\n\nDas funktioniert soweit wie gewünscht und wir können das Ganze jetzt erweitern:\n\ndat1[dat1$uni == \"Uni Oldenburg\" & dat1$studs &gt; 10000, ] # & bedeutet UND\n\nWir können auch hier einen ODER-Operator verwenden:\n\ndat1[dat1$uni == \"Uni Oldenburg\" | dat1$studs &gt; 10000, ]\n\n\n\n2.16.3 select() vs $\nWenn wir mit select() eine spezifische Variable auswählen, wird trotzdem die Datenstruktur als data.frame() erhalten, während die Auswahl dat1$variablenname die Spalte als Vektor (also Wertereihe) ausgibt:\n\ndat1$studs\n\n[1] 19173  5333 15643\n\nclass(dat1$studs)\n\n[1] \"numeric\"\n\ndat1$studs/ 20\n\n[1] 958.65 266.65 782.15\n\n\nselect() erhält die Werte als Spalte eines data.frame:\n\ndat1 %&gt;% select(studs)\n\n  studs\n1 19173\n2  5333\n3 15643\n\ndat1 %&gt;% select(studs) %&gt;% class()\n\n[1] \"data.frame\"\n\ndat1 %&gt;% select(studs)/20 \n\n   studs\n1 958.65\n2 266.65\n3 782.15",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#footnotes",
    "href": "02_intro.html#footnotes",
    "title": "2  Working with Datasets",
    "section": "",
    "text": "In many other programming languages, these are called libraries.↩︎\nThere are more, and this enumeration ignores technical details—for an advanced introduction to vectors in R, click here.↩︎\nWe will see soon how packages can make working in R easier.↩︎\nIt has become common in the R community to write packages with {} to distinguish them more clearly from functions. I follow this convention in this script.↩︎\nSometimes the dataset is not in the project’s subfolder, in which case the entire path can be specified in read_dta(): pend &lt;- read_dta(file = \"D:/Courses/R-Course/data/PENDDAT_cf_W13.dta\")↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#variable-type-factor---defining-custom-orders",
    "href": "02_intro.html#variable-type-factor---defining-custom-orders",
    "title": "2  Working with Datasets",
    "section": "2.9 Variable type factor - defining custom orders",
    "text": "2.9 Variable type factor - defining custom orders\nAnother common task in data analysis is sorting datasets. For this, we use arrange():\n\ndat1 %&gt;% arrange(studs)\n\n  studs profs gegr stu_prof           uni\n1  5333    67 1830 79.59701    Uni Vechta\n2 15643   210 1973 74.49048 Uni Oldenburg\n3 19173   322 1971 59.54348    Uni Bremen\n\n\nThis also works for string variables:\n\ndat1 %&gt;% arrange(uni)\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n3  5333    67 1830 79.59701    Uni Vechta\n\n\nBut what if we want to assign a specific order that doesn’t follow numeric or alphabetical order? For example, if we want to order the universities as follows: 1) Uni Oldenburg, 2) Uni Bremen, and 3) Uni Vechta.\nThis is where a third variable type comes in: factor.\nWith the levels = argument, we can define an order:\n\nfactor(dat1$uni, levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\n[1] Uni Bremen    Uni Vechta    Uni Oldenburg\nLevels: Uni Oldenburg Uni Bremen Uni Vechta\n\ndat1$uni_fct &lt;- factor(dat1$uni, \n                       levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\nIf we now sort by uni_fct, the order of the levels is respected:\n\nclass(dat1$uni_fct)\n\n[1] \"factor\"\n\ndat1 %&gt;% arrange(uni_fct)\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n\n\nWith desc(), we can sort in reverse order:\n\ndat1 %&gt;% arrange(desc(uni_fct))\n\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\nThis may seem trivial at the moment but is very useful later for ordering variables in plots or setting the reference category in regression models.\nOf course, we can also sort by multiple variables; we just add more to arrange():\n\ndat1 %&gt;% arrange(desc(uni_fct), gegr, studs)\n\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\n(This doesn’t make much sense in this example.)\n\n2.9.1 Exercise",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#exporting-objects",
    "href": "02_intro.html#exporting-objects",
    "title": "2  Working with Datasets",
    "section": "2.12 Exporting objects",
    "text": "2.12 Exporting objects\n\n\n\n\n\n\nThe term save can sometimes lead to misunderstandings in R: does it mean\n\nsaving a dataset or other object to disk as .csv, .dta, .sav for access by other programs, or\nsimply storing the results internally in R under an object name?\n\nI avoid the word save and instead speak of exporting (Case 1: writing to a file) or storing (Case 2: storing results/values within R in an object).\n\n\n\nThe proprietary format in R for exporting data.frames and reloading afterwards is .RData (comparable to dta in Stata):\n\nsaveRDS(pend06, file = \"./data/pend06.RData\")\nrm(pend06) # delete pend06 from memory\n\npend06_neu &lt;- readRDS(file = \"./data/pend06.RData\")\nhead(pend06) # does not exist anymore -&gt; rm()\n\nError in eval(expr, envir, enclos): Objekt 'pend06' nicht gefunden\n\nhead(pend06_neu,n=1)\n\n# A tibble: 1 × 123\n         pnr      hnr welle   pintjahr pintmon  pintmod zpsex   palter PD0400   \n       &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+lbl&gt;\n1 1000402601 10004026 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 71     -10 [Ite…\n# ℹ 114 more variables: PA0100 &lt;dbl+lbl&gt;, PA0200 &lt;dbl+lbl&gt;, PA0300 &lt;dbl+lbl&gt;,\n#   PA0445 &lt;dbl+lbl&gt;, PA0800 &lt;dbl+lbl&gt;, PA0900 &lt;dbl+lbl&gt;, PA1000 &lt;dbl+lbl&gt;,\n#   PSM0100 &lt;dbl+lbl&gt;, PEO0100a &lt;dbl+lbl&gt;, PEO0100b &lt;dbl+lbl&gt;,\n#   PEO0100c &lt;dbl+lbl&gt;, PEO0100d &lt;dbl+lbl&gt;, PEO0100e &lt;dbl+lbl&gt;,\n#   PEO0200a &lt;dbl+lbl&gt;, PEO0200b &lt;dbl+lbl&gt;, PEO0200c &lt;dbl+lbl&gt;,\n#   PEO0200d &lt;dbl+lbl&gt;, PEO0300a &lt;dbl+lbl&gt;, PEO0300b &lt;dbl+lbl&gt;,\n#   PEO0300c &lt;dbl+lbl&gt;, PEO0300d &lt;dbl+lbl&gt;, PEO0300e &lt;dbl+lbl&gt;, …\n\n\nWe can also export and restore other objects. However, we need to load() them, which will result in restoring the previous object name:\n\nsave(studs, file = \"./data/stud_vektor.RData\")\nrm(studs)\nstuds\nload(file = \"./data/stud_vektor.RData\") # studs is back with the same object name\nstuds\n\nThis also works for multiple Objects:\n\nsave(studs,profs, file = \"./data/meine_vektoren.RData\")\nrm(studs,profs)\nstuds\nprofs\nload(file = \"./data/meine_vektoren.RData\") # studs & profs restored with the same name\nstuds\nprofs\n\n\n2.12.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#overview-importing-and-exporting-data-sets",
    "href": "02_intro.html#overview-importing-and-exporting-data-sets",
    "title": "2  Working with Datasets",
    "section": "2.13 Overview: Importing and exporting data sets",
    "text": "2.13 Overview: Importing and exporting data sets\nImporting data sets\n\nExplanantionsCode\n\n\n\n\n\n\n\n\n\n\n\n\n\nfile type\nR function\nR package\nComment\n\n\n\n\n.csv\nread.table()\n-\nset delimiter with `sep = \";\"`\n\n\n.Rdata (R format)\nreadRDS\n-\n\n\n\ngroße .csv\nvroom()\n{vroom}\nset delimiter using `delim = \";\"`\n\n\n.dta (Stata)\nread_dta()\n{haven}\n\n\n\n.dta (Stata - große Dateien)\nread.dta13()\n{readstata13}\nuse convert.factors = F to import only numeric values\nalso imports files from newer Stata versions\n\n\n.dat (SPSS)\nread_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nread_xlsx()\n{readxl}\nuse `sheet = 1`to specifiy which sheet you want\n\n\n\n\n\n\n\n\n\n\n# csv file\ndat1 &lt;- read.table(file = \"Dateiname.csv\",sep = \";\")\n\n# Rdata\ndat1 &lt;- readRDS(file = \"Dateiname.Rdata\")\n\n# large csv\nlibrary(vroom)\ndat1 &lt;- vroom(file = \"Dateiname.csv\",delim = \";\")\n\n# Stata dta\nlibrary(haven)\ndat1 &lt;- read_dta(file = \"Dateiname.dta\")\n\n# Stata large files\n# faster than read_dta(), but without labels\nlibrary(readstata13)\ndat1 &lt;- read.dta13(file = \"Dateiname.dta\",convert.factors = F) \n\n# SPSS sav\ndat1 &lt;- read_sav(file = \"Dateiname.sav\")\n\n# Excel\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"1\")\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"Tabellenblatt1\")\n\n\n\n\nExporting data sets\n\nExplanantionsCode\n\n\n\n\n\n\n\nfile type\nR function\nR package\nComment\n\n\n\n\n.Rdata (R format)\nsaveRDS()\n-\nall variable properties remain\n\n\n.csv\nwrite.table()\n-\nuse `sep = \";\"` to set delimiter br&gt;use row.names= F to suppress row numbering\n\n\n.dta (Stata)\nwrite_dta()\n{haven}\n\n\n\n.dat (SPSS)\nwrite_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nwrite.xlsx()\n{xlsx}\nmit `sheetName` ggf. Tabellenblattname angeben\n\n\n\n\n\n\n\n\n\n\n# Rdata\nsaveRDS(dat1,file = \"Dateiname.Rdata\")\n# csv\nwrite.table(dat1,file = \"Dateiname.csv\",sep = \";\",row.names = F)\n# dta\nlibrary(haven)\nwrite_dta(dat1,path = \"Dateiname.dta\")\n# sav\nlibrary(haven)\nwrite_sav(dat1,path = \"Dateiname.sav\")\n# xlsx\nlibrary(xlsx)\nwrite.xlsx(dat1,file = \"Dateiname.xlsx\", sheetName = \"Tabellenblatt 1\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#appendix",
    "href": "02_intro.html#appendix",
    "title": "2  Working with Datasets",
    "section": "2.16 Appendix",
    "text": "2.16 Appendix\n\n2.16.1 Alternatives to R Projects\nBesides setting up a project, you can also set the path using setwd() or directly specify it within read_dta() or other read...() commands. However, this approach is less portable to other machines. When someone else opens the .Rproj file, R automatically sets paths relative to the file’s location. This is also true if the directory is moved on your device—R will automatically adjust the working directory.\nTo set the working directory with setwd(), insert the folder path within the parentheses. Make sure to replace any \\ with /:\n\nsetwd(\"D:/Kurse/R_IAB\")\n\nYou can check if it worked with getwd():\n\ngetwd()\n\nThe path you set with setwd() should appear.\nAlternatively, you can provide the full path directly in read_dta():\n\npend &lt;- haven::read_dta(\"C:/Kurse/R_IAB/orig/PENDDAT_cf_W13.dta\")\n\n\n\n2.16.2 Selecting Rows & Columns Without {dplyr}\nBase R (without extensions like {dplyr}) can also filter datasets using square brackets []:\n\ndat1[1, 1] # first row, first column\n\n[1] 19173\n\ndat1[1, ]  # first row, all columns\n\n  studs profs gegr stu_prof        uni    uni_fct\n1 19173   322 1971 59.54348 Uni Bremen Uni Bremen\n\ndat1[, 1]  # all rows, first column (equivalent to dat1$studs)\n\n[1] 19173  5333 15643\n\ndat1[, \"studs\"] # all rows, column named studs -&gt; note the \"\"\n\n[1] 19173  5333 15643\n\n\nYou can also select multiple rows or columns by using c():\n\ndat1[c(1, 2), ]  ## 1st & 2nd row, all columns\ndat1[, c(1, 3)]  ## all rows, 1st & 3rd column (equivalent to dat1$studs & dat1$stu_prof)\ndat1[, c(\"studs\", \"uni\")] ## all rows, columns named studs and uni\n\nYou can also write conditions in these square brackets to make selections from dat1.\n\ndat1 # full dataset\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\ndat1[dat1$uni == \"Uni Oldenburg\", ] # Rows where uni equals \"Uni Oldenburg\", all columns\n\n  studs profs gegr stu_prof           uni       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\ndat1$studs[dat1$uni == \"Uni Oldenburg\"] # Just check the student count: no comma needed\n\n[1] 15643\n\n\nThis works as expected, and we can expand it:\n\ndat1[dat1$uni == \"Uni Oldenburg\" & dat1$studs &gt; 10000, ] # & means AND\n\n  studs profs gegr stu_prof           uni       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\nYou can also use the OR operator:\n\ndat1[dat1$uni == \"Uni Oldenburg\" | dat1$studs &gt; 10000, ]\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\n\n\n2.16.3 select() vs $\nWhen you use select() to pick a specific variable, it preserves the data structure as a data.frame(), whereas dat1$variablename extracts the column as a vector (a series of values):\n\ndat1$studs\n\n[1] 19173  5333 15643\n\nclass(dat1$studs)\n\n[1] \"numeric\"\n\ndat1$studs / 20\n\n[1] 958.65 266.65 782.15\n\n\nselect() keeps the values as a column in a data.frame:\n\ndat1 %&gt;% select(studs)\n\n  studs\n1 19173\n2  5333\n3 15643\n\ndat1 %&gt;% select(studs) %&gt;% class()\n\n[1] \"data.frame\"\n\ndat1 %&gt;% select(studs) / 20\n\n   studs\n1 958.65\n2 266.65\n3 782.15",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "03_desc.html",
    "href": "03_desc.html",
    "title": "3  Getting an Overview",
    "section": "",
    "text": "3.1 Frequency Counts\nWe have various commands available to create a frequency count:\nThe simplest command for counting frequencies is the table() command. For example, with the variable statakt representing the education status of respondents:\ntable(pend$statakt)\n\n\n -10   -9   -5    1    2    3 \n3765 3289  280 9470 6139 5481\nHere, we see the absolute frequencies displayed. The first row lists the different values, and the second row shows the frequencies.\nHowever, the labels are ignored in the output of table(). A look into the PASS data report or using attributes() reveals the value labels:\nattributes(pend$statakt)\n\n$label\n[1] \"Aktueller Hauptstatus, generiert (ab Welle 2)\"\n\n$format.stata\n[1] \"%46.0g\"\n\n$class\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n\n$labels\nItem fuer Fragebogenversion nicht relevant \n                                       -10 \n               Item in Welle nicht erhoben \n                                        -9 \n   Generierung nicht mgl. (fehlende Werte) \n                                        -5 \n                             Erwerbstaetig \n                                         1 \n        Arbeitslos (Gemeldet und sonstige) \n                                         2 \n                                   Inaktiv \n                                         3\nt1 &lt;- table(pend$statakt)\n9470 respondents are employed, 5481 respondents are inactive, etc. (More on labels and working with value labels in R later.)\nWith count() from {dplyr}, we get the labels displayed directly. Again, we use the pipe %&gt;%:\npend %&gt;% count(statakt)\n\n# A tibble: 6 × 2\n  statakt                                              n\n  &lt;dbl+lbl&gt;                                        &lt;int&gt;\n1 -10 [Item fuer Fragebogenversion nicht relevant]  3765\n2  -9 [Item in Welle nicht erhoben]                 3289\n3  -5 [Generierung nicht mgl. (fehlende Werte)]      280\n4   1 [Erwerbstaetig]                               9470\n5   2 [Arbeitslos (Gemeldet und sonstige)]          6139\n6   3 [Inaktiv]                                     5481\nWe can also store tables under a freely chosen name and call them up later:\nt1 &lt;- table(pend$statakt)\nt2 &lt;- pend %&gt;% count(statakt)\nWe see here that the table with table() creates a new object form, a table. With count(), however, a data.frame is created.\nclass(t1)\n\n[1] \"table\"\n\nclass(t2)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#häufigkeitsauszählungen",
    "href": "03_desc.html#häufigkeitsauszählungen",
    "title": "3  Einen Überblick erhalten",
    "section": "",
    "text": "table()\ncount() aus {dplyr}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einen Überblick erhalten</span>"
    ]
  },
  {
    "objectID": "03_desc.html#NA03",
    "href": "03_desc.html#NA03",
    "title": "3  Getting an Overview",
    "section": "3.2 Missing Values in R: NA",
    "text": "3.2 Missing Values in R: NA\nNegative values are a bit annoying.\nTo mark the values like -5 as missing data in R, we need to set them to NA in pend. To do this, we call pend$statakt and filter with [] only the values for statakt equal to -1. In the previous chapter, we learned how to call specific values this way:\n\npend$statakt[pend$statakt == -5] # only call statakt = -5\n\n&lt;labelled&lt;double&gt;[280]&gt;: Aktueller Hauptstatus, generiert (ab Welle 2)\n  [1] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n [26] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n [51] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n [76] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[101] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[126] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[151] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[176] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[201] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[226] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[251] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[276] -5 -5 -5 -5 -5\n\nLabels:\n value                                      label\n   -10 Item fuer Fragebogenversion nicht relevant\n    -9                Item in Welle nicht erhoben\n    -5    Generierung nicht mgl. (fehlende Werte)\n     1                              Erwerbstaetig\n     2         Arbeitslos (Gemeldet und sonstige)\n     3                                    Inaktiv\n\n\n(Here, we get the labels again, which is somewhat suboptimal for clarity.)\nIf we then assign a new value with &lt;-, the called values will be overwritten - here, we overwrite all values for statakt == -1 with NA:\n\npend$statakt[pend$statakt == -5]  &lt;- NA\n\nNA is the code for missing data in R, and they will not be listed in table():\n\ntable(pend$statakt)\n\n\n -10   -9    1    2    3 \n3765 3289 9470 6139 5481 \n\n\nBut we can explicitly request the count of NA with the option exclude = NULL:\n\ntable(pend$statakt,exclude = NULL)\n\n\n -10   -9    1    2    3 &lt;NA&gt; \n3765 3289 9470 6139 5481  280 \n\n\nHowever, we have not yet overwritten all the negative values; -10 and -9 are still missing. Of course, it would be possible this way, but it’s a bit cumbersome:\n\npend$statakt[pend$statakt == -9 ]  &lt;- NA\npend$statakt[pend$statakt == -10]  &lt;- NA\n\nFor the PASS data, it’s shorter to use &lt; 0, because all missing codes are less than 0:1\n\npend$statakt[pend$statakt &lt; 0 ]  &lt;- NA\n\nNow we are done with statakt:\n\ntable(pend$statakt)\n\n\n   1    2    3 \n9470 6139 5481 \n\ntable(pend$statakt,exclude = NULL)\n\n\n   1    2    3 &lt;NA&gt; \n9470 6139 5481 7334 \n\n\nIn count(), NA is also counted:\n\npend %&gt;% count(statakt)\n\n# A tibble: 4 × 2\n  statakt                                     n\n  &lt;dbl+lbl&gt;                               &lt;int&gt;\n1  1 [Erwerbstaetig]                       9470\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139\n3  3 [Inaktiv]                             5481\n4 NA                                       7334\n\n\nIf we want to avoid this, we use filter() again - with is.na(), we can identify NA. By prefixing with !, we can request that all non-NA values be retained with TRUE:\n\npend %&gt;% filter(!is.na(statakt)) %&gt;% count(statakt)\n\n# A tibble: 3 × 2\n  statakt                                    n\n  &lt;dbl+lbl&gt;                              &lt;int&gt;\n1 1 [Erwerbstaetig]                       9470\n2 2 [Arbeitslos (Gemeldet und sonstige)]  6139\n3 3 [Inaktiv]                             5481\n\n\nMore about missing values can be found, for example, in The missing book by Nicholas Tierney & Allison Horst.\n\n3.2.1 Exercise",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#andere-tabellenwerte",
    "href": "03_desc.html#andere-tabellenwerte",
    "title": "3  Einen Überblick erhalten",
    "section": "3.3 Andere Tabellenwerte",
    "text": "3.3 Andere Tabellenwerte\nMit Hilfe weiterer Funktionen können wir die Häufigkeitstabellen jeweils anpassen:\n\nprop.table(): relative Werte/Anteile\n\n\ntable(pend$statakt) %&gt;% prop.table(.) \n\n\n        1         2         3 \n0.4490280 0.2910858 0.2598862 \n\n\n29.109% aller Befragten sind arbeitslos.\n\ncumsum(): kumulierte Werte\n\n\ntable(pend$statakt) %&gt;% cumsum(.)\n\n    1     2     3 \n 9470 15609 21090 \n\n\n15609 Befragte sind erwerbstätig oder sind arbeitslos.\n\nprop.table() mit cumsum(): kumulierte relative Häufigkeiten\n\n\ntable(pend$statakt) %&gt;% prop.table() %&gt;% cumsum()\n\n        1         2         3 \n0.4490280 0.7401138 1.0000000 \n\n\n74.011% aller Befragten sind erwerbstätig oder arbeitslos (und nicht inaktiv).\n\n\n\n\n\n\nMehrere Kennzahlen in einer Tabelle\n\n\n\n\n\nAus Stata kennen viele sicherlich folgende Ansicht mit tab statakt:\n\n\nfile D:\\oCloud\\Home-Cloud\\Lehre\\R_IAB\\orig/PENDDAT_cf_W13.dta not found\nr(601);\n\nr(601);\n\n\nStandardmäßig ein table() oder count() immer nur eine Art von Kennzahlen. Da wir aber mit count() die Auszählungen als data.frame() erhalten, können wir die relativen und kumulierten Häufigkeiten einfach als neue Variablen anfügen.\nDazu verwenden wir dat1$var &lt;- ...., das wir im vorherigen Kapitel kennen gelernt hatten. Um also eine neue Spalte pctin unseren data.frame mit den Auszählungen einzufügen gehen wir wie folgt vor: + Zuerst erstellen wir einen data.frame mit der Auszählung mit Hilfe von count()\n\ntab_statakt &lt;- pend %&gt;% count(statakt) # ausgangsbefehl\ntab_statakt\n\n# A tibble: 4 × 2\n  statakt                                     n\n  &lt;dbl+lbl&gt;                               &lt;int&gt;\n1  1 [Erwerbstaetig]                       9470\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139\n3  3 [Inaktiv]                             5481\n4 NA                                       7334\n\n\n\nDann fügen wir eine neue Spalte für die relativen Häufigkeiten hinzu, welche mit prop.table() berechnet werden:\n\n\ntab_statakt$pct &lt;- prop.table(tab_statakt$n)\ntab_statakt\n\n# A tibble: 4 × 3\n  statakt                                     n   pct\n  &lt;dbl+lbl&gt;                               &lt;int&gt; &lt;dbl&gt;\n1  1 [Erwerbstaetig]                       9470 0.333\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.216\n3  3 [Inaktiv]                             5481 0.193\n4 NA                                       7334 0.258\n\n\nWenn wir jetzt noch die kumulierten Häufigkeiten erstellen möchten, dann können wir cumsum() auf pct anwenden:\n\ntab_statakt$Cum &lt;- cumsum(tab_statakt$pct)\n\nEtwas störend ist aber noch das NA, die für fehlende Angaben steht und nicht berücksichtigt werden soll. Das können wir einfach !is.na() in filter() ausschließen:\n\ntab_statakt2 &lt;- pend %&gt;% filter(!is.na(statakt)) %&gt;% count(statakt) \ntab_statakt2$pct &lt;- prop.table(tab_statakt2$n)\ntab_statakt2$Cum &lt;- cumsum(tab_statakt2$pct)\ntab_statakt2\n\n# A tibble: 3 × 4\n  statakt                                    n   pct   Cum\n  &lt;dbl+lbl&gt;                              &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1 [Erwerbstaetig]                       9470 0.449 0.449\n2 2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.291 0.740\n3 3 [Inaktiv]                             5481 0.260 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einen Überblick erhalten</span>"
    ]
  },
  {
    "objectID": "03_desc.html#kontingenztabellen",
    "href": "03_desc.html#kontingenztabellen",
    "title": "3  Einen Überblick erhalten",
    "section": "3.4 Kontingenztabellen",
    "text": "3.4 Kontingenztabellen\nAus Kontingenztabellen erfahren wir, wie häufig Merkmalskombinationen auftreten. Auch für Kontingenztabellen können wir table() verwenden. Zum Beispiel können wir uns eine Tabelle anzeigen lassen, die uns die Häufigkeiten des Erwerbsstatus getrennt nach Geschlechtern zeigt:\n\ntable(pend$zpsex, pend$statakt)\n\n   \n       1    2    3\n  1 4685 3240 2047\n  2 4785 2899 3434\n\n\nWir erkennen aus dieser Tabelle beispielsweise, dass 3434 Befragte weiblich (zpsex=2) und inaktiv (statakt = 3) sind.\nMit addmargins() können wir die Tabelle um die Summenwerte erweitern:\n\ntable(pend$zpsex, pend$statakt) %&gt;% addmargins()\n\n     \n          1     2     3   Sum\n  1    4685  3240  2047  9972\n  2    4785  2899  3434 11118\n  Sum  9470  6139  5481 21090\n\n\nMöchten wir jetzt die relativen Häufigkeiten, dann wenden wir wieder prop.table() an:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table()\n\n   \n             1          2          3\n  1 0.22214320 0.15362731 0.09706022\n  2 0.22688478 0.13745851 0.16282598\n\n\nFür Zeilenprozente benötigen wir die zusätzliche Option margin = 1:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table(margin = 1)\n\n   \n            1         2         3\n  1 0.4698155 0.3249097 0.2052748\n  2 0.4303832 0.2607483 0.3088685\n\n\n\n30.89% der weiblichen Befragten (zpsex=2) sind inaktiv (statakt = 3).\n\nFür Zeilenprozente dann margin = 2:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table(margin = 2)\n\n   \n            1         2         3\n  1 0.4947202 0.5277733 0.3734720\n  2 0.5052798 0.4722267 0.6265280\n\n\n\n62.65% der inaktiven Befragten (statakt = 3) sind weiblich (zpsex=2).\n\nÜbrigens funktioniert auch hier addmargins():\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table(margin = 2) %&gt;% addmargins()\n\n     \n              1         2         3       Sum\n  1   0.4947202 0.5277733 0.3734720 1.3959654\n  2   0.5052798 0.4722267 0.6265280 1.6040346\n  Sum 1.0000000 1.0000000 1.0000000 3.0000000\n\n\nFür eine Kontingenztabelle mit count() geben wir einfach die Variablen in count() an. Das Ergebnis wird immer im “long shape” Format ausgegeben:\n\npend %&gt;% count(zpsex,statakt)\n\n# A tibble: 8 × 3\n  zpsex         statakt                                     n\n  &lt;dbl+lbl&gt;     &lt;dbl+lbl&gt;                               &lt;int&gt;\n1 1 [Maennlich]  1 [Erwerbstaetig]                       4685\n2 1 [Maennlich]  2 [Arbeitslos (Gemeldet und sonstige)]  3240\n3 1 [Maennlich]  3 [Inaktiv]                             2047\n4 1 [Maennlich] NA                                       3555\n5 2 [Weiblich]   1 [Erwerbstaetig]                       4785\n6 2 [Weiblich]   2 [Arbeitslos (Gemeldet und sonstige)]  2899\n7 2 [Weiblich]   3 [Inaktiv]                             3434\n8 2 [Weiblich]  NA                                       3779\n\n\nHier ist count() informativer als table(). Hier werden die Labels verwendet. Der Übersichtlichkeit halber verwende ich meistens count(), auch wenn das long shape Format etwas gewöhnungsbedürftig ist.\n\n3.4.1 Übung\n\n\n\n\n\n\nBei langen Tabellen gibt count() nicht alle Zeilen aus\n\n\n\n\n\nBei langen Tabellen werden nicht alle Werte ausgegeben, sondern nur die ersten Zeilen. Um hier alle Werte zu bekommen, hilft print(n=Inf):\n\npend %&gt;% count(palter) # wird abgeschnitten\n\n# A tibble: 84 × 2\n   palter                n\n   &lt;dbl+lbl&gt;         &lt;int&gt;\n 1 -2 [Keine Angabe]    60\n 2 14                    1\n 3 15                  271\n 4 16                  308\n 5 17                  276\n 6 18                  282\n 7 19                  266\n 8 20                  296\n 9 21                  282\n10 22                  330\n# ℹ 74 more rows\n\npend %&gt;% count(palter) %&gt;% print(n=Inf) # alle Werte werden gezeigt\n\n# A tibble: 84 × 2\n   palter                n\n   &lt;dbl+lbl&gt;         &lt;int&gt;\n 1 -2 [Keine Angabe]    60\n 2 14                    1\n 3 15                  271\n 4 16                  308\n 5 17                  276\n 6 18                  282\n 7 19                  266\n 8 20                  296\n 9 21                  282\n10 22                  330\n11 23                  338\n12 24                  325\n13 25                  371\n14 26                  401\n15 27                  438\n16 28                  460\n17 29                  449\n18 30                  502\n19 31                  495\n20 32                  502\n21 33                  515\n22 34                  513\n23 35                  511\n24 36                  500\n25 37                  474\n26 38                  504\n27 39                  484\n28 40                  517\n29 41                  521\n30 42                  526\n31 43                  536\n32 44                  540\n33 45                  552\n34 46                  610\n35 47                  604\n36 48                  600\n37 49                  585\n38 50                  601\n39 51                  621\n40 52                  597\n41 53                  598\n42 54                  615\n43 55                  575\n44 56                  566\n45 57                  561\n46 58                  618\n47 59                  589\n48 60                  568\n49 61                  512\n50 62                  507\n51 63                  534\n52 64                  469\n53 65                  438\n54 66                  424\n55 67                  376\n56 68                  326\n57 69                  316\n58 70                  291\n59 71                  259\n60 72                  239\n61 73                  212\n62 74                  188\n63 75                  177\n64 76                  134\n65 77                  126\n66 78                  119\n67 79                   96\n68 80                   74\n69 81                   62\n70 82                   54\n71 83                   48\n72 84                   40\n73 85                   26\n74 86                   27\n75 87                   23\n76 88                   15\n77 89                   11\n78 90                   12\n79 91                   11\n80 92                    9\n81 93                    7\n82 94                    4\n83 95                    2\n84 97                    2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einen Überblick erhalten</span>"
    ]
  },
  {
    "objectID": "03_desc.html#lage--konzentrationsmaße",
    "href": "03_desc.html#lage--konzentrationsmaße",
    "title": "3  Einen Überblick erhalten",
    "section": "3.5 Lage- & Konzentrationsmaße",
    "text": "3.5 Lage- & Konzentrationsmaße\nLagemaße sind statische Kennzahlen zur Beschreibung von metrischen Variablen, wie beispielsweise das arithmetische Mittel oder der Median. Einen Überblick bietet summary():\n\nsummary(pend$netges)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n    -5.0     -3.0     -3.0    567.9    990.0 111419.0 \n\n\nAllerdings gibt es im Datensatz natürlich keine Befragten mit einem Bruttoverdienst von -5.0 EUR. Werte kleiner Null sind Zahlencodes für keine Angabe:\n\n\n\n\n\n\n\n\nname\nvalue\n\n\n\n\nItem fuer Fragebogenversion nicht relevant\n-10\n\n\nItem in Welle nicht erhoben\n-9\n\n\nGenerierung nicht mgl. (fehlende Werte)\n-5\n\n\nTrifft nicht zu (Filter)\n-3\n\n\n\n\n\n\n\nUm aussagekräftige Werte zu bekommen, müssen wir diese Werte mit NA überschreiben:\n\npend$netges[pend$netges &lt; 0 ] &lt;- NA # missings überschreiben\n\n\nsummary(pend$netges)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n      0     880    1320    1562    1890  111419   18056 \n\n\nWir können aber auch bestimmte Kennzahlen anfordern sehen uns die Bruttoverdienste der Befragten zu beschreiben:\n\nMinimum und Maximum: min(), max()\narithm. Mittel: mean()\nMedian: median()\nQuantile: quantile()\nVarianz: var()\nStandardabweichung: sd()\nGini-Koeffizient: Gini aus dem Paket {ineq}\n\nWenn eine Variable NA enthält, müssen diese explizit ignoriert werden - ansonsten wird nur NA ausgegeben:\n\nmean(pend$netges)\n\n[1] NA\n\n\nDeshalb müssen wir die Option na.rm = T angeben:\n\nmean(pend$netges,na.rm = T)\n\n[1] 1562.3\n\n\nEin Quantil einer Verteilung trennt die Daten so in zwei Teile, dass x% der Daten darunter und 100-x% darüber liegen. Mit quantile()wir durch Angabe in der Option probs = beliebige Quantilgrenzen anfordern, zB. für die 40%-Quantilgrenze:\n\nquantile(pend$netges,probs = .4, na.rm = T)\n\n 40% \n1125 \n\n\nDen Gini-Koeffizienten können wir mit Gini() aus dem Paket ineq berechnen:\n\ninstall.packages(\"ineq\") # einmal installieren\n\n\nlibrary(ineq) # ineq laden\nGini(pend$netges)\n\n[1] 0.3560557\n\n\n\n3.5.1 Kennzahlentabelle mit summarise\nMit Hilfe von summarise() aus {dplyr} können wir ein eigenes summary() bauen:\n\npend %&gt;% summarise(Minimum = min(netges,na.rm = T),\n                    Median = median(netges,na.rm = T),\n                    Mittelwert = mean(netges,na.rm = T),\n                    Maximum = max(netges,na.rm = T),\n                    Gini = Gini(netges))\n\n# A tibble: 1 × 5\n  Minimum   Median Mittelwert Maximum    Gini\n  &lt;dbl+lbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl+lbl&gt; &lt;dbl&gt;\n1 0           1320      1562. 111419    0.356\n\n\nDer Vorteil des Ganzen wird im nächsten Schritt klarer.\n\n\n3.5.2 Lage- und Streuungsmaße vergleichen\nHäufig werden diese Kennzahlen erst im Vergleich richtig spannend.\nDafür hilft uns das Argument .by = in summarise():\n\npend %&gt;% summarise(Minimum = min(netges,na.rm = T),\n                    Median = median(netges,na.rm = T),\n                    Mittelwert = mean(netges,na.rm = T),\n                    Maximum = max(netges,na.rm = T),\n                    Gini = Gini(netges),\n                   .by = welle)\n\n# A tibble: 13 × 6\n   welle                    Minimum   Median Mittelwert Maximum    Gini\n   &lt;dbl+lbl&gt;                &lt;dbl+lbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl+lbl&gt; &lt;dbl&gt;\n 1  1 [Welle 1 (2006/2007)] 1          1200       1525. 111419    0.416\n 2  3 [Welle 3 (2008/2009)] 0          1298.      1498.  12000    0.349\n 3  2 [Welle 2 (2007/2008)] 0          1320       1529.   7200    0.333\n 4  4 [Welle 4 (2010)]      0          1210       1447.  10800    0.334\n 5  5 [Welle 5 (2011)]      0          1250       1494.  33363    0.367\n 6  6 [Welle 6 (2012)]      0          1215       1459.  15950    0.348\n 7  7 [Welle 7 (2013)]      0          1250       1539.  87835    0.382\n 8  8 [Welle 8 (2014)]      0          1255       1456.   9000    0.322\n 9 10 [Welle 10 (2016)]     0          1375       1541.   6300    0.317\n10 11 [Welle 11 (2017)]     0          1500       1748.  44440    0.340\n11 12 [Welle 12 (2018)]     0          1500       1667.   7150    0.312\n12 13 [Welle 13 (2019)]     0          1550       1816.  88453    0.358\n13  9 [Welle 9 (2015)]      0          1280       1613. 110451    0.387\n\n\nHier stört aber die Sortierung der Welle (R übernimmt die Sortierung aus den Daten). Also hängen wir ein arrange() an, um die Sortierung nach welle anzufordern:\n\npend %&gt;% summarise(Minimum = min(netges,na.rm = T),\n                    Median = median(netges,na.rm = T),\n                    Mittelwert = mean(netges,na.rm = T),\n                    Maximum = max(netges,na.rm = T),\n                    Gini = Gini(netges),\n                   .by = welle) %&gt;% \n  arrange(welle)\n\n# A tibble: 13 × 6\n   welle                    Minimum   Median Mittelwert Maximum    Gini\n   &lt;dbl+lbl&gt;                &lt;dbl+lbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl+lbl&gt; &lt;dbl&gt;\n 1  1 [Welle 1 (2006/2007)] 1          1200       1525. 111419    0.416\n 2  2 [Welle 2 (2007/2008)] 0          1320       1529.   7200    0.333\n 3  3 [Welle 3 (2008/2009)] 0          1298.      1498.  12000    0.349\n 4  4 [Welle 4 (2010)]      0          1210       1447.  10800    0.334\n 5  5 [Welle 5 (2011)]      0          1250       1494.  33363    0.367\n 6  6 [Welle 6 (2012)]      0          1215       1459.  15950    0.348\n 7  7 [Welle 7 (2013)]      0          1250       1539.  87835    0.382\n 8  8 [Welle 8 (2014)]      0          1255       1456.   9000    0.322\n 9  9 [Welle 9 (2015)]      0          1280       1613. 110451    0.387\n10 10 [Welle 10 (2016)]     0          1375       1541.   6300    0.317\n11 11 [Welle 11 (2017)]     0          1500       1748.  44440    0.340\n12 12 [Welle 12 (2018)]     0          1500       1667.   7150    0.312\n13 13 [Welle 13 (2019)]     0          1550       1816.  88453    0.358\n\n\nWas aber wenn wir nur Welle 1 und 10 vergleichen wollen? Wir schalten einen filter() vor:\n\npend %&gt;% \n  filter(welle %in% c(1,10)) %&gt;% \n  summarise(Minimum = min(netges,na.rm = T),\n                    Median = median(netges,na.rm = T),\n                    Mittelwert = mean(netges,na.rm = T),\n                    Maximum = max(netges,na.rm = T),\n                    Gini = Gini(netges),\n                   .by = welle)\n\n# A tibble: 2 × 6\n  welle                    Minimum   Median Mittelwert Maximum    Gini\n  &lt;dbl+lbl&gt;                &lt;dbl+lbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl+lbl&gt; &lt;dbl&gt;\n1  1 [Welle 1 (2006/2007)] 1           1200      1525. 111419    0.416\n2 10 [Welle 10 (2016)]     0           1375      1541.   6300    0.317\n\n\n\n\n3.5.3 Übung",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Einen Überblick erhalten</span>"
    ]
  },
  {
    "objectID": "03_desc.html#übungen",
    "href": "03_desc.html#übungen",
    "title": "3  Getting an Overview",
    "section": "3.5 Übungen",
    "text": "3.5 Übungen\n\nAlle Übungen beziehen sich auf das PASS CampusFile PENDDAT_cf_W13.dta:\n\nlibrary(haven)\npend &lt;- read_dta(\"./orig/PENDDAT_cf_W13.dta\")\n\nZur Erinnerung: hier geht’s zur Übersicht der Einlesebefehle\n\n3.5.1 Übung 1\nWir interessieren uns für die Variable famstand, welche den Familienstand der Befragten enthält:\n\n\n\n\n\n\n\n\nFamilienstand, generiert\nFamilienstand, generiert\n\n\n\n\n-8\nUnplausibler Wert\n\n\n-4\nFrage irrtuemlich nicht gestellt\n\n\n-3\nTrifft nicht zu (Filter)\n\n\n-2\nKeine Antwort\n\n\n1\nLedig\n\n\n2\nVerheiratet/eing. Lebensp., zus. lebd.\n\n\n3\nVerheiratet/eing. Lebensp., getr. lebd.\n\n\n4\nGeschieden\n\n\n5\nVerwitwet\n\n\n\n\n\n\n\n\nLassen Sie sich eine Tabelle mit den absoluten Häufigkeiten anzeigen, nutzen Sie dafür sowohl table() als auch count() (Denken Sie daran, {tidyverse} zu laden für count()).\nÜberschreiben Sie Missing-Codes mit NA.\nHat das Überschreiben der Missings mit NA geklappt? Erstellen Sie die Tabelle erneut.\nLassen Sie sich der relativen Häufigkeiten (Anteile) ausgeben. Verwenden Sie prop.table() auf Basis des table().\nErstellen Sie eine Kontingenztabelle, indem Sie neben famstand auch das Geschlecht zpsex (2 = Frauen, 1 = Männer) mit einbeziehen\n\nZurück nach oben\n\n\n3.5.2 Übung 2\n\n\nErstellen Sie eine Kontingenztabelle für famstand und zpsex\nWie viel Prozent der Befragten sind geschiedene Frauen?\nWie viel Prozent der befragten Frauen sind geschieden? Nutzen Sie die margin =-Option\nWie viel Prozent der befragten Geschiedenen sind Frauen? Nutzen Sie die margin =-Option\n\nZurück nach oben\n\n\n3.5.3 Übung 3\nBeschreiben Sie das Alter der Befragten (palter) mit summary und erstellen Sie selbst einen Überblick mit Hilfe von summarise(), der einen Vergleich des Befragtenalters nach Familienstand erlaubt.\n\nÜberschreiben Sie zunächst die Missings mit NA:\n\n\npend$palter[pend$palter&lt;0] &lt;- NA\npend$famstand[pend$famstand&lt;0] &lt;- NA\n\n\nErstellen Sie einen Überblick mit summary()\nErstellen Sie einen Überblick mit dem Minimum, Median, arith. Mittel, Varianz und Maximum der Alterswerte mit Hilfe von summarise()\nErweitern Sie diesen Überblick dann so, dass sie einen Vergleich der Kennzahlen für die verschiedenen famstand-Kategorien ausgegeben bekommen.\n\nZurück nach oben",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#hinweise",
    "href": "03_desc.html#hinweise",
    "title": "3  Getting an Overview",
    "section": "3.6 Hinweise",
    "text": "3.6 Hinweise\n\n3.6.1 Runden mit round()\nErläuterung: Sie können mit round(x , 3) Werte auf eine gewisse Zahl von Ziffern runden. Die zweite Zahl in der Klammer (nach dem Komma) gibt an, wieviele Dezimalstellen wir möchten:\n\nround(21.12121123,digits = 3)\n\n[1] 21.121\n\nround(21.12121123,digits = 5)\n\n[1] 21.12121\n\nround(21.12121123,digits = 0)\n\n[1] 21\n\n\nWir können also die relativen Häufigkeiten runden und so die Tabelle von oben übersichtlicher machen:\n\nxtabs(~zpsex+statakt, data = pend) %&gt;% \n  prop.table(.,margin = 1) %&gt;% \n  round(.,3)\n\n     statakt\nzpsex     1     2     3\n    1 0.470 0.325 0.205\n    2 0.430 0.261 0.309",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#footnotes",
    "href": "03_desc.html#footnotes",
    "title": "3  Getting an Overview",
    "section": "",
    "text": "For non-systematic values, we can use the %in% operator that we already learned about in connection with filter(): pend$var1[pend$var1 %in% c(-9,2,124) ]  &lt;- NA (this is just an example).↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#frequency-counts",
    "href": "03_desc.html#frequency-counts",
    "title": "3  Getting an Overview",
    "section": "",
    "text": "table()\ncount() from {dplyr}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#other-table-values",
    "href": "03_desc.html#other-table-values",
    "title": "3  Getting an Overview",
    "section": "3.3 Other Table Values",
    "text": "3.3 Other Table Values\nWith the help of additional functions, we can customize the frequency tables:\n\nprop.table(): relative values/percentages\n\n\ntable(pend$statakt) %&gt;% prop.table(.) \n\n\n        1         2         3 \n0.4490280 0.2910858 0.2598862 \n\n\n29.109% of respondents are unemployed.\n\ncumsum(): cumulative values\n\n\ntable(pend$statakt) %&gt;% cumsum(.)\n\n    1     2     3 \n 9470 15609 21090 \n\n\n15609 respondents are employed or unemployed.\n\nprop.table() with cumsum(): cumulative relative frequencies\n\n\ntable(pend$statakt) %&gt;% prop.table() %&gt;% cumsum()\n\n        1         2         3 \n0.4490280 0.7401138 1.0000000 \n\n\n74.011% of respondents are employed or unemployed (and not inactive).\n\n\n\n\n\n\nMultiple Metrics in One Table\n\n\n\n\n\nMany are probably familiar with the following view from Stata with tab statakt:\n\n\n   Aktueller Hauptstatus, generiert (ab |\n                               Welle 2) |      Freq.     Percent        Cum.\n----------------------------------------+-----------------------------------\n                          Erwerbstaetig |      9,470       33.32       33.32\n     Arbeitslos (Gemeldet und sonstige) |      6,139       21.60       54.91\n                                Inaktiv |      5,481       19.28       74.20\n                                      . |      7,334       25.80      100.00\n----------------------------------------+-----------------------------------\n                                  Total |     28,424      100.00\n\n\nBy default, table() or count() only provide one type of metric. However, since we get the counts as a data.frame() with count(), we can simply add the relative and cumulative frequencies as new variables.\nWe use dat1$var &lt;- ...., which we learned in the previous chapter. To add a new column pct to our data.frame with the counts, we proceed as follows: + First, we create a data.frame with the count using count():\n\ntab_statakt &lt;- pend %&gt;% count(statakt) # base command\ntab_statakt\n\n# A tibble: 4 × 2\n  statakt                                     n\n  &lt;dbl+lbl&gt;                               &lt;int&gt;\n1  1 [Erwerbstaetig]                       9470\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139\n3  3 [Inaktiv]                             5481\n4 NA                                       7334\n\n\n\nThen we add a new column for the relative frequencies, calculated with prop.table():\n\n\ntab_statakt$pct &lt;- prop.table(tab_statakt$n)\n\nIf we now want to create cumulative frequencies, we can apply cumsum() to pct:\n\ntab_statakt$Cum &lt;- cumsum(tab_statakt$pct)\ntab_statakt\n\n# A tibble: 4 × 4\n  statakt                                     n   pct   Cum\n  &lt;dbl+lbl&gt;                               &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  1 [Erwerbstaetig]                       9470 0.333 0.333\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.216 0.549\n3  3 [Inaktiv]                             5481 0.193 0.742\n4 NA                                       7334 0.258 1    \n\n\nThe NA is still somewhat annoying as it represents missing data and should not be included. We can exclude it simply with !is.na() in filter():\n\ntab_statakt2 &lt;- pend %&gt;% filter(!is.na(statakt)) %&gt;% count(statakt) \ntab_statakt2$pct &lt;- prop.table(tab_statakt2$n)\ntab_statakt2\n\n# A tibble: 3 × 3\n  statakt                                    n   pct\n  &lt;dbl+lbl&gt;                              &lt;int&gt; &lt;dbl&gt;\n1 1 [Erwerbstaetig]                       9470 0.449\n2 2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.291\n3 3 [Inaktiv]                             5481 0.260\n\ntab_statakt2$cum &lt;- cumsum(tab_statakt2$pct)\ntab_statakt2\n\n# A tibble: 3 × 4\n  statakt                                    n   pct   cum\n  &lt;dbl+lbl&gt;                              &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1 [Erwerbstaetig]                       9470 0.449 0.449\n2 2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.291 0.740\n3 3 [Inaktiv]                             5481 0.260 1    \n\n\n\n\n\n\n3.3.1 Creating a Contingency Table\nContingency tables allow us to explore how frequently combinations of different variables occur together. Let’s look at two ways to create contingency tables in R.\nUsing the table() function, we create a contingency table by inserting two variables. For instance, if we want to see the frequencies of employment status (statakt) by gender (zpsex), we can use the following command:\n\ntable(pend$zpsex, pend$statakt)\n\n   \n       1    2    3\n  1 4685 3240 2047\n  2 4785 2899 3434\n\n\nThis table shows the counts of respondents by gender and employment status. For example, if zpsex=2 represents females and statakt=3 represents inactivity, the table displays how many female respondents are inactive.\nTo add row and column totals, use the addmargins() function:\n\ntable(pend$zpsex, pend$statakt) %&gt;% addmargins()\n\n     \n          1     2     3   Sum\n  1    4685  3240  2047  9972\n  2    4785  2899  3434 11118\n  Sum  9470  6139  5481 21090\n\n\nIf you want to compute the relative frequencies instead of absolute counts, use the prop.table() function:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table()\n\n   \n             1          2          3\n  1 0.22214320 0.15362731 0.09706022\n  2 0.22688478 0.13745851 0.16282598\n\n\nFor row-wise percentages (within each gender, how many fall into each employment status), use:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table(margin = 1)\n\n   \n            1         2         3\n  1 0.4698155 0.3249097 0.2052748\n  2 0.4303832 0.2607483 0.3088685\n\n\nFor column-wise percentages (within each employment status, how many are male or female), use:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table(margin = 2)\n\n   \n            1         2         3\n  1 0.4947202 0.5277733 0.3734720\n  2 0.5052798 0.4722267 0.6265280\n\n\n\n\n3.3.2 Working with count() from {dplyr}\nAnother approach to generate frequency tables is using count() from the {dplyr} package. It provides a more readable output with labeled variables:\n\npend %&gt;% count(zpsex, statakt)\n\n# A tibble: 8 × 3\n  zpsex         statakt                                     n\n  &lt;dbl+lbl&gt;     &lt;dbl+lbl&gt;                               &lt;int&gt;\n1 1 [Maennlich]  1 [Erwerbstaetig]                       4685\n2 1 [Maennlich]  2 [Arbeitslos (Gemeldet und sonstige)]  3240\n3 1 [Maennlich]  3 [Inaktiv]                             2047\n4 1 [Maennlich] NA                                       3555\n5 2 [Weiblich]   1 [Erwerbstaetig]                       4785\n6 2 [Weiblich]   2 [Arbeitslos (Gemeldet und sonstige)]  2899\n7 2 [Weiblich]   3 [Inaktiv]                             3434\n8 2 [Weiblich]  NA                                       3779",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#summary-statistics",
    "href": "03_desc.html#summary-statistics",
    "title": "3  Getting an Overview",
    "section": "3.4 Summary Statistics",
    "text": "3.4 Summary Statistics\nFor numerical variables, such as income (netges), we often compute summary statistics like the mean, median, or quantiles. To get a quick overview, use summary():\n\nsummary(pend$netges)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n    -5.0     -3.0     -3.0    567.9    990.0 111419.0 \n\n\n\n3.4.1 Handling Missing Data\nNegative values in the data (like -5 for netges) typically represent missing data. We can convert these to NA:\n\npend$netges[pend$netges &lt; 0] &lt;- NA\n\n\n\n3.4.2 Calculating Specific Statistics\nTo calculate specific statistics, we can use:\n\nMinimum: min()\nMaximum: max()\nMean: mean()\nMedian: median()\nQuantiles: quantile()\nVariance: var()\nStandard Deviation: sd()\n\nFor instance, the mean of income ignoring missing values:\n\nmean(pend$netges, na.rm = TRUE)\n\n[1] 1562.3\n\n\n\n\n3.4.3 Custom Summary with summarise()\nYou can use summarise() from {dplyr} to create custom summary tables:\n\npend %&gt;% summarise(\n  Minimum = min(netges, na.rm = TRUE),\n  Median = median(netges, na.rm = TRUE),\n  Mean = mean(netges, na.rm = TRUE),\n  Maximum = max(netges, na.rm = TRUE)\n)\n\n# A tibble: 1 × 4\n  Minimum   Median  Mean Maximum  \n  &lt;dbl+lbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt;\n1 0           1320 1562. 111419   \n\n\n\n\n3.4.4 Comparing Across Groups\nTo compare statistics across groups, use .by in summarise():\n\npend %&gt;% summarise(\n  Minimum = min(netges, na.rm = TRUE),\n  Median = median(netges, na.rm = TRUE),\n  Mean = mean(netges, na.rm = TRUE),\n  Maximum = max(netges, na.rm = TRUE),\n  .by = welle\n) %&gt;% arrange(welle)\n\n# A tibble: 13 × 5\n   welle                    Minimum   Median  Mean Maximum  \n   &lt;dbl+lbl&gt;                &lt;dbl+lbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt;\n 1  1 [Welle 1 (2006/2007)] 1          1200  1525. 111419   \n 2  2 [Welle 2 (2007/2008)] 0          1320  1529.   7200   \n 3  3 [Welle 3 (2008/2009)] 0          1298. 1498.  12000   \n 4  4 [Welle 4 (2010)]      0          1210  1447.  10800   \n 5  5 [Welle 5 (2011)]      0          1250  1494.  33363   \n 6  6 [Welle 6 (2012)]      0          1215  1459.  15950   \n 7  7 [Welle 7 (2013)]      0          1250  1539.  87835   \n 8  8 [Welle 8 (2014)]      0          1255  1456.   9000   \n 9  9 [Welle 9 (2015)]      0          1280  1613. 110451   \n10 10 [Welle 10 (2016)]     0          1375  1541.   6300   \n11 11 [Welle 11 (2017)]     0          1500  1748.  44440   \n12 12 [Welle 12 (2018)]     0          1500  1667.   7150   \n13 13 [Welle 13 (2019)]     0          1550  1816.  88453   \n\n\nYou can also filter for specific waves if needed:\n\npend %&gt;% \n  filter(welle %in% c(1, 10)) %&gt;% \n  summarise(\n    Minimum = min(netges, na.rm = TRUE),\n    Median = median(netges, na.rm = TRUE),\n    Mean = mean(netges, na.rm = TRUE),\n    Maximum = max(netges, na.rm = TRUE),\n    .by = welle\n  )\n\n# A tibble: 2 × 5\n  welle                    Minimum   Median  Mean Maximum  \n  &lt;dbl+lbl&gt;                &lt;dbl+lbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt;\n1  1 [Welle 1 (2006/2007)] 1           1200 1525. 111419   \n2 10 [Welle 10 (2016)]     0           1375 1541.   6300   \n\n\nThese methods allow for thorough analysis of both categorical and numerical data in R.\n\n\n3.4.5 Exercise",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html",
    "href": "04_viz_translated.html",
    "title": "4  Visualization with {ggplot2}",
    "section": "",
    "text": "4.1 ggplot2 and the Grammar of Graphics\nggplot2 is the implementation of the concept of “layered grammar of graphics” in R. The idea of this visualization system is to break down data visualization into parameters: the underlying dataset, the variables to be displayed, the choice of display shapes, the coordinate system, scales, and statistical transformations. A standard command in ggplot2 looks something like this:\nggplot(data = dataset, aes(x = var1, y = var2, color = var3)) +\n  geom_point() +\n  labs(title= \"Title\", subtitle = \"Subtitle\") +\n  theme_minimal()\nSo we first call up a plot with ggplot(). Further arguments then define additional aspects:\nNow we will work through the individual layers of the graphic:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#ggplot2-and-the-grammar-of-graphics",
    "href": "04_viz_translated.html#ggplot2-and-the-grammar-of-graphics",
    "title": "4  Visualization with {ggplot2}",
    "section": "",
    "text": "With data =, we specify the data.frame we want to visualize.\nThe aesthetics aes() specify which variables are to be displayed: here var1 on the x-axis, var2 on the y-axis, and var3 for coloring.\nThe layers geom_.. specify the type of display, e.g., geom_point() for point plots and geom_bar() for bar charts.\nWith labs, we can add labels, such as a title or axis labels.\nThe themes theme_... set the design of the graphic, e.g., black and white axes and background colors with theme_bw().\n\n\n\n4.1.1 data =\nIn data =, we specify the data.frame that contains the information to be visualized. We start our ggplot with:\n\nggplot(data = pend_small)\n\n\n\n\n\n\n\n\n\n\n4.1.2 aes\nWe want to visualize these values in a scatterplot, with age on the x-axis and weekly working hours on the y-axis:\n\nggplot(data = pend_small, aes(x = palter, y = azges1))\n\n\n\n\n\n\n\n\n\n\n4.1.3 geom\nIf we only provide these details, we will get an empty coordinate system—why? Because we haven’t yet specified what form of display we want. For this, we must specify a geom_, such as geom_col() for bar charts, which we attach to the ggplot command with +:\n\nggplot(data = pend_small, aes(x = palter, y = azges1)) + geom_point()\n\n\n\n\n\n\n\n\nWith color =, we can also change the color of the points:\n\nggplot(data = pend_small, aes(x = palter, y = azges1)) + geom_point(color = \"orange\")\n\n\n\n\n\n\n\n\nHere is an overview of all color names that are recognized, though there are many more colors—see Appendix.\n\n\n4.1.4 aes() Part II\nThis already looks pretty good, but the points are not yet separated by gender. To do this, we need to include the gender information (zpsex) in aes(). In addition to the axes, aes() also specifies the variables for the appearance of the geom_s—this can include not only color but also shape, size, or transparency. Here’s an overview.\nGender should determine the color of the points, which we can specify in aes with color:\n\n# results in an error due to labels:\nggplot(data = pend_small, aes(x = palter, y = azges1, color = zpsex )) + \n  geom_point()\n\nError in UseMethod(\"rescale\"): nicht anwendbare Methode für 'rescale' auf Objekt der Klasse \"c('haven_labelled', 'vctrs_vctr', 'double')\" angewendet\n\n\nA numeric variable for color = results in a color gradient, while a factor/character variable results in a discrete color scale:\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.numeric(zpsex))) + \n  geom_point()\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.factor(zpsex))) + \n  geom_point()\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.character(zpsex))) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also specify custom colors with scale_color_manual1, and a list of possible colors can be found here.\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.factor(zpsex))) + \n  geom_point() + \n  scale_color_manual(values = c(\"lightskyblue4\",\"navy\"))\n\n\n\n\n\n\n\n\n\n\n4.1.5 Labels\nWith the breaks and labels options, we can also edit the legend labels. To do this, we first specify the levels of the gender variable in breaks and then the corresponding labels in the same order:\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.factor(zpsex))) + \n  geom_point() + \n  scale_color_manual(values = c(\"lightskyblue4\",\"navy\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\n\n\n\n\n\n\n\n\nFinally, we adjust the labels with labs, where we have the following options:\n\ntitle: Title for the graphic\nsubtitle: Subtitle for the title\ncaption: Annotation below the graphic\nx: x-axis label\ny: y-axis label\nfill: Legend label when fill is specified in aes()\ncolor: Legend label when color is specified in aes()\nlinetype: Legend label when linetype is specified in aes()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#footnotes",
    "href": "04_viz_translated.html#footnotes",
    "title": "4  Visualization with {ggplot2}",
    "section": "",
    "text": "If we had specified color in aes, the corresponding command would be scale_color_manual.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#combination-of-all-options",
    "href": "04_viz_translated.html#combination-of-all-options",
    "title": "4  Visualization with {ggplot2}",
    "section": "4.2 Combination of all options",
    "text": "4.2 Combination of all options\n\nggplot(data = pend_small, aes(x = palter, y = azges1, \n                               shape = as.factor(zpsex),\n                               color = as.factor(zpsex))) + \n  geom_point(size = 4) + \n  scale_color_manual(values = c(\"lightskyblue\",\"orange\"),\n                     breaks = c(1,2), labels = c(\"Men\", \"Women\")\n                     ) +\n  scale_shape_manual(values = c(18,20),\n                     breaks = c(1,2), labels = c(\"Men\", \"Women\")\n                     ) +\n  labs(color = \"Gender\", \n       shape = \"Gender\",\n       y = \"Hours/Week\",\n       x = \"Age\",\n       title = \"Working hours and age\",\n       subtitle = \"By Gender\",\n       caption = \"Soruce: PASS CF 0619\"\n       ) \n\n\n\n\n\n\n\n\nÜbersicht zu shapes\n\n\n\n\n\n\n\n\n\n\nMit der folgenden Syntax können wir mit ggplot2 einen Boxplot erstellen. Da wir nur eine Variable betrachten, müssen wir lediglich y = oder x = angeben - je nachdem ob die Box vertikal oder horizontal orientiert sein soll.\n\nggplot(data = pend_small, aes(y = azges1)) + geom_boxplot()\n\n\n\n\n\n\n\n\nSo können wir einen Boxplot erstellen, der die Werte für Männer und Frauen getrennt darstellt:\n\nggplot(data = pend_small, aes(y = azges1, x = factor(zpsex))) + geom_boxplot()\n\n\n\n\n\n\n\n\n\n4.2.1 Histogram\nEbenso können Verteilungen mit einem Histogramm beschrieben werden:\n\nggplot(data = pend_small, aes(x = azges1)) + \n  geom_histogram()  \n\n\n\n\n\n\n\n\nWenn wir hier die Farbe ändern möchten, dann ist fill = anstelle von color = die richtige Option:\n\nggplot(data = pend_small, aes(x = azges1)) + \n  geom_histogram(fill = \"sienna1\")  \n\n\n\n\n\n\n\n\nMöchten wir das Histogramm nach Geschlecht aufsplitten, können wir auch hier wieder fill als Aesthetic angeben. Mit position = position_dodge() können wir die Balken nebeneinander stellen lassen:\nggplot(data = pend_small, aes(x = azges1, fill = factor(zpsex))) + \n  geom_histogram() \nggplot(data = pend_small, aes(x = azges1, fill = factor(zpsex))) + \n  geom_histogram(position = position_dodge()) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAuch hier funktionieren natürlich wieder die scale_...manual Befehle, allerdings hier als scale_fill_manual anstelle scale_color_manual von oben:\n\nggplot(data = pend_small, aes(x = azges1, fill = factor(zpsex))) + \n  geom_histogram(position = position_dodge()) +\n  scale_fill_manual(values = c(\"sienna1\",\"dodgerblue4\"),\n                    breaks = 1:2, labels = c(\"Männer\",\"Frauen\")) +\n  labs(fill = \"Geschlecht\")\n\n\n\n\n\n\n\n\n\n\n4.2.2 Übung",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#kategoriale-merkmale",
    "href": "04_viz_translated.html#kategoriale-merkmale",
    "title": "4  Visualization with {ggplot2}",
    "section": "4.3 Kategoriale Merkmale",
    "text": "4.3 Kategoriale Merkmale\nIm Folgenden sehen wir uns eine Möglichkeit an, die Kontingenztabelle aus Kapitel 2 zu visualisieren:\n\npend_small$PD0400[pend_small$PD0400&lt;0] &lt;- NA # missings ausschließen\npend_small %&gt;% \n  count(zpsex,PD0400) \n\n# A tibble: 10 × 3\n   zpsex         PD0400                              n\n   &lt;dbl+lbl&gt;     &lt;dbl+lbl&gt;                       &lt;int&gt;\n 1 1 [Maennlich]  1 [Ueberhaupt nicht religioes]    40\n 2 1 [Maennlich]  2 [Eher nicht religioes]          41\n 3 1 [Maennlich]  3 [Eher religioes]                49\n 4 1 [Maennlich]  4 [Sehr religioes]                22\n 5 1 [Maennlich] NA                                780\n 6 2 [Weiblich]   1 [Ueberhaupt nicht religioes]    26\n 7 2 [Weiblich]   2 [Eher nicht religioes]          34\n 8 2 [Weiblich]   3 [Eher religioes]                40\n 9 2 [Weiblich]   4 [Sehr religioes]                16\n10 2 [Weiblich]  NA                                816\n\n\nMit geom_bar() können wir Säulen darstellen, indem wir ..count.. für y die Höhe als Anzahl der Beobachtungen festlegen:\n\npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(x = as_factor(PD0400), fill = factor(zpsex),\n                       y = ..count..)) +\n  geom_bar(position=position_dodge()) \n\n\n\n\n\n\n\n\nWie kommen wir jetzt an die relativen Häufigkeiten? Wir passen unsere aes auf y = (..count..)/sum(..count..) an. Mit scale_y_continuous(labels = scales::label_percent(accuracy = 1)) können wir außerdem auf der y-Achse die Prozentwerte anzeigen lassen:\n\npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(x = as_factor(PD0400), fill = factor(zpsex),\n                       y = (..count..)/sum(..count..) )) +\n  geom_bar(position=position_dodge()) +\n  scale_y_continuous(labels = scales::label_percent(accuracy = 1)) \n\n\n\n\n\n\n\n\nUm jetzt ein Balken- statt einem Säulendiagramm zu erhalten, tauschen wir einfach x und y sowie die Prozentbeschriftung auf scale_x_continuous:\n\npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(y = as_factor(PD0400), fill = factor(zpsex),\n                       x = (..count..)/sum(..count..) )) +\n  geom_bar(position=position_dodge()) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) \n\n\n\n\n\n\n\n\nAuch diese Grafiken können wir dann wieder mit scale_... anpassen und mit labs() ausführlich labeln - alle Optionen sind konsistent über alle Darstellungsformen hinweg. Außerdem können wir die Kategorien mit breaks = und labels = auch selbst labeln, wenn uns die definierten Labels nicht gefallen:\npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(y = as_factor(PD0400), fill = factor(zpsex),\n                       x = (..count..)/sum(..count..) )) +\n  geom_bar(position=position_dodge()) +\n  scale_fill_manual(values = c(\"navajowhite\",\"navy\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\")) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  labs(title = \"Religiösität nach Geschlecht\",\n       subtitle = \"Relative Häufigkeiten\",\n       caption = \"Quelle: PASS-CF 0619\",\n       y = \"Religiösität\",\n       x = \"Relative Häufigkeit\",\n       fill = \"Geschlecht\" ) \npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(y = PD0400, fill = factor(zpsex),\n                       x = (..count..)/sum(..count..) )) +\n  geom_bar(position=position_dodge()) +\n  scale_fill_manual(values = c(\"navajowhite\",\"navy\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\")) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  scale_y_continuous(breaks = 1:4, \n                     labels = c(\"Überhaupt nicht\",\n                                \"Eher nicht\",\n                                \"Eher schon\",\n                                \"Sehr\")) +\n  labs(title = \"Religiösität nach Geschlecht\",\n       subtitle = \"Relative Häufigkeiten\",\n       caption = \"Quelle: PASS-CF 0619\",\n       y = \"Religiösität\",\n       x = \"Relative Häufigkeit\",\n       fill = \"Geschlecht\" ) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.3.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#übungen",
    "href": "04_viz_translated.html#übungen",
    "title": "4  Visualization with {ggplot2}",
    "section": "4.4 Übungen",
    "text": "4.4 Übungen\nNutzen Sie für alle Aufgaben die ersten 150 Beobachtungen (pend_small), um den Plot einfach zu halten. Denken Sie daran die fehlenden Werte mit filter() auszuschließen, Sie können dazu diesen Befehl verwenden:\n\npend &lt;-\n  haven::read_dta(\"./orig/PENDDAT_cf_W13.dta\",\n    col_select = c(\"zpsex\",\"welle\",\"bilzeit\",\"PA0445\",\"PG1270\",\"PEO0400c\")\n    )\n\n\n4.4.1 Übung 1\n\npend_u41 &lt;-\n  pend %&gt;% \n  filter(welle == 13, bilzeit &gt; 0, PA0445 &gt;0) \n\n\nErstellen Sie einen Scatterplot für die Variablen Dauer der gesamten Arbeitslosigkeitserfahrung in Monaten (PA0445, y-Achse) und Dauer der Ausbildung (bilzeit, x-Achse).\nLegen Sie die Farbe so fest, dass Männer und Frauen unterschiedliche Farben gekennzeichnet werden (zpsex)\nVerändern Sie die Farben auf goldenrod1 und dodgerblue4 fest (oder eine beliebige andere)\nBeschriften Sie die Achsen und Legende!\n\nZurück nach oben\n\n\n4.4.2 Übung 2\n\npend_u42 &lt;-\n  pend %&gt;% \n  filter(welle == 9, PG1270 &gt;0) \n\n\nErstellen Sie einen Boxplot oder Histogramm für die Verteilung der Anzahl gerauchter Zigaretten und Zigarillos pro Tag (i.d. letzten Woche) (PG1270).\nPassen Sie diese Grafik so an, dass die Verteilungen für Männer und Frauen getrennt dargestellt werden.\nWie können Sie auch die Farben nach dem Geschlecht getrennt anlegen? (Denken Sie an color = und fill =)\nVerändern Sie die Farben der Balken mit Hilfe von scale_fill_manual oder scale_fill_brewer oder scale_fill_viridis (Siehe Abschnitte Farben und ColorBreweR und viridis unter “weitere Optionen”)\n\nZurück nach oben\n\n\n4.4.3 Übung 3\n\npend_u43 &lt;-\n  pend %&gt;% \n  filter(welle == 11, PEO0400c &gt;0) \n\n\nErstellen Sie ein Säulen-Diagramm für die Antworten auf die Frage “Eine berufstätige Mutter kann ein genauso herzliches Verhältnis zu ihren Kindern haben, wie eine Mutter, die nicht erwerbstätig ist.” (PEO0400c)\nErstellen Sie ein Säulen-Diagramm für d(PEO0400c) getrennt nach der Variable migration, legen Sie also die Farbe der Säulen nach migration fest. Die Variable migration erfasst, ob die Befragten einen Migrationshintergrund haben:\n\n\n\nVariablevaluelabel`PEO0400c`1Stimme voll und ganz zu2Stimme eher zu3Stimme eher nicht zu4Stimme ueberhaupt nicht zu`migration`1Kein Migrationshintergrund2selbst / mind. 1 Elternteil zugezogen3Mind. 1 Elternteil zugezogen4Mind. 1 Grosselt. zugez., Elt. in D geb.\n\n\nZurück nach oben",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#weitere-optionen-für-ggplot2",
    "href": "04_viz_translated.html#weitere-optionen-für-ggplot2",
    "title": "4  Visualization with {ggplot2}",
    "section": "4.5 Weitere Optionen für ggplot2",
    "text": "4.5 Weitere Optionen für ggplot2\n\n4.5.1 Aesthetics\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5.2 themes\nMit sog. themes können wir das layout der Grafik verändern. Weitere Themes sind zB: theme_light(), theme_classic() ider theme_void(), eine Liste findet sich hier. Außerdem bietet das Paket {ggthemes} (install.packages('ggthemes')) eine große Auswahl.\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 2) + \n  theme_minimal()\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 2) +\n  theme_dark()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5.3 Farben\n\np1 &lt;- ggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 3) \n\nNeben den im Beispiel verwendeten Farben für fill können natürlich auch noch unzählige weitere Farben in scale_fill_manual und scale_color_manual verwendet werden:\n\nHier findet sich eine Übersicht mit allen Farbnamen, die verstanden werden\nAlternativ können auch sog. HEX-Codes angeben werden, die bspw. mit dem Adobe Color Wheel oder Color Hex erstellt werden können.\n\np1 +  scale_color_manual(values = c(\"dodgerblue4\",\"sienna1\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\np1 +  scale_color_manual(values = c(\"#005b96\",\"#6497b1\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5.3.1 ColorBreweR\nAlternativ zur manuellen Auswahl der Farben mit scale_fill_manual und scale_color_manual können mit scale_fill_brewer() auch vorgegebene Farbpaletten des colorbrewer verwendet werden. Dazu muss lediglich scale_fill_brewer() anstelle von scale_fill_manual angeben werden und statt values eine der Paletten - eine Übersicht findet sich hier. Die Farbpaletten von ColorBreweR sind alle in ggplot2 integriert.\n\np1 +\n  scale_color_brewer(palette = \"RdYlBu\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n4.5.3.2 viridis\nAnalog dazu gibt es auch die {viridis}-Paletten, welche durchgängig “colorblind-safe” und ebenfalls in {ggplot2} integriert sind. Allerdings ist hier zu beachten, dass für Farbauswahlen basierend auf einer kategorialen Variable scale_color_viridis_d() zu verwenden ist. Soll die Farbe entlang einer numerischen/metrischen Variable bestimmt werden, dann ist scale_color_viridis_c() zu verwenden. Außerdem kann mit begin und end die Breite der Farbskala angepasst werden:\np1 +\n  scale_color_viridis_d(option=\"magma\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \np1 +\n  scale_color_viridis_d(option=\"magma\",begin = .65,end = .85,\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5.3.3 Weitere Farbpaletten\nDarüber hinaus gibt es unzählige Pakete, die ebenfalls scale_color_ und scale_fill_-Funktionen bieten: Hier noch zwei Beispiele mit {scico} und {MetBrewer}, welches Farben aus Bildern im Metropolitan Museum of Art enthält:\n\ninstall.packages('scico')\ninstall.packages(\"MetBrewer\")\n\n{scico} Farbpaletten\n\n\n\n\n\n\n\n\n\n{MetBrewer} Farbpaletten\n\n\n\n\n\n\n\n\n\nlibrary(scico)\np1 +\n  scale_color_scico_d(palette = \"oslo\",begin = .5,end = .8,\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \nlibrary(MetBrewer)\np1 +\n  scale_color_met_d(name = \"Kandinsky\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVergleichbare Pakete gibt es auch für\n\n{DutchMasters} - Farbpaletten aus Bildern niederländischer Maler\n{wesanderson} - Farbpaletten basierend auf verschiedenen Filmen von Wes Anderson (The Grand Budapest Hotel usw.)\n{ochRe} - Farbpaletten “inspired by Australian art, landscapes and wildlife”\n{paletteer} bietet eine riesige Auswahl verschiedenster Farbpaletten\n\n\n\n\n4.5.4 Shapes\n\n\n\n\n\n\n\n\n\nZusätzlicher Überblick\n\n\n4.5.5 Linetypes\n\n\n\n\n\n\n\n\n\nÜbersicht zu Shapes und Linetypes im R Cookbook",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#linksammlung",
    "href": "04_viz_translated.html#linksammlung",
    "title": "4  Visualization with {ggplot2}",
    "section": "4.6 Linksammlung",
    "text": "4.6 Linksammlung\n\nDas Graph Kapitel des R Cookbooks ist eine hervorragende Quelle für alle möglichen Optionen und eine grundlegende Übersicht - bspw. zur Anpassung der Legende, Linien- und Punktvarianten oder den Achsen\nSchriftgröße und -farbe anpassen: Hier findet sich eine gute Übersicht, wie die Schriftgröße und -farbe in {ggplot2} angepasst werden kann.\nFrom Data to Viz bietet einen Entscheidungsbaum für verschiedene Zusammenhänge und Deskriptionen mit Beispiel-Syntax\n\n\n\n\n\n\n\n\n\n\n\nDie R Graph Gallery ist noch etwas umfangreicher und bietet noch weitere Visualisierungsideen\nFür alle, die mehr zu gelungenen (und schönen) Datenvisualisierungen mit {ggplot2} erfahren möchten, ist das Tutorial von Cédric Scherer ein hervorragender Einstieg. Dieser Workshop eignet sich sehr gut für eine Vertiefung.\nDieser Workshop bietet weitere Einblicke wie Datenvisualisierungen mit {ggplot2} schöner gestaltet werden können.\nEine Liste von Erweiterungen für ggplot2\nDas Buch zu {ggplot2}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#more-options-for-ggplot2",
    "href": "04_viz_translated.html#more-options-for-ggplot2",
    "title": "4  Visualization with {ggplot2}",
    "section": "4.5 More options for {ggplot2}",
    "text": "4.5 More options for {ggplot2}\n\n4.5.1 Aesthetics\n\n\n\n\n\n\n\n\n\n\n\n4.5.2 themes\nWith so-called themes, we can change the layout of the graphic. Other themes include theme_light(), theme_classic(), or theme_void(). A full list can be found here. Additionally, the {ggthemes} package (install.packages('ggthemes')) offers a wide selection.\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 2) + \n  theme_minimal()\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 2) +\n  theme_dark()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5.3 Farben\n\np1 &lt;- ggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 3) \n\nNeben den im Beispiel verwendeten Farben für fill können natürlich auch noch unzählige weitere Farben in scale_fill_manual und scale_color_manual verwendet werden:\n\nHier findet sich eine Übersicht mit allen Farbnamen, die verstanden werden\nAlternativ können auch sog. HEX-Codes angeben werden, die bspw. mit dem Adobe Color Wheel oder Color Hex erstellt werden können.\n\np1 +  scale_color_manual(values = c(\"dodgerblue4\",\"sienna1\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\np1 +  scale_color_manual(values = c(\"#005b96\",\"#6497b1\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5.3.1 ColorBreweR\nAlternativ zur manuellen Auswahl der Farben mit scale_fill_manual und scale_color_manual können mit scale_fill_brewer() auch vorgegebene Farbpaletten des colorbrewer verwendet werden. Dazu muss lediglich scale_fill_brewer() anstelle von scale_fill_manual angeben werden und statt values eine der Paletten - eine Übersicht findet sich hier. Die Farbpaletten von ColorBreweR sind alle in ggplot2 integriert.\n\np1 +\n  scale_color_brewer(palette = \"RdYlBu\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n4.5.3.2 viridis\nAnalog dazu gibt es auch die {viridis}-Paletten, welche durchgängig “colorblind-safe” und ebenfalls in {ggplot2} integriert sind. Allerdings ist hier zu beachten, dass für Farbauswahlen basierend auf einer kategorialen Variable scale_color_viridis_d() zu verwenden ist. Soll die Farbe entlang einer numerischen/metrischen Variable bestimmt werden, dann ist scale_color_viridis_c() zu verwenden. Außerdem kann mit begin und end die Breite der Farbskala angepasst werden:\np1 +\n  scale_color_viridis_d(option=\"magma\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \np1 +\n  scale_color_viridis_d(option=\"magma\",begin = .65,end = .85,\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.5.3.3 Weitere Farbpaletten\nDarüber hinaus gibt es unzählige Pakete, die ebenfalls scale_color_ und scale_fill_-Funktionen bieten: Hier noch zwei Beispiele mit {scico} und {MetBrewer}, welches Farben aus Bildern im Metropolitan Museum of Art enthält:\n\ninstall.packages('scico')\ninstall.packages(\"MetBrewer\")\n\n{scico} Farbpaletten\n\n\n\n\n\n\n\n\n\n{MetBrewer} Farbpaletten\n\n\n\n\n\n\n\n\n\nlibrary(scico)\np1 +\n  scale_color_scico_d(palette = \"oslo\",begin = .5,end = .8,\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \nlibrary(MetBrewer)\np1 +\n  scale_color_met_d(name = \"Kandinsky\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparable packages also exist for:\n\n{DutchMasters} - Color palettes from paintings by Dutch masters.\n{wesanderson} - Color palettes based on various Wes Anderson films (e.g., The Grand Budapest Hotel).\n{ochRe} - Color palettes “inspired by Australian art, landscapes, and wildlife.”\n{paletteer} offers a vast selection of various color palettes.\n\nCheck out the interactive color picker here\n\n\n\n4.5.4 Shapes\n\n\n\n\n\n\n\n\n\nZusätzlicher Überblick\n\n\n4.5.5 Linetypes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview\n\n\n\nShapes und Linetypes at a glance in the R Cookbook",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#useful-links",
    "href": "04_viz_translated.html#useful-links",
    "title": "4  Visualization with {ggplot2}",
    "section": "4.6 Useful links",
    "text": "4.6 Useful links\n\nThe Graphs chapter of the R Cookbook is an excellent resource for various options and a basic overview—for example, on adjusting the legend, line and point types, or the axes.\nAdjusting font size and color: This guide provides a good overview of how to modify font size and color in {ggplot2}.\nFrom Data to Viz offers a decision tree for various relationships and descriptions with example syntax.\n\n\n\n\n\n\n\n\n\n\n\nThe R Graph Gallery is even more extensive and offers additional visualization ideas.\nFor those who want to learn more about effective (and beautiful) data visualizations with {ggplot2}, Cédric Scherer’s tutorial is an excellent introduction. This workshop is great for further exploration.\nThis workshop offers additional insights on how to make data visualizations more appealing with {ggplot2}.\nA list of extensions for ggplot2.\nThe book on {ggplot2}.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  }
]