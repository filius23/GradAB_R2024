[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GradAB R Intro 2024",
    "section": "",
    "text": "Welcome!\nIntroduction to R for GradAB and IAB people.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#course-dates",
    "href": "index.html#course-dates",
    "title": "GradAB R Intro 2024",
    "section": "Course dates",
    "text": "Course dates\n\n   11.09. & 13.09.2024\n   9:00 – 15:00\n   E09",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "1  Getting started with R",
    "section": "",
    "text": "1.1 Installing and Setting Up R & RStudio\nR is a completely free program that you can download from CRAN. The RStudio extension is also free and can be downloaded here. RStudio enhances R by providing a significantly more informative and appealing interface, help, and auto-completion when writing syntax, as well as an overall improved user interface. However, RStudio is an extension of R, so you need both programs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#installing-and-setting-up-r-rstudio",
    "href": "01_intro.html#installing-and-setting-up-r-rstudio",
    "title": "1  Getting started with R",
    "section": "",
    "text": "Install R first and then RStudio, so that RStudio recognizes the installed R version, and the two programs usually connect automatically. R is essentially the engine, and RStudio is our cockpit. We could work directly with R, but RStudio offers a more comfortable option and a better overview.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.1: R and RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#setting-up-rstudio",
    "href": "01_intro.html#setting-up-rstudio",
    "title": "1  Getting started with R",
    "section": "1.2 Setting Up RStudio",
    "text": "1.2 Setting Up RStudio\nAfter successful installation, open the RStudio application  and you should see the following view:\n\nTo avoid problems when working with R in the future, please disable the automatic saving and loading of the workspace. To do this, go to the appropriate menu under the “Tools -&gt; Global options” tab, disable “Restore .RData into workspace at startup,” and set “Save workspace to .RData on exit:” to Never. Otherwise, RStudio will save all loaded objects when you end the session and automatically load them the next time you open the program, which can lead to problems.\n\nConfirm the settings with “Apply” and close the window with “OK.”",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#first-steps-in-r",
    "href": "01_intro.html#first-steps-in-r",
    "title": "1  Getting started with R",
    "section": "1.3 First Steps in R",
    "text": "1.3 First Steps in R\nAfter these basic settings, we can start with the first steps in R. To do this, first open a script by clicking on the white icon in the top left corner or pressing CTRL/Command + Shift + N simultaneously.\n\nA fourth window opens, so you should now see the following view:\n\nThis script editor is where we will create and execute commands. The script editor serves as a collection of all commands to be executed. We can save these collections to revisit them later, and, more importantly, we can share command collections with others or use scripts from others for ourselves. So, we first draft a calculation in the script editor:\n\nTo execute it, click on the line to be executed so that the cursor is in that line, and then press CTRL and Enter simultaneously (Mac users: Command and Enter):\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.2: Shortcuts for Calculations\n\n\n\nR outputs the results in the console below:\n\nThis also works for multiple calculations at once by selecting multiple lines and then pressing CTRL and Enter again (Mac users: Command and Enter):\n\nInputs from the script editor and results from the console will be presented like this in the future:\n\n2+5\n\n[1] 7\n\n3-4\n\n[1] -1\n\n5*6\n\n[1] 30\n\n7/8\n\n[1] 0.875\n\n\nOf course, R also handles longer calculations, such as following the order of operations:\n\n2+3*2\n\n[1] 8\n\n(2+3)*2\n\n[1] 10\n\n\nOther operations are also possible:\n\n4^2 ## 4²\nsqrt(4) ## Square root \nexp(1) ## Exponential function (Euler's number)\nlog(5) ## Natural logarithm\nlog(exp(5)) ## log and exp cancel each other out\n\nWe can create sequences of numbers using seq() or ::\n\n2:6\n\n[1] 2 3 4 5 6\n\nseq(2,11,3)\n\n[1]  2  5  8 11\n\n\n\n1.3.1 Creating Objects\nSo far, we have always displayed our calculations directly. For more extensive calculations—since we want to work with datasets starting in the next chapter—we want to save the intermediate steps.\nResults can be saved as objects under any name using &lt;-. R will then not display the result but will repeat the command in the console:\n\nx &lt;- 4/2\n\nIn the “Environment” window at the top right, you can now see the stored object x:\n\nWe can retrieve it later:\n\nx\n\n[1] 2\n\n\nAdditionally, we can use objects in calculations—we simply use x and create, for example, y:\n\ny &lt;- x * 5\ny\n\n[1] 10\n\n\n\n\n\n1.3.2 Storing Multiple Values\nWith c(), we can store multiple values under one object, and these can also be used in calculations:\n\nx1 &lt;- c(1,2,3)\nx1\n\n[1] 1 2 3\n\nx1* 2\n\n[1] 2 4 6\n\n\nWith length(), we can check the number of stored values:\n\nlength(x1)\n\n[1] 3\n\n\n\ny1 &lt;- c(10,11,9)\ny1\n\n[1] 10 11  9\n\ny1/x1\n\n[1] 10.0  5.5  3.0\n\n\n\n\n1.3.3 Deleting Values\nOf course, we can also delete objects using rm(). If we try to call a non-existent object, we will get an error message:\n\nrm(x1)\nx1\n\nError in eval(expr, envir, enclos): Objekt 'x1' nicht gefunden\n\n\nWith rm(list = ls()), all objects can be removed from the environment.\n\n\n1.3.4 Saving Scripts\nWe can save the script to call it again later.\n\nIt is important to give the saved file the extension “.R”, for example, “01_Script.R”.\n\n\n1.3.5 Comments\nBesides the actual commands, comments are a central part of a data analysis syntax. This allows future users (especially ourselves in 3 weeks or 2 years) to understand what is happening. Comments in R can be added with #:\n\n2+ 5 # this is a comment\n\n[1] 7\n\n2+ # a comment can also be placed here\n  5\n\n[1] 7\n\n\n\n( 2 + # a \n    3) * # comment\n  2 # across multiple lines\n\n[1] 10\n\n\nTip: It’s best to create a folder right away where you can store all R scripts and datasets from this course.\n\n\n1.3.6 Structuring Scripts\n\n# Heading 1 ----\n\n## Section 1.1 ----\n3+2*4\n3+2*3\n## Section 1.2 ----\n3+2*sqrt(3)\n\n# Heading 2 ----\nx &lt;- c(2,6,8,2,35)\ny &lt;- seq(2,10,2)\n\ny/x",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "01_intro.html#exercises",
    "href": "01_intro.html#exercises",
    "title": "1  Getting started with R",
    "section": "1.4 Exercises",
    "text": "1.4 Exercises\n\nCreate a sequence of numbers from 7 to 13. How can you adjust the sequence with seq() so that only the odd numbers are generated?\nStore the number of students at the University of Oldenburg (15643) in stud.\nStore the number of professorships at the University of Oldenburg (210) in prof.\nCalculate the number of students per professorship at the University of Oldenburg using the objects stud and prof.\nStore the result in studprof and recall the object again!\nDo you see the created variables in the Environment window?\nStore the student numbers of the University of Bremen (19173), University of Vechta (5333), and University of Oldenburg (15643) together in studs.\nStore the number of professors at the University of Bremen (322), University of Vechta (67), and University of Oldenburg (210) together in profs.\nCalculate the number of students per professorship for all three universities.\nYou also want to include the student numbers (14000) and professorships (217) of the University of Osnabrück in studs and profs. How would you do that?\nCalculate the ratio of students to professorships for all four universities!\nDelete the object stud. How can you tell that it worked?\nDelete all objects from the Environment. How can you tell that it worked?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting started with R</span>"
    ]
  },
  {
    "objectID": "02_intro.html",
    "href": "02_intro.html",
    "title": "2  Working with Datasets",
    "section": "",
    "text": "2.1 Data Structures in R: data.frame\nIn the previous chapter, we combined the student numbers of the University of Bremen (19173), University of Vechta (5333), and University of Oldenburg (15643) under studs and related them to the professor numbers stored in profs. While this works fine, it is more organized to store related values together. For this, R provides the data.frame. We can store the two objects in a dataset by entering them into data.frame and storing the new object under dat1. When we call dat1, we see that the values have been combined row by row:\nstuds &lt;- c(19173, 5333, 15643)  # Store student numbers under \"studs\"\nprofs &lt;- c(322, 67, 210)        # Store professor numbers under \"profs\"\ndat1_orig &lt;- data.frame(studs, profs)\ndat1_orig\n\n  studs profs\n1 19173   322\n2  5333    67\n3 15643   210\ndat1 &lt;- data.frame(studs = c(19173, 5333, 15643), \n                   profs = c(322, 67, 210),\n                   gegr  = c(1971, 1830, 1973)) # Without intermediate objects\ndat1    # Display the entire dataset\n\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\nIn the first row, we see the values for the University of Bremen, in the second row for the University of Vechta, and so on. We can access the columns using dataset_name$variable_name. For example, we can display the profs column:\ndat1$profs \n\n[1] 322  67 210\nWe can display the variable/column names of the dataset with colnames()/names(). Additionally, we can call the number of rows and columns using nrow and ncol:\ncolnames(dat1) ## Display variable/column names\n\n[1] \"studs\" \"profs\" \"gegr\" \n\nnames(dat1) ## Display variable/column names\n\n[1] \"studs\" \"profs\" \"gegr\" \n\nncol(dat1) ## Number of columns/variables\n\n[1] 3\n\nnrow(dat1) ## Number of rows/cases\n\n[1] 3\nWe can add new variables to the dataset by using dataset_name$new_variable:\ndat1$stu_prof &lt;- dat1$studs/dat1$profs\n## dat1 now has one more column:\nncol(dat1) \n\n[1] 4\n\ndat1\n\n  studs profs gegr stu_prof\n1 19173   322 1971 59.54348\n2  5333    67 1830 79.59701\n3 15643   210 1973 74.49048\nWe can also store one or more words in a variable, but letters/words must always be enclosed in \"\".\ndat1$uni &lt;- c(\"Uni Bremen\", \"Uni Vechta\", \"Uni Oldenburg\")\ndat1\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\nWith View(dat1), a new window opens where we can view the entire dataset:\nView(dat1)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#data-types-in-r",
    "href": "02_intro.html#data-types-in-r",
    "title": "2  Working with Datasets",
    "section": "2.2 Data Types in R",
    "text": "2.2 Data Types in R\nSo far, we have encountered two variable types: numeric (contains numbers) and character (contains text or numbers that are understood as text). We also learned an organization method: data.frame.\nThe following variable types in R are important for us:2\n\n\n\n\n\n\n\n\n\n\n\n\nVectors\n\n\n\n\ninteger  double\nNumeric values (numeric)\n\n\ncharacter\nText (or numbers understood as text)\n\n\nfactor\nText or numbers understood as text with predefined sorting and fixed value universe\n\n\nlogical\nTRUE or FALSE—mostly the result of a comparison (greater/less/equal)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCombined Vectors\n\n\n\n\ndata.frame  tibble\nTwo-dimensional data structure organized in tabular form—tibble is an enhancement of data.frame in the tidyverse (more on this later)\n\n\nlist\nOrdered collection of vectors of different types—can contain other value types, data.frame, or even other lists\n\n\n\n\n\n\n\nFor now, we focus on character and numeric variables. We will discuss the other types when they are needed. With class(), we can examine the type of a variable, or with is.numeric() or is.character(), we can check whether a variable belongs to a certain type:\n\nclass(dat1$profs)\n\n[1] \"numeric\"\n\nclass(dat1$uni)\n\n[1] \"character\"\n\nis.numeric(dat1$profs)\n\n[1] TRUE\n\nis.character(dat1$profs)\n\n[1] FALSE\n\n\nWe can enforce a type change with as.character() or as.numeric():\n\nas.character(dat1$profs) ## The \"\" indicate that the variable is defined as character\n\n[1] \"322\" \"67\"  \"210\"\n\n\nThis does not change the original variable dat1$profs:\n\nclass(dat1$profs)\n\n[1] \"numeric\"\n\n\nIf we want to keep this conversion for dat1$profs, we need to overwrite the variable:\n\ndat1$profs &lt;- as.character(dat1$profs)\ndat1$profs \n\n[1] \"322\" \"67\"  \"210\"\n\nclass(dat1$profs)\n\n[1] \"character\"\n\n\nWe cannot perform calculations with character variables, even if they contain numbers:\n\ndat1$profs / 2 \n\nError in dat1$profs/2: nicht-numerisches Argument für binären Operator\n\n\nHowever, we can convert dat1$profs to numeric on the fly to perform calculations:\n\nas.numeric(dat1$profs)\n\n[1] 322  67 210\n\nas.numeric(dat1$profs) / 2\n\n[1] 161.0  33.5 105.0\n\n\nIf we convert text variables to numeric, calculations result in NA. NA in R stands for missing values:\n\nas.numeric(dat1$uni)\n\nWarning: NAs durch Umwandlung erzeugt\n\n\n[1] NA NA NA\n\n\nR, understandably, does not know how to convert university names into numbers.\n\n\n\n\n\n\nA common issue in calculations is due to incorrect variable types.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#selecting-rows-columns",
    "href": "02_intro.html#selecting-rows-columns",
    "title": "2  Working with Datasets",
    "section": "2.3 Selecting Rows & Columns",
    "text": "2.3 Selecting Rows & Columns\nA typical task when working with datasets is selecting rows (“cases”) and columns (“variables”).\nFor this, R in its base version3 provides a selection method using []. The basic structure is [row_selection, column_selection]. Leaving out the part before or after the comma selects all rows/columns. Be careful: forgetting the comma is a common source of errors in R.\n\ndat1 # complete dataset\ndat1[1,1] # first row, first column\ndat1[1,]  # first row, all columns\ndat1[,1]  # all rows, first column (equivalent to dat1$studs)\ndat1[,\"studs\"] # all rows, column named studs -&gt; note: \"\"\n\nIn these square brackets, you can also write conditions to make selections from dat1.\n\ndat1[dat1$studs &gt; 10000, ] # rows where studs is greater than 10000, all columns\ndat1[dat1$studs &gt; 10000 & dat1$profs &lt; 300, ] # & means AND\ndat1$profs[dat1$studs &gt; 10000] # Only see the number of professors: no comma\n\n\n2.3.1 Exercise\nRepetitive use of the dataset name in the [] makes the syntax quite long and somewhat tedious. Therefore, there is a better/more convenient solution. We use the {dplyr} package4.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#packages",
    "href": "02_intro.html#packages",
    "title": "2  Working with Datasets",
    "section": "2.4 Packages in R",
    "text": "2.4 Packages in R\nPackages are extensions for R that include additional functions.  Packages need to be installed once and then loaded before use in a new session (i.e., after every restart of R/RStudio). install.packages() performs the installation, and library() loads the packages:\n\ninstall.packages(\"Package\") # only needed once on your PC\nlibrary(Package) # needed after every restart\n\nOften, when using install.packages(), not only the specified package is downloaded but also a number of other packages, the so-called “dependencies”. These are packages used in the background to enable the functions of the desired package. So don’t be surprised if the installation takes a bit longer.\nWith install.packages() we essentially screw in the light bulb in R, with library() we flip the switch so we can use the functions from the package. Each restart turns the light bulb off again, and we need to turn it back on with library(). The advantage is that we don’t have to turn on all the light bulbs at once when starting R.\n\n\n\n\n\nSource: Dianne Cook\n\n\n\n\n\n\n\n\n\n\ninstall.packages() in the IAB Network\n\n\n\nPackages in R are typically installed from CRAN. This is not possible on the servers at IAB due to isolation from the internet. This restricts package installation in R to the collection maintained by DIM under N:/Ablagen/D01700-Allgemein/R/bin/windows/contrib/.\nA central challenge in installing from local zip files is handling dependencies: packages that the desired package relies on. When installing from the internet, dependencies are automatically installed, but with a local installation, this is not the case.\nAt IAB, some workarounds exist, and currently, I have a solution in progress at FDZ based on a .Rprofile file that provides the fdz_install() command, which behaves like the standard install.packages() command (or should, at least).\nThe most recent version of the .Rprofile file can be found under N:\\Ablagen\\D01700-Quickablage\\Filser\\R_2024\\prog.\nPlace the .Rprofile file in C:\\Users\\*YOUR_USERNAME*\\Documents and restart R (CTRL + F10), you should then see a similar message in the console:\n\n----------------------------------------\nIAB-FDZ .Rprofile\nVersion 0.5\n----------------------------------------\n- Local repository: N:/Ablagen/D01700-Allgemein/R/bin/windows/contrib/4.2\n- Working directory: N:/Ablagen/D01700-FDZ/Quickablage/AndreasF/R-Kurs\n \n- Default package library: C:/Users/FilserA001.IAB/AppData/Local/R/win-library/4.2\n- HOME directory: C:/Users/FilserA001.IAB/Documents\n- R_home directory: C:/PROGRA~1/R/R-4.2.1\n----------------------------------------\n\nMore about RProfile\n\n\n\n\n\n\n\n\nLoading packages once\n\n\n\n\n\nIn addition to library(), you can also call functions from packages using :::\n\npackage::function()\n\nThis option is often used when only one function from a package is used or to clarify which package the function comes from. It can also help with issues if a command from another package has the same name—this will override the previous command (usually with a warning), which might look like:\n\nThe following objects are masked from ‘package:dplyr’:\n\n    between, first, last\n\nThe following object is masked from ‘package:purrr’:\n\n    transpose\n\nThis can be avoided by not fully loading certain packages but only calling the necessary functions with ::.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#tidyverse",
    "href": "02_intro.html#tidyverse",
    "title": "2  Working with Datasets",
    "section": "2.5 {tidyverse}",
    "text": "2.5 {tidyverse}\nIn this course, we will mainly work with packages from the {tidyverse}. The tidyverse is a collection of packages that share common syntax logic and thus harmonize particularly well and cover a broad range of use cases. With\n\ninstall.packages(\"tidyverse\")\nfdz_install(\"tidyverse\") # on IAB servers with .Rprofile\n\nthe following packages are installed:\nbroom, conflicted, cli, dbplyr, dplyr, dtplyr, forcats, ggplot2, googledrive, googlesheets4, haven, hms, httr, jsonlite, lubridate, magrittr, modelr, pillar, purrr, ragg, readr, readxl, reprex, rlang, rstudioapi, rvest, stringr, tibble, tidyr, xml2, tidyverse\nWe will get to know some of them during the course. The initially most important one is {dplyr}, which makes selecting cases and variables easier:\n\n\n\n\n\nIllustration based on the {dplyr} Cheatsheet\n\n\n\n\nBut installation is only the first step; we need to load the package with library():\n\nlibrary(tidyverse) # after once using install.packages(\"tidyverse\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#selecting-rows-with-slice",
    "href": "02_intro.html#selecting-rows-with-slice",
    "title": "2  Working with Datasets",
    "section": "2.6 Selecting Rows with slice()",
    "text": "2.6 Selecting Rows with slice()\nA first function from {tidyverse} is slice(), which allows us to select rows:\n\nslice(dat1,1) # first row\nslice(dat1,2:3) # rows 2-3\nslice(dat1,c(1,3)) # rows 1 and 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#filter",
    "href": "02_intro.html#filter",
    "title": "2  Working with Datasets",
    "section": "2.7 Selecting Observations with filter()",
    "text": "2.7 Selecting Observations with filter()\nWith filter(), we can select rows from dat1 based on conditions:\n\nfilter(dat1,uni == \"Uni Oldenburg\", studs &gt; 1000)\n\n  studs profs gegr stu_prof           uni\n1 15643   210 1973 74.49048 Uni Oldenburg\n\n\nThe selection does not change the original object dat1:\n\ndat1\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg\n\n\nIf we want to keep the result of our selection with filter() for further steps, we can store it in a new data.frame object:\n\nover_10k &lt;- filter(dat1, studs &gt; 10000)\nover_10k\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n\n\n\n2.7.1 filter() helpers\n{dplyr} provides a number of helpers for filter():\n\ngreater/smaller than or equal to: &lt;= &gt;=\nor: |\none of: %in%\nwithin a given range: between()\n\n\nfilter(dat1, studs &gt;= 10000)\nfilter(dat1, studs &lt;= 10000)\nfilter(dat1,studs &gt; 10000 | profs &lt; 200) # more than 10.000 Students *or* less than 200 professors\nfilter(dat1, gegr %in% c(1971,1830)) # founded 1971 or 1830\nfilter(dat1, between(gegr,1971,1830)) # founded between 1971 and 1830 (including)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#select",
    "href": "02_intro.html#select",
    "title": "2  Working with Datasets",
    "section": "2.8 Selecting variables with select()",
    "text": "2.8 Selecting variables with select()\nselect() allows us to select specific columns:\n\nselect(dat1,uni,studs) # columns uni and studs\n\n            uni studs\n1    Uni Bremen 19173\n2    Uni Vechta  5333\n3 Uni Oldenburg 15643\n\n\n\nselect(dat1, 1:3) # column 1-3\n\n  studs profs gegr\n1 19173   322 1971\n2  5333    67 1830\n3 15643   210 1973\n\nselect(dat1, !profs) # all but profs\n\n  studs gegr stu_prof           uni\n1 19173 1971 59.54348    Uni Bremen\n2  5333 1830 79.59701    Uni Vechta\n3 15643 1973 74.49048 Uni Oldenburg\n\n\nWe can also select columns by name or position and reorder them:\n\nselect(dat1,uni,studs,profs) # columns in a specific order\n\n            uni studs profs\n1    Uni Bremen 19173   322\n2    Uni Vechta  5333    67\n3 Uni Oldenburg 15643   210\n\nselect(dat1,-studs) # all columns except for \"studs\"\n\n  profs gegr stu_prof           uni\n1   322 1971 59.54348    Uni Bremen\n2    67 1830 79.59701    Uni Vechta\n3   210 1973 74.49048 Uni Oldenburg\n\n\nThe output of select() can be further modified by other functions:\n\ndat1 %&gt;% \n  select(uni,studs) %&gt;% \n  filter(studs &gt; 10000)\n\n            uni studs\n1    Uni Bremen 19173\n2 Uni Oldenburg 15643\n\n\n\n2.8.1 Chaining Commands with %&gt;%\nIn R, dplyr and other {tidyverse} packages use %&gt;% (the pipe operator) to chain commands. This is a way to streamline commands and improve readability:\n\ndat1 %&gt;%\n  filter(studs &gt; 10000) %&gt;%\n  select(uni,studs)\n\n            uni studs\n1    Uni Bremen 19173\n2 Uni Oldenburg 15643\n\n\nHere, %&gt;% takes the output of one function and passes it as an input to the next function. This operator allows you to read and write code that closely resembles natural language.\n\n\n\n\n\n\nEND\n\n\n\nWenn wir jetzt aber einige Zeilen und einige Spalten auswählen möchten, dann können wir filter() und select() kombinieren:\n\nselect(filter(dat1,studs &lt; 10000),uni)\n\n         uni\n1 Uni Vechta\n\n\nDiese Befehlsschachtel können wir mit der sog. Pipe %&gt;% auflösen. %&gt;% steht einfach für “und dann”. Die Pipe kommt aus dem Paket {magrittr}, welches wiederum Teil des tidyverse ist und automatisch mit {dplyr} geladen wird.\n\nfilter(dat1,studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\nHäufig wird die Pipe dann so verwendet, dass zu Beginn lediglich der zu bearbeitende Datensatz steht und sich dann die Schritte anschließen:\n\ndat1 %&gt;% filter(.,studs &lt; 10000) %&gt;% select(.,uni)\n\n         uni\n1 Uni Vechta\n\n\nDer Punkt . steht jeweils für das Ergebnis des vorherigen Schritts. Hier also:\n\nRufe dat1 auf und dann (%&gt;%)\nWähle nur Zeilen aus in denen studs &lt; 10000 und dann (%&gt;%)\nBehalte nur die Spalte uni\n\n\ndat1 %&gt;% filter(studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\n\n\n\n\n\n\nThe shortcut for %&gt;% is STRG+SHIFT+m (cmd+shift+m on Mac)\n\n\n\nIf we want to select both some rows and some columns, we can combine filter() and select():\n\nselect(filter(dat1, studs &lt; 10000), uni)\n\n         uni\n1 Uni Vechta\n\n\nWe can simplify this nested command with the so-called pipe %&gt;%. %&gt;% just means “and then”. The pipe comes from the {magrittr} package, which is part of the tidyverse and is automatically loaded with {dplyr}.\n\nfilter(dat1, studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\nOften, the pipe is used in a way that the dataset to be processed is specified at the beginning, followed by the steps to be performed:\n\ndat1 %&gt;% filter(., studs &lt; 10000) %&gt;% select(., uni)\n\n         uni\n1 Uni Vechta\n\n\nThe dot . represents the result of the previous step. Here:\n\nCall dat1 and then (%&gt;%)\nSelect only rows where studs &lt; 10000 and then (%&gt;%)\nKeep only the column uni\n\n\ndat1 %&gt;% filter(studs &lt; 10000) %&gt;% select(uni)\n\n         uni\n1 Uni Vechta\n\n\n\n\n\n\n\n\nThe shortcut for %&gt;% is CTRL+SHIFT+m (cmd+shift+m on Mac)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#variable-type-factor---defining-custom-orders",
    "href": "02_intro.html#variable-type-factor---defining-custom-orders",
    "title": "2  Working with Datasets",
    "section": "2.9 Variable type factor - defining custom orders",
    "text": "2.9 Variable type factor - defining custom orders\nAnother common task in data analysis is sorting datasets. For this, we use arrange():\n\ndat1 %&gt;% arrange(studs)\n\n  studs profs gegr stu_prof           uni\n1  5333    67 1830 79.59701    Uni Vechta\n2 15643   210 1973 74.49048 Uni Oldenburg\n3 19173   322 1971 59.54348    Uni Bremen\n\n\nThis also works for string variables:\n\ndat1 %&gt;% arrange(uni)\n\n  studs profs gegr stu_prof           uni\n1 19173   322 1971 59.54348    Uni Bremen\n2 15643   210 1973 74.49048 Uni Oldenburg\n3  5333    67 1830 79.59701    Uni Vechta\n\n\nBut what if we want to assign a specific order that doesn’t follow numeric or alphabetical order? For example, if we want to order the universities as follows: 1) Uni Oldenburg, 2) Uni Bremen, and 3) Uni Vechta.\nThis is where a third variable type comes in: factor.\nWith the levels = argument, we can define an order:\n\nfactor(dat1$uni, levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\n[1] Uni Bremen    Uni Vechta    Uni Oldenburg\nLevels: Uni Oldenburg Uni Bremen Uni Vechta\n\ndat1$uni_fct &lt;- factor(dat1$uni, \n                       levels = c(\"Uni Oldenburg\", \"Uni Bremen\", \"Uni Vechta\"))\n\nIf we now sort by uni_fct, the order of the levels is respected:\n\nclass(dat1$uni_fct)\n\n[1] \"factor\"\n\ndat1 %&gt;% arrange(uni_fct)\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n\n\nWith desc(), we can sort in reverse order:\n\ndat1 %&gt;% arrange(desc(uni_fct))\n\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\nThis may seem trivial at the moment but is very useful later for ordering variables in plots or setting the reference category in regression models.\nOf course, we can also sort by multiple variables; we just add more to arrange():\n\ndat1 %&gt;% arrange(desc(uni_fct), gegr, studs)\n\n  studs profs gegr stu_prof           uni       uni_fct\n1  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n2 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\n(This doesn’t make much sense in this example.)\n\n2.9.1 Exercise",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#rproj",
    "href": "02_intro.html#rproj",
    "title": "2  Working with Datasets",
    "section": "2.10 Setting up a project",
    "text": "2.10 Setting up a project\nIn general, it’s worth setting up projects in RStudio. Projects are .Rproj files  that automatically set the working directory to where they are saved. This simplifies collaborative work: no matter who is working on a project or on which device, the project file ensures all paths are always relative to the project directory. Furthermore, version control via git, e.g., github, and other functions can be set in the project file for all users. Also, the last open scripts remain open, making it easier to work on multiple projects.\n\n\n\n\n\n\n\n\n\nWith getwd(), we can check if it worked:\n\ngetwd()\n\n\n\n[1] \"D:/Courses/R-Course\"\n\n\n\n\n\n\n\n\n\n\n\nAlternatively, we could create an .Rproj project with the following command (here’s an example of calling a package with ::):\n\nrstudioapi::initializeProject(path = \"D:/Courses/R-Course\")\n\nWe can open the project with:\n\nrstudioapi::openProject(path = \"D:/Courses/R-Course\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#import",
    "href": "02_intro.html#import",
    "title": "2  Working with Datasets",
    "section": "2.11 Importing datasets",
    "text": "2.11 Importing datasets\nIn most cases, we’ll use datasets that are already saved in a file and just need to be imported. There are countless ways to do this.\nIn this seminar, we’ll work with the Campus-File of PASS, whose parts are available as Stata files.\nTo import the dataset into R, we need to tell R the file path where the dataset is located. The file path depends on your device’s folder structure; in this case, it would be “D:/Courses/R-Course/”.\nOf course, the file path depends on where you saved the dataset:\n\n\n\n\n\n\n\n\n\nWe need to inform R of this file path.\n\n2.11.1 The import command\nNow we can use the actual import command read.table. For the path, we can just enter the quotation marks after file = and press the Tab key. Then we’ll see all subdirectories and tables in the project folder.5\n\nlibrary(haven)\npend &lt;- read_dta(\"./orig/PENDDAT_cf_W13.dta\") \n\nThe import process consists of two parts: first, we specify the object name as pend, under which R will store the dataset. After the &lt;- is the actual read_dta() command, which contains several options. First, we specify the exact dataset name, including the file extension.\n\n\n\n\n\n\nR has problems with Windows-style \\ in file paths\n\n\n\n\n\nUnfortunately, Windows systems use \\ in file paths, which causes problems in R. Therefore, file paths must always be specified with / or alternatively with \\\\. RStudio can help a bit with the CTRL + F/Search & Replace function.\n\n\n\nThe object created is a data.frame:\n\nclass(pend)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nTechnically, it’s a tibble—an enhanced version of data.frame in the tidyverse that includes labels and provides additional information in its display, such as variable classes in the first row.\nIf we were to simply type pend here, the entire dataset would be displayed. For an overview, we can use head:\n\nhead(pend)\n\n# A tibble: 6 × 123\n         pnr      hnr welle   pintjahr pintmon pintmod  zpsex   palter PD0400   \n       &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+lbl&gt;\n1 1000001901 10000019 1 [Wel… 2007     5 [Mai]  1 [CAP… 2 [Wei… 36       2 [Ehe…\n2 1000001902 10000019 1 [Wel… 2007     5 [Mai] NA       1 [Mae… 39       2 [Ehe…\n3 1000001901 10000019 3 [Wel… 2009     3 [Mae…  1 [CAP… 2 [Wei… 38      -9 [Ite…\n4 1000002001 10000020 1 [Wel… 2007     4 [Apr…  1 [CAP… 1 [Mae… 66     -10 [Ite…\n5 1000002002 10000020 1 [Wel… 2007     4 [Apr…  1 [CAP… 2 [Wei… 61       3 [Ehe…\n6 1000002002 10000020 2 [Wel… 2008     5 [Mai]  1 [CAP… 2 [Wei… 62       3 [Ehe…\n# ℹ 114 more variables: PA0100 &lt;dbl+lbl&gt;, PA0200 &lt;dbl+lbl&gt;, PA0300 &lt;dbl+lbl&gt;,\n#   PA0445 &lt;dbl+lbl&gt;, PA0800 &lt;dbl+lbl&gt;, PA0900 &lt;dbl+lbl&gt;, PA1000 &lt;dbl+lbl&gt;,\n#   PSM0100 &lt;dbl+lbl&gt;, PEO0100a &lt;dbl+lbl&gt;, PEO0100b &lt;dbl+lbl&gt;,\n#   PEO0100c &lt;dbl+lbl&gt;, PEO0100d &lt;dbl+lbl&gt;, PEO0100e &lt;dbl+lbl&gt;,\n#   PEO0200a &lt;dbl+lbl&gt;, PEO0200b &lt;dbl+lbl&gt;, PEO0200c &lt;dbl+lbl&gt;,\n#   PEO0200d &lt;dbl+lbl&gt;, PEO0300a &lt;dbl+lbl&gt;, PEO0300b &lt;dbl+lbl&gt;,\n#   PEO0300c &lt;dbl+lbl&gt;, PEO0300d &lt;dbl+lbl&gt;, PEO0300e &lt;dbl+lbl&gt;, …\n\n\nWith nrow and ncol, we can check if it worked. The dataset should have 28424 rows and 123 columns:\n\nnrow(pend)\n\n[1] 28424\n\nncol(pend)\n\n[1] 123\n\n\nOf course, we can also select rows and columns from this much larger dataset as we did before. For example, we can select the data from 2006 and store it under pend06:\n\npend06 &lt;- pend %&gt;% filter(pintjahr == 2006)\n\nNaturally, pend06 has significantly fewer rows than pend:\n\nnrow(pend06)\n\n[1] 168\n\n\nIf we want to see the exact ages of the respondents from pend06, we can call up the corresponding column with pend06$palter:\n\npend06$palter\n\n&lt;labelled&lt;double&gt;[168]&gt;: Alter (Welle 1: gen. aus P1; ab Welle 2: beste Inf.), generiert\n  [1] 71 66 64 64 63 51 64 65 26 38 41 63 58 58 69 45 59 37 28 63 56 29 29 49 47\n [26] 66 34 22 21 37 36 58 56 80 44 65 61 66 40 53 34 70 69 54 65 62 58 54 51 57\n [51] 72 52 25 34 55 44 68 73 46 87 74 83 46 40 62 58 66 41 53 71 66 79 54 42 68\n [76] 68 81 92 70 66 68 77 44 66 66 67 62 43 35 35 52 54 20 48 48 20 41 24 22 33\n[101] 55 41 50 36 19 52 25 36 37 29 37 36 43 49 16 59 28 19 43 44 30 43 50 50 53\n[126] 52 71 43 58 58 58 38 49 30 27 50 58 26 36 44 28 19 42 44 23 20 33 24 31 32\n[151] 31 44 50 58 45 57 37 62 46 52 50 47 40 62 40 19 28 35\n\nLabels:\n value                                   label\n   -10 Item in Fragebogenversion nicht erhoben\n    -9             Item in Welle nicht erhoben\n    -8                       Unplausibler Wert\n    -4        Frage irrtuemlich nicht gestellt\n    -3                Trifft nicht zu (Filter)\n    -2                            Keine Angabe\n    -1                             Weiss nicht\n\n\nAs we’ve seen, there are many more variables in PASS than just palter, and not all have such meaningful names—like PD0400. To understand these variable names and the meaning of the values, we need the codebook.\nWe can also access a variable’s attributes()—more on labels later.\n\n\n2.11.2 Exercise",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#exporting-objects",
    "href": "02_intro.html#exporting-objects",
    "title": "2  Working with Datasets",
    "section": "2.12 Exporting objects",
    "text": "2.12 Exporting objects\n\n\n\n\n\n\nThe term save can sometimes lead to misunderstandings in R: does it mean\n\nsaving a dataset or other object to disk as .csv, .dta, .sav for access by other programs, or\nsimply storing the results internally in R under an object name?\n\nI avoid the word save and instead speak of exporting (Case 1: writing to a file) or storing (Case 2: storing results/values within R in an object).\n\n\n\nThe proprietary format in R for exporting data.frames and reloading afterwards is .RData (comparable to dta in Stata):\n\nsaveRDS(pend06, file = \"./data/pend06.RData\")\nrm(pend06) # delete pend06 from memory\n\npend06_neu &lt;- readRDS(file = \"./data/pend06.RData\")\nhead(pend06) # does not exist anymore -&gt; rm()\n\nError in eval(expr, envir, enclos): Objekt 'pend06' nicht gefunden\n\nhead(pend06_neu,n=1)\n\n# A tibble: 1 × 123\n         pnr      hnr welle   pintjahr pintmon  pintmod zpsex   palter PD0400   \n       &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+lbl&gt;\n1 1000402601 10004026 1 [Wel… 2006     12 [Dez… 0 [CAT… 1 [Mae… 71     -10 [Ite…\n# ℹ 114 more variables: PA0100 &lt;dbl+lbl&gt;, PA0200 &lt;dbl+lbl&gt;, PA0300 &lt;dbl+lbl&gt;,\n#   PA0445 &lt;dbl+lbl&gt;, PA0800 &lt;dbl+lbl&gt;, PA0900 &lt;dbl+lbl&gt;, PA1000 &lt;dbl+lbl&gt;,\n#   PSM0100 &lt;dbl+lbl&gt;, PEO0100a &lt;dbl+lbl&gt;, PEO0100b &lt;dbl+lbl&gt;,\n#   PEO0100c &lt;dbl+lbl&gt;, PEO0100d &lt;dbl+lbl&gt;, PEO0100e &lt;dbl+lbl&gt;,\n#   PEO0200a &lt;dbl+lbl&gt;, PEO0200b &lt;dbl+lbl&gt;, PEO0200c &lt;dbl+lbl&gt;,\n#   PEO0200d &lt;dbl+lbl&gt;, PEO0300a &lt;dbl+lbl&gt;, PEO0300b &lt;dbl+lbl&gt;,\n#   PEO0300c &lt;dbl+lbl&gt;, PEO0300d &lt;dbl+lbl&gt;, PEO0300e &lt;dbl+lbl&gt;, …\n\n\nWe can also export and restore other objects. However, we need to load() them, which will result in restoring the previous object name:\n\nsave(studs, file = \"./data/stud_vektor.RData\")\nrm(studs)\nstuds\nload(file = \"./data/stud_vektor.RData\") # studs is back with the same object name\nstuds\n\nThis also works for multiple Objects:\n\nsave(studs,profs, file = \"./data/meine_vektoren.RData\")\nrm(studs,profs)\nstuds\nprofs\nload(file = \"./data/meine_vektoren.RData\") # studs & profs restored with the same name\nstuds\nprofs\n\n\n2.12.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#overview-importing-and-exporting-data-sets",
    "href": "02_intro.html#overview-importing-and-exporting-data-sets",
    "title": "2  Working with Datasets",
    "section": "2.13 Overview: Importing and exporting data sets",
    "text": "2.13 Overview: Importing and exporting data sets\nImporting data sets\n\nExplanantionsCode\n\n\n\n\n\n\n\n\n\n\n\n\n\nfile type\nR function\nR package\nComment\n\n\n\n\n.csv\nread.table()\n-\nset delimiter with `sep = \";\"`\n\n\n.Rdata (R format)\nreadRDS\n-\n\n\n\ngroße .csv\nvroom()\n{vroom}\nset delimiter using `delim = \";\"`\n\n\n.dta (Stata)\nread_dta()\n{haven}\n\n\n\n.dta (Stata - große Dateien)\nread.dta13()\n{readstata13}\nuse convert.factors = F to import only numeric values\nalso imports files from newer Stata versions\n\n\n.dat (SPSS)\nread_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nread_xlsx()\n{readxl}\nuse `sheet = 1`to specifiy which sheet you want\n\n\n\n\n\n\n\n\n\n\n# csv file\ndat1 &lt;- read.table(file = \"Dateiname.csv\",sep = \";\")\n\n# Rdata\ndat1 &lt;- readRDS(file = \"Dateiname.Rdata\")\n\n# large csv\nlibrary(vroom)\ndat1 &lt;- vroom(file = \"Dateiname.csv\",delim = \";\")\n\n# Stata dta\nlibrary(haven)\ndat1 &lt;- read_dta(file = \"Dateiname.dta\")\n\n# Stata large files\n# faster than read_dta(), but without labels\nlibrary(readstata13)\ndat1 &lt;- read.dta13(file = \"Dateiname.dta\",convert.factors = F) \n\n# SPSS sav\ndat1 &lt;- read_sav(file = \"Dateiname.sav\")\n\n# Excel\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"1\")\ndat1 &lt;- read_xlsx(path = \"Dateiname.xlsx\", sheet = \"Tabellenblatt1\")\n\n\n\n\nExporting data sets\n\nExplanantionsCode\n\n\n\n\n\n\n\nfile type\nR function\nR package\nComment\n\n\n\n\n.Rdata (R format)\nsaveRDS()\n-\nall variable properties remain\n\n\n.csv\nwrite.table()\n-\nuse `sep = \";\"` to set delimiter br&gt;use row.names= F to suppress row numbering\n\n\n.dta (Stata)\nwrite_dta()\n{haven}\n\n\n\n.dat (SPSS)\nwrite_spss()\n{haven}\n\n\n\n.xlsx (Excel)\nwrite.xlsx()\n{xlsx}\nmit `sheetName` ggf. Tabellenblattname angeben\n\n\n\n\n\n\n\n\n\n\n# Rdata\nsaveRDS(dat1,file = \"Dateiname.Rdata\")\n# csv\nwrite.table(dat1,file = \"Dateiname.csv\",sep = \";\",row.names = F)\n# dta\nlibrary(haven)\nwrite_dta(dat1,path = \"Dateiname.dta\")\n# sav\nlibrary(haven)\nwrite_sav(dat1,path = \"Dateiname.sav\")\n# xlsx\nlibrary(xlsx)\nwrite.xlsx(dat1,file = \"Dateiname.xlsx\", sheetName = \"Tabellenblatt 1\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#hilfe-zu-paketen-und-funktionen",
    "href": "02_intro.html#hilfe-zu-paketen-und-funktionen",
    "title": "2  Working with Datasets",
    "section": "2.14 Hilfe zu Paketen und Funktionen",
    "text": "2.14 Hilfe zu Paketen und Funktionen\nR packages (often) come with very detailed help pages, which can either be called up directly from RStudio:\n\n# help for packages\nvignette(\"dplyr\")\nvignette(package = \"dplyr\")\nvignette(\"rowwise\")\nhelp(\"dplyr\")\nhelp(package = \"dplyr\")\n\n\n# help for a specific function\n?select()\n\nAlternatively, googling the package and function mostly gives you what you need R dplyr select()\nOr refer to the CRAN site:\n\n\n\n\n\nCRAN-Seite für {dplyr}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#exercises",
    "href": "02_intro.html#exercises",
    "title": "2  Working with Datasets",
    "section": "2.15 Exercises",
    "text": "2.15 Exercises\n\n2.15.1 Exercise 1\n\nCreate a data.frame object called dat2:\n\n\ndat2 &lt;- data.frame(studs = c(14954,47269 ,23659,9415 ,38079), \n                   profs = c(250,553,438 ,150,636),\n                   prom_recht = c(FALSE,TRUE,TRUE,TRUE,FALSE),\n                   gegr  = c(1971,1870,1457,1818,1995))\n\n\nDo you see dat2 in your environment?\nPrint dat2 in the console.\nAdd the names of the universities as a new column to the dataset. The names are in this order:\n\n\nc(\"FH Aachen\",\"RWTH Aachen\",\"Uni Freiburg\",\"Uni Bonn\",\"FH Bonn-Rhein-Sieg\")\n\n[1] \"FH Aachen\"          \"RWTH Aachen\"        \"Uni Freiburg\"      \n[4] \"Uni Bonn\"           \"FH Bonn-Rhein-Sieg\"\n\n\n\nDisplay dat2 - either in the console or using View().\nCalculate the ratio of students per professor and store the results in a new variable. Check the result.\nDisplay only the third row of dat2.\nDisplay only the third column of dat2.\n\nWhat would you do to copy dat2 into an object called df_unis?\nBack to top\n\n\n\n2.15.2 Exercise 2\n\nCreate a .Rprofile for the package installation in C:\\Users\\*USERNAME*\\Documents.\nInstall the tidyverse packages using fdz_install(\"tidyverse\") after placing the .Rprofile file under C:\\Users\\*USERNAME*\\Documents.\nUse the data.frame dat2 from Exercise 1.\nUse filter to display only the universities with fewer than 10,000 students. (Remember to install and load {tidyverse} with library()).\nDisplay only the gegr column.\nDisplay only the rows of universities with the right to award doctorates (prom_recht).\n\nBack to top\n\n\n\n2.15.3 Exercise 3\n\nContinue using the dataset from Exercises 1 & 2.\nDisplay only the universities that were founded in 1971, 1457, or 1995, and for these cases, show only the name and founding year.\nSort the dataset according to the following order. (Create a factor variable that defines this order.)\n\n\nc(\"RWTH Aachen\", \"Uni Freiburg\", \"Uni Bonn\", \"FH Aachen\", \"FH Bonn-Rhein-Sieg\")\n\n[1] \"RWTH Aachen\"        \"Uni Freiburg\"       \"Uni Bonn\"          \n[4] \"FH Aachen\"          \"FH Bonn-Rhein-Sieg\"\n\n\nBack to top\n\n\n\n2.15.4 Exercise 4\n\nCreate an R project in your directory for this course.\nSave the personal data from the PASS-CampusFile (PENDDAT_cf_W13.dta) in your directory in the subfolder orig.\nRead the dataset PENDDAT_cf_W13.dta as shown above into R and assign it to the object name pend.\nUse head() and View() to get an overview of the dataset.\nHow many respondents (rows) does the dataset contain?\nDisplay the variable names of pend using names()!\nHow can you display the rows that contain the respondent with the pnr 1000908201?\nSelect all respondents older than 60 (Age: palter) and save this selection as ue_1960.\nHow do you need to adjust the command so that ue_1960 contains only the variables pnr, hnr, welle, pintjahr, and palter?\nHow many columns does ue_1960 have? How many rows?\n\nBonus Exercises:\n\n\nHow old is the respondent with the pnr 1000908201 in welle 10 (in pintjahr 2016)?\nCreate a new variable with the birth year of the respondents (based on the age palter and the interview year pintjahr).\n\n\nBack to top\n\n\n\n2.15.5 Exercise 5\n\nExport the data.frame with the smaller dataset version (ue_1960) created in the previous exercise as an .Rdata file.\nLoad the exported .Rdata file under a different name, e.g., ue_1960_neu.\nDid everything work? Compare the newly loaded object with the original one: identical(ue_1960, ue_1960_neu) - are both objects identical?\n\nBack to top",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#appendix",
    "href": "02_intro.html#appendix",
    "title": "2  Working with Datasets",
    "section": "2.16 Appendix",
    "text": "2.16 Appendix\n\n2.16.1 Alternatives to R Projects\nBesides setting up a project, you can also set the path using setwd() or directly specify it within read_dta() or other read...() commands. However, this approach is less portable to other machines. When someone else opens the .Rproj file, R automatically sets paths relative to the file’s location. This is also true if the directory is moved on your device—R will automatically adjust the working directory.\nTo set the working directory with setwd(), insert the folder path within the parentheses. Make sure to replace any \\ with /:\n\nsetwd(\"D:/Kurse/R_IAB\")\n\nYou can check if it worked with getwd():\n\ngetwd()\n\nThe path you set with setwd() should appear.\nAlternatively, you can provide the full path directly in read_dta():\n\npend &lt;- haven::read_dta(\"C:/Kurse/R_IAB/orig/PENDDAT_cf_W13.dta\")\n\n\n\n2.16.2 Selecting Rows & Columns Without {dplyr}\nBase R (without extensions like {dplyr}) can also filter datasets using square brackets []:\n\ndat1[1, 1] # first row, first column\n\n[1] 19173\n\ndat1[1, ]  # first row, all columns\n\n  studs profs gegr stu_prof        uni    uni_fct\n1 19173   322 1971 59.54348 Uni Bremen Uni Bremen\n\ndat1[, 1]  # all rows, first column (equivalent to dat1$studs)\n\n[1] 19173  5333 15643\n\ndat1[, \"studs\"] # all rows, column named studs -&gt; note the \"\"\n\n[1] 19173  5333 15643\n\n\nYou can also select multiple rows or columns by using c():\n\ndat1[c(1, 2), ]  ## 1st & 2nd row, all columns\ndat1[, c(1, 3)]  ## all rows, 1st & 3rd column (equivalent to dat1$studs & dat1$stu_prof)\ndat1[, c(\"studs\", \"uni\")] ## all rows, columns named studs and uni\n\nYou can also write conditions in these square brackets to make selections from dat1.\n\ndat1 # full dataset\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n2  5333    67 1830 79.59701    Uni Vechta    Uni Vechta\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\ndat1[dat1$uni == \"Uni Oldenburg\", ] # Rows where uni equals \"Uni Oldenburg\", all columns\n\n  studs profs gegr stu_prof           uni       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\ndat1$studs[dat1$uni == \"Uni Oldenburg\"] # Just check the student count: no comma needed\n\n[1] 15643\n\n\nThis works as expected, and we can expand it:\n\ndat1[dat1$uni == \"Uni Oldenburg\" & dat1$studs &gt; 10000, ] # & means AND\n\n  studs profs gegr stu_prof           uni       uni_fct\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\nYou can also use the OR operator:\n\ndat1[dat1$uni == \"Uni Oldenburg\" | dat1$studs &gt; 10000, ]\n\n  studs profs gegr stu_prof           uni       uni_fct\n1 19173   322 1971 59.54348    Uni Bremen    Uni Bremen\n3 15643   210 1973 74.49048 Uni Oldenburg Uni Oldenburg\n\n\n\n\n2.16.3 select() vs $\nWhen you use select() to pick a specific variable, it preserves the data structure as a data.frame(), whereas dat1$variablename extracts the column as a vector (a series of values):\n\ndat1$studs\n\n[1] 19173  5333 15643\n\nclass(dat1$studs)\n\n[1] \"numeric\"\n\ndat1$studs / 20\n\n[1] 958.65 266.65 782.15\n\n\nselect() keeps the values as a column in a data.frame:\n\ndat1 %&gt;% select(studs)\n\n  studs\n1 19173\n2  5333\n3 15643\n\ndat1 %&gt;% select(studs) %&gt;% class()\n\n[1] \"data.frame\"\n\ndat1 %&gt;% select(studs) / 20\n\n   studs\n1 958.65\n2 266.65\n3 782.15",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "02_intro.html#footnotes",
    "href": "02_intro.html#footnotes",
    "title": "2  Working with Datasets",
    "section": "",
    "text": "In many other programming languages, these are called libraries.↩︎\nThere are more, and this enumeration ignores technical details—for an advanced introduction to vectors in R, click here.↩︎\nWe will see soon how packages can make working in R easier.↩︎\nIt has become common in the R community to write packages with {} to distinguish them more clearly from functions. I follow this convention in this script.↩︎\nSometimes the dataset is not in the project’s subfolder, in which case the entire path can be specified in read_dta(): pend &lt;- read_dta(file = \"D:/Courses/R-Course/data/PENDDAT_cf_W13.dta\")↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Datasets</span>"
    ]
  },
  {
    "objectID": "03_desc.html",
    "href": "03_desc.html",
    "title": "3  Getting an Overview",
    "section": "",
    "text": "3.1 Frequency Counts\nWe have various commands available to create a frequency count:\nThe simplest command for counting frequencies is the table() command. For example, with the variable statakt representing the education status of respondents:\ntable(pend$statakt)\n\n\n -10   -9   -5    1    2    3 \n3765 3289  280 9470 6139 5481\nHere, we see the absolute frequencies displayed. The first row lists the different values, and the second row shows the frequencies.\nHowever, the labels are ignored in the output of table(). A look into the PASS data report or using attributes() reveals the value labels:\nattributes(pend$statakt)\n\n$label\n[1] \"Aktueller Hauptstatus, generiert (ab Welle 2)\"\n\n$format.stata\n[1] \"%46.0g\"\n\n$class\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n\n$labels\nItem fuer Fragebogenversion nicht relevant \n                                       -10 \n               Item in Welle nicht erhoben \n                                        -9 \n   Generierung nicht mgl. (fehlende Werte) \n                                        -5 \n                             Erwerbstaetig \n                                         1 \n        Arbeitslos (Gemeldet und sonstige) \n                                         2 \n                                   Inaktiv \n                                         3\nt1 &lt;- table(pend$statakt)\n9470 respondents are employed, 5481 respondents are inactive, etc. (More on labels and working with value labels in R later.)\nWith count() from {dplyr}, we get the labels displayed directly. Again, we use the pipe %&gt;%:\npend %&gt;% count(statakt)\n\n# A tibble: 6 × 2\n  statakt                                              n\n  &lt;dbl+lbl&gt;                                        &lt;int&gt;\n1 -10 [Item fuer Fragebogenversion nicht relevant]  3765\n2  -9 [Item in Welle nicht erhoben]                 3289\n3  -5 [Generierung nicht mgl. (fehlende Werte)]      280\n4   1 [Erwerbstaetig]                               9470\n5   2 [Arbeitslos (Gemeldet und sonstige)]          6139\n6   3 [Inaktiv]                                     5481\nWe can also store tables under a freely chosen name and call them up later:\nt1 &lt;- table(pend$statakt)\nt2 &lt;- pend %&gt;% count(statakt)\nWe see here that the table with table() creates a new object form, a table. With count(), however, a data.frame is created.\nclass(t1)\n\n[1] \"table\"\n\nclass(t2)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#frequency-counts",
    "href": "03_desc.html#frequency-counts",
    "title": "3  Getting an Overview",
    "section": "",
    "text": "table()\ncount() from {dplyr}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#NA03",
    "href": "03_desc.html#NA03",
    "title": "3  Getting an Overview",
    "section": "3.2 Missing Values in R: NA",
    "text": "3.2 Missing Values in R: NA\nNegative values are a bit annoying.\nTo mark the values like -5 as missing data in R, we need to set them to NA in pend. To do this, we call pend$statakt and filter with [] only the values for statakt equal to -1. In the previous chapter, we learned how to call specific values this way:\n\npend$statakt[pend$statakt == -5] # only call statakt = -5\n\n&lt;labelled&lt;double&gt;[280]&gt;: Aktueller Hauptstatus, generiert (ab Welle 2)\n  [1] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n [26] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n [51] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n [76] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[101] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[126] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[151] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[176] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[201] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[226] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[251] -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5 -5\n[276] -5 -5 -5 -5 -5\n\nLabels:\n value                                      label\n   -10 Item fuer Fragebogenversion nicht relevant\n    -9                Item in Welle nicht erhoben\n    -5    Generierung nicht mgl. (fehlende Werte)\n     1                              Erwerbstaetig\n     2         Arbeitslos (Gemeldet und sonstige)\n     3                                    Inaktiv\n\n\n(Here, we get the labels again, which is somewhat suboptimal for clarity.)\nIf we then assign a new value with &lt;-, the called values will be overwritten - here, we overwrite all values for statakt == -1 with NA:\n\npend$statakt[pend$statakt == -5]  &lt;- NA\n\nNA is the code for missing data in R, and they will not be listed in table():\n\ntable(pend$statakt)\n\n\n -10   -9    1    2    3 \n3765 3289 9470 6139 5481 \n\n\nBut we can explicitly request the count of NA with the option exclude = NULL:\n\ntable(pend$statakt,exclude = NULL)\n\n\n -10   -9    1    2    3 &lt;NA&gt; \n3765 3289 9470 6139 5481  280 \n\n\nHowever, we have not yet overwritten all the negative values; -10 and -9 are still missing. Of course, it would be possible this way, but it’s a bit cumbersome:\n\npend$statakt[pend$statakt == -9 ]  &lt;- NA\npend$statakt[pend$statakt == -10]  &lt;- NA\n\nFor the PASS data, it’s shorter to use &lt; 0, because all missing codes are less than 0:1\n\npend$statakt[pend$statakt &lt; 0 ]  &lt;- NA\n\nNow we are done with statakt:\n\ntable(pend$statakt)\n\n\n   1    2    3 \n9470 6139 5481 \n\ntable(pend$statakt,exclude = NULL)\n\n\n   1    2    3 &lt;NA&gt; \n9470 6139 5481 7334 \n\n\nIn count(), NA is also counted:\n\npend %&gt;% count(statakt)\n\n# A tibble: 4 × 2\n  statakt                                     n\n  &lt;dbl+lbl&gt;                               &lt;int&gt;\n1  1 [Erwerbstaetig]                       9470\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139\n3  3 [Inaktiv]                             5481\n4 NA                                       7334\n\n\nIf we want to avoid this, we use filter() again - with is.na(), we can identify NA. By prefixing with !, we can request that all non-NA values be retained with TRUE:\n\npend %&gt;% filter(!is.na(statakt)) %&gt;% count(statakt)\n\n# A tibble: 3 × 2\n  statakt                                    n\n  &lt;dbl+lbl&gt;                              &lt;int&gt;\n1 1 [Erwerbstaetig]                       9470\n2 2 [Arbeitslos (Gemeldet und sonstige)]  6139\n3 3 [Inaktiv]                             5481\n\n\nMore about missing values can be found, for example, in The missing book by Nicholas Tierney & Allison Horst.\n\n3.2.1 Exercise",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#other-table-values",
    "href": "03_desc.html#other-table-values",
    "title": "3  Getting an Overview",
    "section": "3.3 Other Table Values",
    "text": "3.3 Other Table Values\nWith the help of additional functions, we can customize the frequency tables:\n\nprop.table(): relative values/percentages\n\n\ntable(pend$statakt) %&gt;% prop.table(.) \n\n\n        1         2         3 \n0.4490280 0.2910858 0.2598862 \n\n\n29.109% of respondents are unemployed.\n\ncumsum(): cumulative values\n\n\ntable(pend$statakt) %&gt;% cumsum(.)\n\n    1     2     3 \n 9470 15609 21090 \n\n\n15609 respondents are employed or unemployed.\n\nprop.table() with cumsum(): cumulative relative frequencies\n\n\ntable(pend$statakt) %&gt;% prop.table() %&gt;% cumsum()\n\n        1         2         3 \n0.4490280 0.7401138 1.0000000 \n\n\n74.011% of respondents are employed or unemployed (and not inactive).\n\n\n\n\n\n\nMultiple Metrics in One Table\n\n\n\n\n\nMany are probably familiar with the following view from Stata with tab statakt:\n\n\n   Aktueller Hauptstatus, generiert (ab |\n                               Welle 2) |      Freq.     Percent        Cum.\n----------------------------------------+-----------------------------------\n                          Erwerbstaetig |      9,470       33.32       33.32\n     Arbeitslos (Gemeldet und sonstige) |      6,139       21.60       54.91\n                                Inaktiv |      5,481       19.28       74.20\n                                      . |      7,334       25.80      100.00\n----------------------------------------+-----------------------------------\n                                  Total |     28,424      100.00\n\n\nBy default, table() or count() only provide one type of metric. However, since we get the counts as a data.frame() with count(), we can simply add the relative and cumulative frequencies as new variables.\nWe use dat1$var &lt;- ...., which we learned in the previous chapter. To add a new column pct to our data.frame with the counts, we proceed as follows: + First, we create a data.frame with the count using count():\n\ntab_statakt &lt;- pend %&gt;% count(statakt) # base command\ntab_statakt\n\n# A tibble: 4 × 2\n  statakt                                     n\n  &lt;dbl+lbl&gt;                               &lt;int&gt;\n1  1 [Erwerbstaetig]                       9470\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139\n3  3 [Inaktiv]                             5481\n4 NA                                       7334\n\n\n\nThen we add a new column for the relative frequencies, calculated with prop.table():\n\n\ntab_statakt$pct &lt;- prop.table(tab_statakt$n)\n\nIf we now want to create cumulative frequencies, we can apply cumsum() to pct:\n\ntab_statakt$Cum &lt;- cumsum(tab_statakt$pct)\ntab_statakt\n\n# A tibble: 4 × 4\n  statakt                                     n   pct   Cum\n  &lt;dbl+lbl&gt;                               &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  1 [Erwerbstaetig]                       9470 0.333 0.333\n2  2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.216 0.549\n3  3 [Inaktiv]                             5481 0.193 0.742\n4 NA                                       7334 0.258 1    \n\n\nThe NA is still somewhat annoying as it represents missing data and should not be included. We can exclude it simply with !is.na() in filter():\n\ntab_statakt2 &lt;- pend %&gt;% filter(!is.na(statakt)) %&gt;% count(statakt) \ntab_statakt2$pct &lt;- prop.table(tab_statakt2$n)\ntab_statakt2\n\n# A tibble: 3 × 3\n  statakt                                    n   pct\n  &lt;dbl+lbl&gt;                              &lt;int&gt; &lt;dbl&gt;\n1 1 [Erwerbstaetig]                       9470 0.449\n2 2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.291\n3 3 [Inaktiv]                             5481 0.260\n\ntab_statakt2$cum &lt;- cumsum(tab_statakt2$pct)\ntab_statakt2\n\n# A tibble: 3 × 4\n  statakt                                    n   pct   cum\n  &lt;dbl+lbl&gt;                              &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1 [Erwerbstaetig]                       9470 0.449 0.449\n2 2 [Arbeitslos (Gemeldet und sonstige)]  6139 0.291 0.740\n3 3 [Inaktiv]                             5481 0.260 1    \n\n\n\n\n\n\n3.3.1 Creating a Contingency Table\nContingency tables allow us to explore how frequently combinations of different variables occur together. Let’s look at two ways to create contingency tables in R.\nUsing the table() function, we create a contingency table by inserting two variables. For instance, if we want to see the frequencies of employment status (statakt) by gender (zpsex), we can use the following command:\n\ntable(pend$zpsex, pend$statakt)\n\n   \n       1    2    3\n  1 4685 3240 2047\n  2 4785 2899 3434\n\n\nThis table shows the counts of respondents by gender and employment status. For example, if zpsex=2 represents females and statakt=3 represents inactivity, the table displays how many female respondents are inactive.\nTo add row and column totals, use the addmargins() function:\n\ntable(pend$zpsex, pend$statakt) %&gt;% addmargins()\n\n     \n          1     2     3   Sum\n  1    4685  3240  2047  9972\n  2    4785  2899  3434 11118\n  Sum  9470  6139  5481 21090\n\n\nIf you want to compute the relative frequencies instead of absolute counts, use the prop.table() function:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table()\n\n   \n             1          2          3\n  1 0.22214320 0.15362731 0.09706022\n  2 0.22688478 0.13745851 0.16282598\n\n\nFor row-wise percentages (within each gender, how many fall into each employment status), use:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table(margin = 1)\n\n   \n            1         2         3\n  1 0.4698155 0.3249097 0.2052748\n  2 0.4303832 0.2607483 0.3088685\n\n\nFor column-wise percentages (within each employment status, how many are male or female), use:\n\ntable(pend$zpsex, pend$statakt) %&gt;% prop.table(margin = 2)\n\n   \n            1         2         3\n  1 0.4947202 0.5277733 0.3734720\n  2 0.5052798 0.4722267 0.6265280\n\n\n\n\n3.3.2 Working with count() from {dplyr}\nAnother approach to generate frequency tables is using count() from the {dplyr} package. It provides a more readable output with labeled variables:\n\npend %&gt;% count(zpsex, statakt)\n\n# A tibble: 8 × 3\n  zpsex         statakt                                     n\n  &lt;dbl+lbl&gt;     &lt;dbl+lbl&gt;                               &lt;int&gt;\n1 1 [Maennlich]  1 [Erwerbstaetig]                       4685\n2 1 [Maennlich]  2 [Arbeitslos (Gemeldet und sonstige)]  3240\n3 1 [Maennlich]  3 [Inaktiv]                             2047\n4 1 [Maennlich] NA                                       3555\n5 2 [Weiblich]   1 [Erwerbstaetig]                       4785\n6 2 [Weiblich]   2 [Arbeitslos (Gemeldet und sonstige)]  2899\n7 2 [Weiblich]   3 [Inaktiv]                             3434\n8 2 [Weiblich]  NA                                       3779",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#summary-statistics",
    "href": "03_desc.html#summary-statistics",
    "title": "3  Getting an Overview",
    "section": "3.4 Summary Statistics",
    "text": "3.4 Summary Statistics\nFor numerical variables, such as income (netges), we often compute summary statistics like the mean, median, or quantiles. To get a quick overview, use summary():\n\nsummary(pend$netges)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n    -5.0     -3.0     -3.0    567.9    990.0 111419.0 \n\n\n\n3.4.1 Handling Missing Data\nNegative values in the data (like -5 for netges) typically represent missing data. We can convert these to NA:\n\npend$netges[pend$netges &lt; 0] &lt;- NA\n\n\n\n3.4.2 Calculating Specific Statistics\nTo calculate specific statistics, we can use:\n\nMinimum: min()\nMaximum: max()\nMean: mean()\nMedian: median()\nQuantiles: quantile()\nVariance: var()\nStandard Deviation: sd()\n\nFor instance, the mean of income ignoring missing values:\n\nmean(pend$netges, na.rm = TRUE)\n\n[1] 1562.3\n\n\n\n\n3.4.3 Custom Summary with summarise()\nYou can use summarise() from {dplyr} to create custom summary tables:\n\npend %&gt;% summarise(\n  Minimum = min(netges, na.rm = TRUE),\n  Median = median(netges, na.rm = TRUE),\n  Mean = mean(netges, na.rm = TRUE),\n  Maximum = max(netges, na.rm = TRUE)\n)\n\n# A tibble: 1 × 4\n  Minimum   Median  Mean Maximum  \n  &lt;dbl+lbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt;\n1 0           1320 1562. 111419   \n\n\n\n\n3.4.4 Comparing Across Groups\nTo compare statistics across groups, use .by in summarise():\n\npend %&gt;% summarise(\n  Minimum = min(netges, na.rm = TRUE),\n  Median = median(netges, na.rm = TRUE),\n  Mean = mean(netges, na.rm = TRUE),\n  Maximum = max(netges, na.rm = TRUE),\n  .by = welle\n) %&gt;% arrange(welle)\n\n# A tibble: 13 × 5\n   welle                    Minimum   Median  Mean Maximum  \n   &lt;dbl+lbl&gt;                &lt;dbl+lbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt;\n 1  1 [Welle 1 (2006/2007)] 1          1200  1525. 111419   \n 2  2 [Welle 2 (2007/2008)] 0          1320  1529.   7200   \n 3  3 [Welle 3 (2008/2009)] 0          1298. 1498.  12000   \n 4  4 [Welle 4 (2010)]      0          1210  1447.  10800   \n 5  5 [Welle 5 (2011)]      0          1250  1494.  33363   \n 6  6 [Welle 6 (2012)]      0          1215  1459.  15950   \n 7  7 [Welle 7 (2013)]      0          1250  1539.  87835   \n 8  8 [Welle 8 (2014)]      0          1255  1456.   9000   \n 9  9 [Welle 9 (2015)]      0          1280  1613. 110451   \n10 10 [Welle 10 (2016)]     0          1375  1541.   6300   \n11 11 [Welle 11 (2017)]     0          1500  1748.  44440   \n12 12 [Welle 12 (2018)]     0          1500  1667.   7150   \n13 13 [Welle 13 (2019)]     0          1550  1816.  88453   \n\n\nYou can also filter for specific waves if needed:\n\npend %&gt;% \n  filter(welle %in% c(1, 10)) %&gt;% \n  summarise(\n    Minimum = min(netges, na.rm = TRUE),\n    Median = median(netges, na.rm = TRUE),\n    Mean = mean(netges, na.rm = TRUE),\n    Maximum = max(netges, na.rm = TRUE),\n    .by = welle\n  )\n\n# A tibble: 2 × 5\n  welle                    Minimum   Median  Mean Maximum  \n  &lt;dbl+lbl&gt;                &lt;dbl+lbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt;\n1  1 [Welle 1 (2006/2007)] 1           1200 1525. 111419   \n2 10 [Welle 10 (2016)]     0           1375 1541.   6300   \n\n\nThese methods allow for thorough analysis of both categorical and numerical data in R.\n\n\n3.4.5 Exercise",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#übungen",
    "href": "03_desc.html#übungen",
    "title": "3  Getting an Overview",
    "section": "3.5 Übungen",
    "text": "3.5 Übungen\n\nAlle Übungen beziehen sich auf das PASS CampusFile PENDDAT_cf_W13.dta:\n\nlibrary(haven)\npend &lt;- read_dta(\"./orig/PENDDAT_cf_W13.dta\")\n\nZur Erinnerung: hier geht’s zur Übersicht der Einlesebefehle\n\n3.5.1 Übung 1\nWir interessieren uns für die Variable famstand, welche den Familienstand der Befragten enthält:\n\n\n\n\n\n\n\n\nFamilienstand, generiert\nFamilienstand, generiert\n\n\n\n\n-8\nUnplausibler Wert\n\n\n-4\nFrage irrtuemlich nicht gestellt\n\n\n-3\nTrifft nicht zu (Filter)\n\n\n-2\nKeine Antwort\n\n\n1\nLedig\n\n\n2\nVerheiratet/eing. Lebensp., zus. lebd.\n\n\n3\nVerheiratet/eing. Lebensp., getr. lebd.\n\n\n4\nGeschieden\n\n\n5\nVerwitwet\n\n\n\n\n\n\n\n\nLassen Sie sich eine Tabelle mit den absoluten Häufigkeiten anzeigen, nutzen Sie dafür sowohl table() als auch count() (Denken Sie daran, {tidyverse} zu laden für count()).\nÜberschreiben Sie Missing-Codes mit NA.\nHat das Überschreiben der Missings mit NA geklappt? Erstellen Sie die Tabelle erneut.\nLassen Sie sich der relativen Häufigkeiten (Anteile) ausgeben. Verwenden Sie prop.table() auf Basis des table().\nErstellen Sie eine Kontingenztabelle, indem Sie neben famstand auch das Geschlecht zpsex (2 = Frauen, 1 = Männer) mit einbeziehen\n\nZurück nach oben\n\n\n3.5.2 Übung 2\n\n\nErstellen Sie eine Kontingenztabelle für famstand und zpsex\nWie viel Prozent der Befragten sind geschiedene Frauen?\nWie viel Prozent der befragten Frauen sind geschieden? Nutzen Sie die margin =-Option\nWie viel Prozent der befragten Geschiedenen sind Frauen? Nutzen Sie die margin =-Option\n\nZurück nach oben\n\n\n3.5.3 Übung 3\nBeschreiben Sie das Alter der Befragten (palter) mit summary und erstellen Sie selbst einen Überblick mit Hilfe von summarise(), der einen Vergleich des Befragtenalters nach Familienstand erlaubt.\n\nÜberschreiben Sie zunächst die Missings mit NA:\n\n\npend$palter[pend$palter&lt;0] &lt;- NA\npend$famstand[pend$famstand&lt;0] &lt;- NA\n\n\nErstellen Sie einen Überblick mit summary()\nErstellen Sie einen Überblick mit dem Minimum, Median, arith. Mittel, Varianz und Maximum der Alterswerte mit Hilfe von summarise()\nErweitern Sie diesen Überblick dann so, dass sie einen Vergleich der Kennzahlen für die verschiedenen famstand-Kategorien ausgegeben bekommen.\n\nZurück nach oben",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#hinweise",
    "href": "03_desc.html#hinweise",
    "title": "3  Getting an Overview",
    "section": "3.6 Hinweise",
    "text": "3.6 Hinweise\n\n3.6.1 Runden mit round()\nErläuterung: Sie können mit round(x , 3) Werte auf eine gewisse Zahl von Ziffern runden. Die zweite Zahl in der Klammer (nach dem Komma) gibt an, wieviele Dezimalstellen wir möchten:\n\nround(21.12121123,digits = 3)\n\n[1] 21.121\n\nround(21.12121123,digits = 5)\n\n[1] 21.12121\n\nround(21.12121123,digits = 0)\n\n[1] 21\n\n\nWir können also die relativen Häufigkeiten runden und so die Tabelle von oben übersichtlicher machen:\n\nxtabs(~zpsex+statakt, data = pend) %&gt;% \n  prop.table(.,margin = 1) %&gt;% \n  round(.,3)\n\n     statakt\nzpsex     1     2     3\n    1 0.470 0.325 0.205\n    2 0.430 0.261 0.309",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "03_desc.html#footnotes",
    "href": "03_desc.html#footnotes",
    "title": "3  Getting an Overview",
    "section": "",
    "text": "For non-systematic values, we can use the %in% operator that we already learned about in connection with filter(): pend$var1[pend$var1 %in% c(-9,2,124) ]  &lt;- NA (this is just an example).↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting an Overview</span>"
    ]
  },
  {
    "objectID": "05_data_wrangle1_translated.html",
    "href": "05_data_wrangle1_translated.html",
    "title": "4  Data Wrangling I: Labels & factor",
    "section": "",
    "text": "4.1 Labels from Other Programs in R\nIn many software packages like Stata or SPSS, labels are often retained through various operations and then displayed automatically. This is not the case in R. Instead, in R, we can assign labels using the factor variable type. This approach might seem unusual for those who have worked extensively with Stata or SPSS, but it is quite useful in practice if you get accustomed to the workflow.\nFor example, when we create a count summary with count(), the labels we assign are displayed:\npend_kap5$gender &lt;- factor(pend_kap5$zpsex, \n                            levels = c(1, 2), \n                            labels = c(\"Male\", \"Female\"))\n\n# Counting occurrences and showing labels\npend_kap5 %&gt;% \n  count(gender,zpsex)\n\n# A tibble: 2 × 3\n  gender zpsex             n\n  &lt;fct&gt;  &lt;dbl+lbl&gt;     &lt;int&gt;\n1 Male   1 [Maennlich]   324\n2 Female 2 [Weiblich]    359\nBy using factor, we can efficiently manage and display categorical data.\nView(pend_kap5)\npend_kap5 %&gt;% count(zpsex)\nDiese sind als attributes() Variablen zugeordnet:\nattributes(pend_kap5$zpsex)\n\n$label\n[1] \"Steuervariable: Geschlecht des Befragten (aus HHgrid)\"\n\n$format.stata\n[1] \"%42.0g\"\n\n$labels\nItem in Fragebogenversion nicht erhoben             Item in Welle nicht erhoben \n                                    -10                                      -9 \n                      Unplausibler Wert        Frage irrtuemlich nicht gestellt \n                                     -8                                      -4 \n               Trifft nicht zu (Filter)                            Keine Angabe \n                                     -3                                      -2 \n                            Weiss nicht                               Maennlich \n                                     -1                                       1 \n                               Weiblich \n                                      2 \n\n$class\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"\nWie können wir die Labels attributes() verwenden und so Tipparbeit sparen?\n{haven} enthält sich die Funktion as_factor1, mit der wir aus Labels direkt eine factor-Variable erstellen können:\npend_kap5$zpsex_fct &lt;- as_factor(pend_kap5$zpsex)\n\n# ansehen:\npend_kap5 %&gt;% select(contains(\"zpsex\")) %&gt;% head()\n\n# A tibble: 6 × 2\n  zpsex         zpsex_fct\n  &lt;dbl+lbl&gt;     &lt;fct&gt;    \n1 2 [Weiblich]  Weiblich \n2 2 [Weiblich]  Weiblich \n3 1 [Maennlich] Maennlich\n4 1 [Maennlich] Maennlich\n5 2 [Weiblich]  Weiblich \n6 1 [Maennlich] Maennlich",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling I: Labels & factor</span>"
    ]
  },
  {
    "objectID": "05_data_wrangle1_translated.html#factor-selbst-erstellen-oder-bearbeiten",
    "href": "05_data_wrangle1_translated.html#factor-selbst-erstellen-oder-bearbeiten",
    "title": "4  Data Wrangling I: Labels & factor",
    "section": "4.2 factor selbst erstellen oder bearbeiten",
    "text": "4.2 factor selbst erstellen oder bearbeiten\nAlternativ können wir auch mit factor() sowie den Optionen levels und labels selber labeln. Die labels werden dann der Reihenfolge nach den Zahlen aus levels zugewiesen.\n\nattributes(pend_kap5$zpsex)$labels %&gt;% enframe(name = \"label\")\n\n# A tibble: 9 × 2\n  label                                   value\n  &lt;chr&gt;                                   &lt;dbl&gt;\n1 Item in Fragebogenversion nicht erhoben   -10\n2 Item in Welle nicht erhoben                -9\n3 Unplausibler Wert                          -8\n4 Frage irrtuemlich nicht gestellt           -4\n5 Trifft nicht zu (Filter)                   -3\n6 Keine Angabe                               -2\n7 Weiss nicht                                -1\n8 Maennlich                                   1\n9 Weiblich                                    2\n\npend_kap5$zpsex_fct2 &lt;- factor(pend_kap5$zpsex,\n                               levels = c(1,2),\n                               labels = c(\"Männer\",\"Frauen\"))\n\n# ansehen:\npend_kap5 %&gt;% select(contains(\"zpsex\")) %&gt;% head()\n\n# A tibble: 6 × 3\n  zpsex         zpsex_fct zpsex_fct2\n  &lt;dbl+lbl&gt;     &lt;fct&gt;     &lt;fct&gt;     \n1 2 [Weiblich]  Weiblich  Frauen    \n2 2 [Weiblich]  Weiblich  Frauen    \n3 1 [Maennlich] Maennlich Männer    \n4 1 [Maennlich] Maennlich Männer    \n5 2 [Weiblich]  Weiblich  Frauen    \n6 1 [Maennlich] Maennlich Männer    \n\n\nAußerdem wird aus allen nicht angegebenen levels automatisch NA:\n\nattributes(pend_kap5$PSM0100)\n\n$label\n[1] \"Nutzung von sozialen Netzwerken?\"\n\n$format.stata\n[1] \"%39.0f\"\n\n$labels\nItem in Fragebogenversion nicht erhoben             Item in Welle nicht erhoben \n                                    -10                                      -9 \n                      Unplausibler Wert                     Nutzt kein Internet \n                                     -8                                      -5 \n       Frage irrtuemlich nicht gestellt                Trifft nicht zu (Filter) \n                                     -4                                      -3 \n                           Keine Angabe                             Weiss nicht \n                                     -2                                      -1 \n                                     Ja                                    Nein \n                                      1                                       2 \n\n$class\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n\npend_kap5 %&gt;% select(PSM0100) %&gt;% head()\n\n# A tibble: 6 × 1\n  PSM0100                 \n  &lt;dbl+lbl&gt;               \n1  2 [Nein]               \n2  1 [Ja]                 \n3  2 [Nein]               \n4 -5 [Nutzt kein Internet]\n5 -5 [Nutzt kein Internet]\n6 -5 [Nutzt kein Internet]\n\npend_kap5$PSM0100_fct &lt;- \n  factor(pend_kap5$PSM0100, \n         levels = 1:2, \n         labels = c(\"Nutzt soziale Netzwerke\",\"Nutzt keine soziale Netzwerken\"))\n\n# Ergebnis ansehen:\npend_kap5 %&gt;% select(contains(\"PSM0100\")) %&gt;% head()\n\n# A tibble: 6 × 2\n  PSM0100                  PSM0100_fct                   \n  &lt;dbl+lbl&gt;                &lt;fct&gt;                         \n1  2 [Nein]                Nutzt keine soziale Netzwerken\n2  1 [Ja]                  Nutzt soziale Netzwerke       \n3  2 [Nein]                Nutzt keine soziale Netzwerken\n4 -5 [Nutzt kein Internet] &lt;NA&gt;                          \n5 -5 [Nutzt kein Internet] &lt;NA&gt;                          \n6 -5 [Nutzt kein Internet] &lt;NA&gt;                          \n\n\nOder wir nutzen die Funktionen aus {forcats} zur recodierung eines factors. {forcats} ist Teil des {tidyverse}. Mit fct_recode() können wir die levels verändern:\n\nlevels(pend_kap5$PSM0100_fct)\n\n[1] \"Nutzt soziale Netzwerke\"        \"Nutzt keine soziale Netzwerken\"\n\npend_kap5$PSM0100_fct2 &lt;- fct_recode(pend_kap5$PSM0100_fct,\n  `Ja, nutzt soziale Netzwerke` = \"Nutzt soziale Netzwerke\", # bei Leerzeichen `` um die Wörter\n  )\n\n\npend_kap5 %&gt;% select(contains(\"PSM0100\")) %&gt;% head()\n\n# A tibble: 6 × 3\n  PSM0100                  PSM0100_fct                    PSM0100_fct2          \n  &lt;dbl+lbl&gt;                &lt;fct&gt;                          &lt;fct&gt;                 \n1  2 [Nein]                Nutzt keine soziale Netzwerken Nutzt keine soziale N…\n2  1 [Ja]                  Nutzt soziale Netzwerke        Ja, nutzt soziale Net…\n3  2 [Nein]                Nutzt keine soziale Netzwerken Nutzt keine soziale N…\n4 -5 [Nutzt kein Internet] &lt;NA&gt;                           &lt;NA&gt;                  \n5 -5 [Nutzt kein Internet] &lt;NA&gt;                           &lt;NA&gt;                  \n6 -5 [Nutzt kein Internet] &lt;NA&gt;                           &lt;NA&gt;                  \n\n\nWeitere fct_....() Funktionen aus {forcats}, einen Überblick gibt das Cheatsheet.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling I: Labels & factor</span>"
    ]
  },
  {
    "objectID": "05_data_wrangle1_translated.html#übung",
    "href": "05_data_wrangle1_translated.html#übung",
    "title": "4  Data Wrangling I: Labels & factor",
    "section": "4.3 Übung",
    "text": "4.3 Übung\n\npend_ue5 &lt;- haven::read_dta(\"./orig/PENDDAT_cf_W13.dta\",\n                               col_select = c(\"pnr\",\"welle\",\"PD0400\")) %&gt;% \n  filter(PD0400&gt;0)\n\nBearbeiten Sie die value labels von PD0400: Religiositaet, Selbsteinstufung\n\n\nvaluelabel1Ueberhaupt nicht religioes2Eher nicht religioes3Eher religioes4Sehr religioes\n\n\n\nVerschaffen Sie sich zunächst mit head() und einer Auszählung mit count() einen Überblick.\nWie können Sie die labels aus den attributes() mit as_factor() in eine Variable PD0400_fct übernehmen?\nErstellen Sie einen factor() Variable F411_01_fct2 mit value labels: 1 = Überhaupt nicht, 2 = Eher nicht,3 = Eher schon,4 = Sehr\n\nBonusübung: Verwenden Sie die gelabelte Variable für eine Balkengrafik.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling I: Labels & factor</span>"
    ]
  },
  {
    "objectID": "05_data_wrangle1_translated.html#anhang",
    "href": "05_data_wrangle1_translated.html#anhang",
    "title": "4  Data Wrangling I: Labels & factor",
    "section": "4.4 Anhang",
    "text": "4.4 Anhang\n\n4.4.1 Labels löschen mit zap_... aus {haven}\nHäufig führen die Label-attributes() zu Problemen in der weiteren Verarbeitung. Mit haven::zap_labels() können wir die Value labels aus einem Datensatz löschen mit haven::zap_label() können wir die Variable labels entfernen.\n\npend_kap5\n\n# A tibble: 683 × 6\n          pnr welle              zpsex         PSM0100             azges1 palter\n        &lt;dbl&gt; &lt;dbl+lbl&gt;          &lt;dbl+lbl&gt;     &lt;dbl+lbl&gt;           &lt;dbl+&gt; &lt;dbl+&gt;\n 1 1000002601 8 [Welle 8 (2014)] 2 [Weiblich]   2 [Nein]           22     34    \n 2 1000010402 8 [Welle 8 (2014)] 2 [Weiblich]   1 [Ja]             40     30    \n 3 1000019102 8 [Welle 8 (2014)] 1 [Maennlich]  2 [Nein]           40     34    \n 4 1000031403 8 [Welle 8 (2014)] 1 [Maennlich] -5 [Nutzt kein Int… 44     52    \n 5 1000032801 8 [Welle 8 (2014)] 2 [Weiblich]  -5 [Nutzt kein Int… 44     58    \n 6 1000032802 8 [Welle 8 (2014)] 1 [Maennlich] -5 [Nutzt kein Int… 43     62    \n 7 1000038201 8 [Welle 8 (2014)] 1 [Maennlich]  1 [Ja]             43     61    \n 8 1000040003 8 [Welle 8 (2014)] 1 [Maennlich]  2 [Nein]           36     40    \n 9 1000051801 8 [Welle 8 (2014)] 2 [Weiblich]   2 [Nein]           31     44    \n10 1000053101 8 [Welle 8 (2014)] 1 [Maennlich]  1 [Ja]             27     47    \n# ℹ 673 more rows\n\npend_kap5 %&gt;% \n  haven::zap_labels() # value labels raus\n\n# A tibble: 683 × 6\n          pnr welle zpsex PSM0100 azges1 palter\n        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 1000002601     8     2       2     22     34\n 2 1000010402     8     2       1     40     30\n 3 1000019102     8     1       2     40     34\n 4 1000031403     8     1      -5     44     52\n 5 1000032801     8     2      -5     44     58\n 6 1000032802     8     1      -5     43     62\n 7 1000038201     8     1       1     43     61\n 8 1000040003     8     1       2     36     40\n 9 1000051801     8     2       2     31     44\n10 1000053101     8     1       1     27     47\n# ℹ 673 more rows\n\n\n\n\n4.4.2 Labels selbst erstellen und ranspielen\nEin alternativer Weg geht über einen kleinen Label-data.frame und left_join() (mehr zu left_join() später.)\n\ntab2 &lt;- pend_kap5 %&gt;% count(PSM0100)\ntab2\n\n# A tibble: 3 × 2\n  PSM0100                      n\n  &lt;dbl+lbl&gt;                &lt;int&gt;\n1 -5 [Nutzt kein Internet]    28\n2  1 [Ja]                    318\n3  2 [Nein]                  337\n\n\n\nlab_df &lt;- data.frame(PSM0100=1:2)\nlab_df\n\n  PSM0100\n1       1\n2       2\n\nlab_df$PD0400_lab &lt;- factor(lab_df$PSM0100,levels = 1:2,\n                           labels = c(\"Nutzt soziale Netzwerke\",\n                                      \"Nutzt keine soziale Netzwerken\"))\nlab_df\n\n  PSM0100                     PD0400_lab\n1       1        Nutzt soziale Netzwerke\n2       2 Nutzt keine soziale Netzwerken\n\n\n\ntab2 %&gt;% \n  left_join(lab_df,by = \"PSM0100\")\n\n# A tibble: 3 × 3\n  PSM0100                      n PD0400_lab                    \n  &lt;dbl+lbl&gt;                &lt;int&gt; &lt;fct&gt;                         \n1 -5 [Nutzt kein Internet]    28 &lt;NA&gt;                          \n2  1 [Ja]                    318 Nutzt soziale Netzwerke       \n3  2 [Nein]                  337 Nutzt keine soziale Netzwerken\n\n\n\n\n4.4.3 Labels in R erstellen und nach bspw. Stata exportieren\nWenn wir aber beispielsweise einen Datensatz für Stata labeln wollen, hilft uns wieder {labelled}:\n\nlibrary(labelled)\n\nError in library(labelled): es gibt kein Paket namens 'labelled'\n\n\n\npend_kap5$zpsex_num2 &lt;- as.numeric(pend_kap5$zpsex)\nattributes(pend_kap5$zpsex_num2)\n\nNULL\n\nval_labels(pend_kap5$zpsex_num2) &lt;- c(\"Männer\"=1,\"Frauen\"=2)\n\nError in val_labels(pend_kap5$zpsex_num2) &lt;- c(Männer = 1, Frauen = 2): konnte Funktion \"val_labels&lt;-\" nicht finden\n\nattributes(pend_kap5$zpsex_num2)\n\nNULL\n\npend_kap5 %&gt;% count(zpsex_num2)\n\n# A tibble: 2 × 2\n  zpsex_num2     n\n       &lt;dbl&gt; &lt;int&gt;\n1          1   324\n2          2   359\n\n\n\npend_kap5 %&gt;% \n  select(zpsex_num2) %&gt;% \n  haven::write_dta(.,path = \"./data/pend_kap5.dta\")\n\n…in Stata:\n\nuse \"./data/pend_kap5.dta\" \ntab zpsex_num2 \n\n(PASS V3, 2006-2019, 21 Jul 2021, PENDDAT)\n\n\n zpsex_num2 |      Freq.     Percent        Cum.\n------------+-----------------------------------\n     Männer |        324       47.44       47.44\n     Frauen |        359       52.56      100.00\n------------+-----------------------------------\n      Total |        683      100.00\n\n\nMehr zu labels in {labelled}.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling I: Labels & factor</span>"
    ]
  },
  {
    "objectID": "05_data_wrangle1_translated.html#footnotes",
    "href": "05_data_wrangle1_translated.html#footnotes",
    "title": "4  Data Wrangling I: Labels & factor",
    "section": "",
    "text": "Nicht zu verwechseln mit as.factor() aus base R - der _ macht einen Unterschied!↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Wrangling I: Labels & factor</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html",
    "href": "06_data_wrangle2_translated.html",
    "title": "5  Data Wrangling II",
    "section": "",
    "text": "5.1 Creating Variables\nLet’s take a closer look at creating variables in R. There are two basic ways to add variables to a data.frame:",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#var",
    "href": "06_data_wrangle2_translated.html#var",
    "title": "5  Data Wrangling II",
    "section": "",
    "text": "5.1.1 Base R: ...$newvar &lt;-\n\ndat3$studs_to_mean &lt;- dat3$studs - mean(dat3$studs)\ndat3\n\n  studs profs gegr prom_recht                uni studs_to_mean\n1 19173   322 1971       TRUE         Uni Bremen     -2517.625\n2  5333    67 1830       TRUE         Uni Vechta    -16357.625\n3 15643   210 1973       TRUE      Uni Oldenburg     -6047.625\n4 14954   250 1971      FALSE          FH Aachen     -6736.625\n5 47269   553 1870       TRUE        RWTH Aachen     25578.375\n6 23659   438 1457       TRUE       Uni Freiburg      1968.375\n7  9415   150 1818       TRUE           Uni Bonn    -12275.625\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg     16388.375\n\n\nYou can also delete variables using &lt;- NULL:\n\ndat3$studs_to_mean &lt;- NULL\ndat3\n\n  studs profs gegr prom_recht                uni\n1 19173   322 1971       TRUE         Uni Bremen\n2  5333    67 1830       TRUE         Uni Vechta\n3 15643   210 1973       TRUE      Uni Oldenburg\n4 14954   250 1971      FALSE          FH Aachen\n5 47269   553 1870       TRUE        RWTH Aachen\n6 23659   438 1457       TRUE       Uni Freiburg\n7  9415   150 1818       TRUE           Uni Bonn\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg\n\n\n\n\n5.1.2 {dplyr}: mutate(neue_var= )\nAn alternative way to create variables is using mutate(neu_variable = ) from {dplyr} ({tidyverse}):\n\ndat3 %&gt;% mutate(studs_to_mean = studs - mean(studs))\n\n  studs profs gegr prom_recht                uni studs_to_mean\n1 19173   322 1971       TRUE         Uni Bremen     -2517.625\n2  5333    67 1830       TRUE         Uni Vechta    -16357.625\n3 15643   210 1973       TRUE      Uni Oldenburg     -6047.625\n4 14954   250 1971      FALSE          FH Aachen     -6736.625\n5 47269   553 1870       TRUE        RWTH Aachen     25578.375\n6 23659   438 1457       TRUE       Uni Freiburg      1968.375\n7  9415   150 1818       TRUE           Uni Bonn    -12275.625\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg     16388.375\n\n\nYou can also create multiple variables within a single mutate() command:\n\ndat3 %&gt;% mutate(\n  studs_to_mean = studs - mean(studs),\n  profs_to_mean = profs - mean(profs)\n)\n\n  studs profs gegr prom_recht                uni studs_to_mean profs_to_mean\n1 19173   322 1971       TRUE         Uni Bremen     -2517.625         -6.25\n2  5333    67 1830       TRUE         Uni Vechta    -16357.625       -261.25\n3 15643   210 1973       TRUE      Uni Oldenburg     -6047.625       -118.25\n4 14954   250 1971      FALSE          FH Aachen     -6736.625        -78.25\n5 47269   553 1870       TRUE        RWTH Aachen     25578.375        224.75\n6 23659   438 1457       TRUE       Uni Freiburg      1968.375        109.75\n7  9415   150 1818       TRUE           Uni Bonn    -12275.625       -178.25\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg     16388.375        307.75\n\n\nOr variables can be reused within mutate():\n\ndat3 %&gt;% mutate(\n  rel_to_mean = studs - mean(studs),\n  above_mean = rel_to_mean &gt; 0\n)\n\n  studs profs gegr prom_recht                uni rel_to_mean above_mean\n1 19173   322 1971       TRUE         Uni Bremen   -2517.625      FALSE\n2  5333    67 1830       TRUE         Uni Vechta  -16357.625      FALSE\n3 15643   210 1973       TRUE      Uni Oldenburg   -6047.625      FALSE\n4 14954   250 1971      FALSE          FH Aachen   -6736.625      FALSE\n5 47269   553 1870       TRUE        RWTH Aachen   25578.375       TRUE\n6 23659   438 1457       TRUE       Uni Freiburg    1968.375       TRUE\n7  9415   150 1818       TRUE           Uni Bonn  -12275.625      FALSE\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg   16388.375       TRUE\n\n\nThe original dataset remains unchanged:\n\ndat3\n\n  studs profs gegr prom_recht                uni\n1 19173   322 1971       TRUE         Uni Bremen\n2  5333    67 1830       TRUE         Uni Vechta\n3 15643   210 1973       TRUE      Uni Oldenburg\n4 14954   250 1971      FALSE          FH Aachen\n5 47269   553 1870       TRUE        RWTH Aachen\n6 23659   438 1457       TRUE       Uni Freiburg\n7  9415   150 1818       TRUE           Uni Bonn\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg\n\n\nTo keep the results, store them in an object:\n\ndat4 &lt;- dat3 %&gt;% mutate(\n  rel_to_mean = studs - mean(studs),\n  above_mean = rel_to_mean &gt; 0\n)\n\ndat4\n\n  studs profs gegr prom_recht                uni rel_to_mean above_mean\n1 19173   322 1971       TRUE         Uni Bremen   -2517.625      FALSE\n2  5333    67 1830       TRUE         Uni Vechta  -16357.625      FALSE\n3 15643   210 1973       TRUE      Uni Oldenburg   -6047.625      FALSE\n4 14954   250 1971      FALSE          FH Aachen   -6736.625      FALSE\n5 47269   553 1870       TRUE        RWTH Aachen   25578.375       TRUE\n6 23659   438 1457       TRUE       Uni Freiburg    1968.375       TRUE\n7  9415   150 1818       TRUE           Uni Bonn  -12275.625      FALSE\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg   16388.375       TRUE\n\n\n\n\n\n\n\n\nCreating Dummy Variables with as.numeric()\n\n\n\nYou can convert logical variables into numeric dummy variables using as.numeric():\n\ndat3 %&gt;% mutate(\n  prom_dummy = as.numeric(prom_recht),\n  over10k = as.numeric(studs &gt; 10000)\n)\n\n  studs profs gegr prom_recht                uni prom_dummy over10k\n1 19173   322 1971       TRUE         Uni Bremen          1       1\n2  5333    67 1830       TRUE         Uni Vechta          1       0\n3 15643   210 1973       TRUE      Uni Oldenburg          1       1\n4 14954   250 1971      FALSE          FH Aachen          0       1\n5 47269   553 1870       TRUE        RWTH Aachen          1       1\n6 23659   438 1457       TRUE       Uni Freiburg          1       1\n7  9415   150 1818       TRUE           Uni Bonn          1       0\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg          0       1\n\n\n\n\n\n\n5.1.3 Exercise",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#group_by",
    "href": "06_data_wrangle2_translated.html#group_by",
    "title": "5  Data Wrangling II",
    "section": "5.2 Gruppierung mit group_by() oder .by=",
    "text": "5.2 Gruppierung mit group_by() oder .by=\nDie wirkliche Stärke von mutate() kommt aber erst zum Tragen, wenn wir es mit weiteren {dplyr}-Funktionen kombinieren. Eine häufige Aufgabe in der Datenaufbereitung sind gruppierte Werte.\n\n\n\n\n\n\n\n\n\nWir machen unseren Beispieldatensatz noch etwas kleiner:\n\ndat5 &lt;- dat3 %&gt;% \n  select(-uni,-gegr) # nur dass alles zu sehen ist\n\nWenn wir einen Datensatz mit group_by() entlang den Werten einer Variablen gruppieren, dann werden alle weiteren mutate() Berechnungen nur innerhalb dieser Gruppen ausgeführt:\n\ndat5 %&gt;%\n  mutate(m_studs = mean(studs),\n         m_profs = mean(profs)) %&gt;% \n  group_by(prom_recht) %&gt;%\n  mutate(m_studs2 = mean(studs),\n         m_profs2 = mean(profs))\n\n# A tibble: 8 × 7\n# Groups:   prom_recht [2]\n  studs profs prom_recht m_studs m_profs m_studs2 m_profs2\n  &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;        &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 19173   322 TRUE        21691.    328.   20082       290\n2  5333    67 TRUE        21691.    328.   20082       290\n3 15643   210 TRUE        21691.    328.   20082       290\n4 14954   250 FALSE       21691.    328.   26516.      443\n5 47269   553 TRUE        21691.    328.   20082       290\n6 23659   438 TRUE        21691.    328.   20082       290\n7  9415   150 TRUE        21691.    328.   20082       290\n8 38079   636 FALSE       21691.    328.   26516.      443\n\n\nVerwenden wir group_by(), können (sollten!) wir mit ungroup() die Gruppierung wieder aufheben, sobald wir sie nicht mehr benötigen:\n\ndat5 %&gt;%\n  mutate(m_studs = mean(studs),\n         m_profs = mean(profs)) %&gt;% \n  group_by(prom_recht) %&gt;%\n  mutate(m_studs2 = mean(studs)) %&gt;% \n  ungroup() %&gt;% \n  mutate(m_profs2 = mean(profs))\n\n\n\n  studs profs prom_recht  m_studs m_profs m_studs2 m_profs2\n1 19173   322       TRUE 21690.62  328.25  20082.0   328.25\n2  5333    67       TRUE 21690.62  328.25  20082.0   328.25\n3 15643   210       TRUE 21690.62  328.25  20082.0   328.25\n4 14954   250      FALSE 21690.62  328.25  26516.5   328.25\n5 47269   553       TRUE 21690.62  328.25  20082.0   328.25\n6 23659   438       TRUE 21690.62  328.25  20082.0   328.25\n7  9415   150       TRUE 21690.62  328.25  20082.0   328.25\n8 38079   636      FALSE 21690.62  328.25  26516.5   328.25\n\n\nSeit {dplyr}-Version 1.1.1 können wir direkt in mutate() mit dem Argument .by= eine Gruppierung angeben. Diese Gruppierung .by= gilt dabei nur für die unmittelbaren Berechnungen innerhalb mutate() - wir sparen uns das ungroup().\n\ndat5 %&gt;%\n  mutate(m_studs = mean(studs),\n         m_profs = mean(profs)) %&gt;% \n  mutate(m_studs2 = mean(studs),\n         .by = prom_recht) %&gt;% \n  mutate(m_profs2 = mean(profs))\n\n  studs profs prom_recht  m_studs m_profs m_studs2 m_profs2\n1 19173   322       TRUE 21690.62  328.25  20082.0   328.25\n2  5333    67       TRUE 21690.62  328.25  20082.0   328.25\n3 15643   210       TRUE 21690.62  328.25  20082.0   328.25\n4 14954   250      FALSE 21690.62  328.25  26516.5   328.25\n5 47269   553       TRUE 21690.62  328.25  20082.0   328.25\n6 23659   438       TRUE 21690.62  328.25  20082.0   328.25\n7  9415   150       TRUE 21690.62  328.25  20082.0   328.25\n8 38079   636      FALSE 21690.62  328.25  26516.5   328.25\n\n\nMit summarise() statt mutate() erhalten wir eine Übersicht:\n\ndat5 %&gt;%\n  summarise(m_studs = mean(studs),.by = prom_recht)\n\n  prom_recht m_studs\n1       TRUE 20082.0\n2      FALSE 26516.5\n\n\n\n5.2.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#across",
    "href": "06_data_wrangle2_translated.html#across",
    "title": "5  Data Wrangling II",
    "section": "5.3 across(): Mehrere Variablen bearbeiten",
    "text": "5.3 across(): Mehrere Variablen bearbeiten\nEine sehr vielseitige Erweiterung für mutate() und summarise() ist across(). Hier mit können wir eine Funktion auf mehrere Spalten gleichzeitig anwenden, ohne uns zu wiederholen:\n\ndat3 %&gt;%\n  summarise(studs = mean(studs),\n            profs = mean(profs))\n\n     studs  profs\n1 21690.62 328.25\n\n\nHier ist across() deutlich kürzer - für die Variablenauswahl können wir die ?select_helpers verwenden - z.B. matches():\n\ndat3 %&gt;%\n  summarise(across(.cols = matches(\"studs|profs\"),.fns = ~mean(.x)))\n\n     studs  profs\n1 21690.62 328.25\n\n\nNatürlich ist das auch kombinierbar mit group_by():\n\ndat3 %&gt;%\n  group_by(prom_recht) %&gt;%\n  summarise(across(matches(\"studs|profs\"), ~mean(.x)))\n\n# A tibble: 2 × 3\n  prom_recht  studs profs\n  &lt;lgl&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 FALSE      26516.   443\n2 TRUE       20082    290\n\n\nWir können auch mehrere Funktionen durchführen, dafür müssen wir sie in einer list() angeben:\n\ndat3 %&gt;%\n  group_by(prom_recht) %&gt;%\n  summarise(across(matches(\"studs|profs\"), list(mean = ~mean(.x), sd = ~sd(.x))))\n\n# A tibble: 2 × 5\n  prom_recht studs_mean studs_sd profs_mean profs_sd\n  &lt;lgl&gt;           &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1 FALSE          26516.   16352.        443     273.\n2 TRUE           20082    14858.        290     183.\n\n\nDiese list()auch vorab ablegen und dann verwenden:\n\nwert_liste &lt;- list(mean = ~mean(.x), sd = ~sd(.x), max = ~max(.x,na.rm = T))\n\ndat3 %&gt;%\n  group_by(prom_recht) %&gt;%\n  summarise(across(matches(\"studs|profs\"), wert_liste))\n\n# A tibble: 2 × 7\n  prom_recht studs_mean studs_sd studs_max profs_mean profs_sd profs_max\n  &lt;lgl&gt;           &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 FALSE          26516.   16352.     38079        443     273.       636\n2 TRUE           20082    14858.     47269        290     183.       553\n\n\nMit dem .names()-Argument können wir auch die Benennung der Spalten steuern. {.fn} steht dabei als Platzhalter für die angewendete Funktion, {.col} für den Namen der bearbeiteten Variable.\n\ndat3 %&gt;%\n  group_by(prom_recht) %&gt;%\n  summarise(across(matches(\"studs|profs\"), \n                   list(mean = ~mean(.x), sd = ~sd(.x)),\n                   .names = \"{.fn}_{.col}\"))\n\n# A tibble: 2 × 5\n  prom_recht mean_studs sd_studs mean_profs sd_profs\n  &lt;lgl&gt;           &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1 FALSE          26516.   16352.        443     273.\n2 TRUE           20082    14858.        290     183.\n\n\nAlle gezeigten Funktionen funktionieren natürlich auch mit mutate():\n\ndat3 %&gt;%\n  mutate(across(matches(\"studs|profs\"), ~mean(.x), .names = \"m_{.col}\"))\n\n  studs profs gegr prom_recht                uni  m_studs m_profs\n1 19173   322 1971       TRUE         Uni Bremen 21690.62  328.25\n2  5333    67 1830       TRUE         Uni Vechta 21690.62  328.25\n3 15643   210 1973       TRUE      Uni Oldenburg 21690.62  328.25\n4 14954   250 1971      FALSE          FH Aachen 21690.62  328.25\n5 47269   553 1870       TRUE        RWTH Aachen 21690.62  328.25\n6 23659   438 1457       TRUE       Uni Freiburg 21690.62  328.25\n7  9415   150 1818       TRUE           Uni Bonn 21690.62  328.25\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg 21690.62  328.25\n\n\nMehr Beispiele in der Hilfe zu across\n\n5.3.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#eigene-funktionen",
    "href": "06_data_wrangle2_translated.html#eigene-funktionen",
    "title": "5  Data Wrangling II",
    "section": "5.4 Eigene Funktionen",
    "text": "5.4 Eigene Funktionen\nWoher kommt aber die ~1 in across()? Dazu sehen wir uns einmal die Grundlagen von Funktionen in R an.\nDazu sehen wir uns drei Zufriedensheitsvariablen für die Befragten aus den Zeilen 12-16 an:\n\n\n\n\n\n\n\n\n\n\n\n\nvar\nWichtig bei Beruf\n\n\n\n\nPEO0300a\nViel Geld verdienen\n\n\nPEO0300b\nEin Beruf, der Spass macht\n\n\nPEO0300c\nGute Aufstiegsmoeglichkeiten\n\n\nPEO0300d\nEin sicherer Arbeitsplatz\n\n\nPEO0300e\nEin Beruf, bei dem man seine Faehigkeiten zeigen kann\n\n\n\n\n\n\n\n\n\n\n\n\n\n-10 bis -1\n1\n2\n3\n4\n\n\n\n\nt.n.z./k.A.\nSehr wichtig\nEher wichtig\nEher nicht wichtig\nUeberhaupt nicht wichtig\n\n\n\n\n\n\n\n\npend &lt;- haven::read_dta(\"./orig/PENDDAT_cf_W13.dta\")\n\nsat_small &lt;- \n  pend %&gt;% \n    filter(welle == 1) %&gt;% \n    select(matches(\"PEO0300(a|b|c)\")) %&gt;% \n    slice(12:16) %&gt;% \n    haven::zap_labels() %&gt;% haven::zap_label() # labels entfernen\nsat_small\n\n# A tibble: 5 × 3\n  PEO0300a PEO0300b PEO0300c\n     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1        2        3        2\n2        1        1        3\n3        1        1        3\n4        2        1        1\n5        1        1        2\n\n\nHäufig wollen wir mehrere Variablen mit der gleichen Operation bearbeiten. Oben haben wir gesehen wie sich das mit across() für existierende Funktionen erledigen lässt. Was aber, wenn wir eine Berechnung durchführen wollen, die nicht einfach die Anwendung von mean(), sd() o.ä. ist?\n\nsat_small %&gt;% \n  mutate(dmean_PEO0300a = PEO0300a - mean(PEO0300a,na.rm = T),\n         dmean_PEO0300c = PEO0300c - mean(PEO0300c,na.rm = T))\n\n# A tibble: 5 × 5\n  PEO0300a PEO0300b PEO0300c dmean_PEO0300a dmean_PEO0300c\n     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;\n1        2        3        2            0.6         -0.200\n2        1        1        3           -0.4          0.8  \n3        1        1        3           -0.4          0.8  \n4        2        1        1            0.6         -1.2  \n5        1        1        2           -0.4         -0.200\n\n\n…und jetzt noch F1450_06? Dann hätten wir drei Mal das mehr oder weniger gleiche getippt und damit gegen das “DRY”-Prinzip2 verstoßen. Außerdem gibt es im PASS CampusFile insgesamt 5 Spalten mit ähnlichen Zufriedenheitsvariablen. Wenn wir die alle bearbeiten möchten, ist copy & paste keine echte Option.\nEigene Funktionen helfen uns, das DRY-Prinzip in R umzusetzen. Wir machen die Berechnungsschritte Teil einer function() und wenden diese dann auf die gewünschten Variablen an. Eine Funktion hat einen Input, für welchen ein Platzhalter in der () definiert wird. Dieser Platzhalter kann dann innerhalb der Funktion - zwischen den {} - aufgerufen und bearbeitet werden. Als Ergebnis erhalten wir das Objekt, das wir in return() angeben. return() muss immer als letztes angeben werden und wir können immer nur ein Objekt als Output definieren:\n\ndtomean &lt;- function(x){\n  d_x &lt;- x - mean(x,na.rm = T)\n  return(d_x)\n}\n\n\nvar1 &lt;- c(1,6,3,7,8,1,5)\nmean(var1)\n\n[1] 4.428571\n\ndtomean(var1)\n\n[1] -3.4285714  1.5714286 -1.4285714  2.5714286  3.5714286 -3.4285714  0.5714286\n\n\nWie können wir unsere Funktion dtomean() jetzt auf die Variablen aus unserem sat_small anwenden? Grundsätzlich haben wir ganz zu Beginn gesehen, dass ein data.frame lediglich zusammengefügte Sammlung von Vektoren (den Variablen) ist. Dementsprechend können wir jetzt unsere dtomean() auf eine Variable (einen Vektor) anwenden, indem wir ihn mit data.frame$variablename aufrufen:\n\ndtomean(sat_small$PEO0300a)\n\n[1]  0.6 -0.4 -0.4  0.6 -0.4\n\n\nUm unsere Funktion jetzt auf jede Variable eines data.frame anzuwenden, können wir lapply() verwenden - der Output ist dann eine Liste, deren Elemente nach den Variablennamen benannt werden:\n\nlapply(sat_small,FUN = dtomean)\n\n$PEO0300a\n[1]  0.6 -0.4 -0.4  0.6 -0.4\n\n$PEO0300b\n[1]  1.6 -0.4 -0.4 -0.4 -0.4\n\n$PEO0300c\n[1] -0.2  0.8  0.8 -1.2 -0.2\n\nres &lt;- lapply(sat_small,FUN = dtomean)\nclass(res)\n\n[1] \"list\"\n\n\nmap() aus {purrr} ist eine Alternative zu lapply:\n\nlapply(sat_small,FUN = dtomean)\n\n$PEO0300a\n[1]  0.6 -0.4 -0.4  0.6 -0.4\n\n$PEO0300b\n[1]  1.6 -0.4 -0.4 -0.4 -0.4\n\n$PEO0300c\n[1] -0.2  0.8  0.8 -1.2 -0.2\n\nsat_small %&gt;% map(~dtomean(.x))\n\n$PEO0300a\n[1]  0.6 -0.4 -0.4  0.6 -0.4\n\n$PEO0300b\n[1]  1.6 -0.4 -0.4 -0.4 -0.4\n\n$PEO0300c\n[1] -0.2  0.8  0.8 -1.2 -0.2\n\n\nDiese formula syntax Schreibweise findet sich dann auch in across() wieder - zusätzlich haben wir hier direkt über .names = die Möglichkeit, die Variablennamen für die Ergebnisse zu bearbeiten:\n\nsat_small %&gt;% \n  mutate(across(matches(\"PEO0300\"),~dtomean(.x),.names = \"dmean_{.col}\"))\n\n# A tibble: 5 × 6\n  PEO0300a PEO0300b PEO0300c dmean_PEO0300a dmean_PEO0300b dmean_PEO0300c\n     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;\n1        2        3        2            0.6            1.6         -0.200\n2        1        1        3           -0.4           -0.4          0.8  \n3        1        1        3           -0.4           -0.4          0.8  \n4        2        1        1            0.6           -0.4         -1.2  \n5        1        1        2           -0.4           -0.4         -0.200\n\n\n\n\n\n\n\n5.4.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#hilfsfunktionen-ifelse-und-case_when",
    "href": "06_data_wrangle2_translated.html#hilfsfunktionen-ifelse-und-case_when",
    "title": "5  Data Wrangling II",
    "section": "5.5 Hilfsfunktionen ifelse() und case_when()",
    "text": "5.5 Hilfsfunktionen ifelse() und case_when()\nifelse() ist eine große Hilfe für alle Umcodierungen: wir formulieren darin eine Bedingung und wenn diese zutrifft wird der erste Wert eingesetzt, wenn nicht wird der zweite Wert eingesetzt. Hier fragen wir also ab, ob studs-mean(studs) größer 0 ist - dann wird darüber eingesetzt, ansonsten eine darunter:\n\ndat3 %&gt;% mutate(rel_to_mean = studs-mean(studs),\n                ab_mean_lab = ifelse(rel_to_mean &gt; 0,\"darüber\",\"darunter\"))\n\n  studs profs gegr prom_recht                uni rel_to_mean ab_mean_lab\n1 19173   322 1971       TRUE         Uni Bremen   -2517.625    darunter\n2  5333    67 1830       TRUE         Uni Vechta  -16357.625    darunter\n3 15643   210 1973       TRUE      Uni Oldenburg   -6047.625    darunter\n4 14954   250 1971      FALSE          FH Aachen   -6736.625    darunter\n5 47269   553 1870       TRUE        RWTH Aachen   25578.375     darüber\n6 23659   438 1457       TRUE       Uni Freiburg    1968.375     darüber\n7  9415   150 1818       TRUE           Uni Bonn  -12275.625    darunter\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg   16388.375     darüber\n\n\ncase_when() ({dplyr}) erweitert dieses Prinzip, sodass wir mehr als zwei Optionen angeben können. Die Syntax ist aber etwas anders: hier geben wir erst die Bedingung an, dann nach einer ~3 die einzusetzenden Werte:\n\ndat3 %&gt;% mutate(alter = case_when(gegr &lt; 1500 ~ \"sehr alt\",\n                                  gegr &lt; 1900 ~ \"alt\"))\n\n  studs profs gegr prom_recht                uni    alter\n1 19173   322 1971       TRUE         Uni Bremen     &lt;NA&gt;\n2  5333    67 1830       TRUE         Uni Vechta      alt\n3 15643   210 1973       TRUE      Uni Oldenburg     &lt;NA&gt;\n4 14954   250 1971      FALSE          FH Aachen     &lt;NA&gt;\n5 47269   553 1870       TRUE        RWTH Aachen      alt\n6 23659   438 1457       TRUE       Uni Freiburg sehr alt\n7  9415   150 1818       TRUE           Uni Bonn      alt\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg     &lt;NA&gt;\n\n\nMit TRUE können alle Fälle angesprochen werden, die bis dahin keiner Bedingung entsprochen haben:\n\ndat3 %&gt;% mutate(alter = case_when(gegr &lt; 1500 ~ \"sehr alt\",\n                                  gegr &lt; 1900 ~ \"alt\",\n                                  TRUE ~ \"relativ neu\"))\n\n  studs profs gegr prom_recht                uni       alter\n1 19173   322 1971       TRUE         Uni Bremen relativ neu\n2  5333    67 1830       TRUE         Uni Vechta         alt\n3 15643   210 1973       TRUE      Uni Oldenburg relativ neu\n4 14954   250 1971      FALSE          FH Aachen relativ neu\n5 47269   553 1870       TRUE        RWTH Aachen         alt\n6 23659   438 1457       TRUE       Uni Freiburg    sehr alt\n7  9415   150 1818       TRUE           Uni Bonn         alt\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg relativ neu\n\n\nDas muss sich nicht auf eine Variable beschränken:\n\ndat3 %&gt;% mutate(alter = case_when(gegr &lt; 1500 & prom_recht == T ~ \"sehr alte Uni\",\n                                  gegr &lt; 1900 & prom_recht == T ~ \"alte Uni\",\n                                  gegr &gt; 1900 & prom_recht == T ~ \"junge Uni\",\n                                  gegr &lt; 1900 & prom_recht == F ~ \"alte Hochschule\",\n                                  gegr &gt; 1900 & prom_recht == F ~ \"junge Hochschule\"))\n\n  studs profs gegr prom_recht                uni            alter\n1 19173   322 1971       TRUE         Uni Bremen        junge Uni\n2  5333    67 1830       TRUE         Uni Vechta         alte Uni\n3 15643   210 1973       TRUE      Uni Oldenburg        junge Uni\n4 14954   250 1971      FALSE          FH Aachen junge Hochschule\n5 47269   553 1870       TRUE        RWTH Aachen         alte Uni\n6 23659   438 1457       TRUE       Uni Freiburg    sehr alte Uni\n7  9415   150 1818       TRUE           Uni Bonn         alte Uni\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg junge Hochschule\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.5.1 Übung",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#variablen-umbenennen",
    "href": "06_data_wrangle2_translated.html#variablen-umbenennen",
    "title": "5  Data Wrangling II",
    "section": "5.6 Variablen umbenennen",
    "text": "5.6 Variablen umbenennen\nUm Variablen umzubenennen gibt es rename(neuer_name = alter_name)\n\nsat_small %&gt;% rename(neuername =PEO0300a)\n\n# A tibble: 5 × 3\n  neuername PEO0300b PEO0300c\n      &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1         2        3        2\n2         1        1        3\n3         1        1        3\n4         2        1        1\n5         1        1        2\n\n\nFür fortgeschrittene Veränderungen empfiehlt sich ein Blick in rename_with(). Damit können wir Regular Expressions, bspw. aus {stringr} verwenden. Hier nur ein Beispiel:\n\nsat_small %&gt;% rename_with(~tolower(.))\n\n# A tibble: 5 × 3\n  peo0300a peo0300b peo0300c\n     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1        2        3        2\n2        1        1        3\n3        1        1        3\n4        2        1        1\n5        1        1        2\n\nsat_small %&gt;% rename_with(~str_remove(.x,\"PEO0300\"))\n\n# A tibble: 5 × 3\n      a     b     c\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     2     3     2\n2     1     1     3\n3     1     1     3\n4     2     1     1\n5     1     1     2\n\nsat_small %&gt;% rename_with(~str_replace(.x,\"PEO0300\",\"Beruf_\"))\n\n# A tibble: 5 × 3\n  Beruf_a Beruf_b Beruf_c\n    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1       2       3       2\n2       1       1       3\n3       1       1       3\n4       2       1       1\n5       1       1       2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#übungen",
    "href": "06_data_wrangle2_translated.html#übungen",
    "title": "5  Data Wrangling II",
    "section": "5.7 Übungen",
    "text": "5.7 Übungen\n\n5.7.1 Übung\n\nErstellen Sie dat3 wie oben gezeigt aus dat1 und dat2\nBerechnen Sie das Betreuungsverhältnis (Studierende pro Professur studs/profs) an den Hochschulen relativ zum Mittelwert des Betreuungsverhältnisses (rel_studprofs).\nLiegt das Betreuungsverhältnis über oder unter dem Mittelwert? Wie können Sie den Befehl anpassen, sodass die Variable rel_studprofs lediglich TRUE oder FALSE enthält anstelle der Zahlenwerte.\nWandeln Sie rel_studprofs in eine Dummy-Variable mit 0/1 als Werten statt TRUE/FALSE\n\n\n\n\n\n\n\nDaumenregel zur Entscheidung, ob mutate() oder ...$newvar &lt;- besser passt: Immer wenn es nur darum geht, schnell eine Variable zu erstellen/löschen, ist ...$newvar &lt;- die einfachere Wahl. Sobald es darüber hinaus geht, hat mutate() sehr große Vorteile (folgender Abschnitt).\n\n\n\nZurück nach oben\n\n\n5.7.2 Übung\n\nVerwenden Sie weiterhin den Uni-Datensatz.\nBerechnen Sie das Betreuungsverhältnis (studprofs) relativ zum Mittelwert getrennt für Hochschulen/Unis mit und ohne Promotionsrecht und fügen Sie dieses als neue Spalte ein.\nTesten Sie sowohl die Variante mit group_by() als auch .by =.\n\nZurück nach oben\n\n\n\n\n\n5.7.3 Übung\n\nVerwenden Sie den pend_small-Datensatz:\n\n\npend_small &lt;- haven::read_dta(\"./orig/PENDDAT_cf_W13.dta\",\n                               col_select = c(\"welle\",\"zpsex\",\"PEO0400a\",\"PEO0400b\",\"PEO0400c\",\"PEO0400d\")\n                               ) %&gt;% \n  filter(welle == 2) %&gt;% \n  slice(1:15)\n\n\nBerechnen Sie den Mittelwert für die Variablen PEO0400a, PEO0400b, PEO0400c und PEO0400d:\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar\nlab\n\n\n\n\nPEO0400a\nFrau sollte bereit, Arbeitszeit wegen Familie zu verringern\n\n\nPEO0400b\nWas Frauen wirklich wollen, sind ein Heim und Kinder\n\n\nPEO0400c\nBerufst. Mutter kann genauso herzl. Verhaeltn. zu Kindern haben\n\n\nPEO0400d\nAufgabe Ehemann: Geld verdienen, Aufgabe Ehefrau: Haushalt/Fam.\n\n\n\n\n\n\n\n   welle zpsex PEO0400a PEO0400b PEO0400c PEO0400d\n1      2     2        1        1        4        1\n2      2     1        2        1        3        2\n3      2     2        1        3        1        4\n4      2     2        1        1        4        1\n5      2     2        1        1        1        1\n6      2     1        1        1        1        1\n7      2     1        1        2        1        4\n8      2     1        3        2        3        2\n9      2     2        3        3        3        3\n10     2     1        2        3        2        2\n11     2     1        4        3        2        3\n12     2     2        2        3        2        3\n13     2     1        2        3        2        3\n14     2     1        1        2        1        1\n15     2     1        1        1        1        2\n\n\n\nVerwenden Sie across(), um die Mittelwerte für alle vier Variablen zu berechnen.\nBerechnen Sie die Mittelwerte getrennt nach Geschlecht (zpsex), indem Sie group_by() oder .by = verwenden.\nFügen Sie auch die Varianz (var()) hinzu und nutzen sie .names=, um die Spaltennamen nach dem Schema kennzahl.variable zu benennen.\n\nZurück nach oben\n\n\n5.7.4 Übung\nVerwenden Sie weiterhin pend_small:\n\npend_small\n\n\n\n   welle zpsex PEO0400a PEO0400b PEO0400c PEO0400d\n1      2     2        1        1        4        1\n2      2     1        2        1        3        2\n3      2     2        1        3        1        4\n4      2     2        1        1        4        1\n5      2     2        1        1        1        1\n6      2     1        1        1        1        1\n7      2     1        1        2        1        4\n8      2     1        3        2        3        2\n9      2     2        3        3        3        3\n10     2     1        2        3        2        2\n11     2     1        4        3        2        3\n12     2     2        2        3        2        3\n13     2     1        2        3        2        3\n14     2     1        1        2        1        1\n15     2     1        1        1        1        2\n\n\n\nStandardisieren Sie die Variablen PEO0400a - PEO0400d aus pend_small nach folgendem Muster:\n\n\npend_small %&gt;% \n  mutate(std_PEO0400b = (PEO0400b - mean(PEO0400b,na.rm = T))/sd(PEO0400b,na.rm = T))\n\n\nNutzen Sie eine Funktion, um nicht wiederholt die gleichen Schritte einzugeben.\nVerwenden Sie zusätzlich across(), um die Funktion auf die gewünschten Variablen anzuwenden.\n\nZurück nach oben\n\n\n5.7.5 Übung\n\nBearbeiten Sie pend_small2:\n\n\npend_small2 &lt;- haven::read_dta(\"./orig/PENDDAT_cf_W13.dta\",\n                         col_select = c(\"palter\",\"PEO0400a\",\"PEO0400b\",\"PEO0400c\",\"statakt\")) \npend_small2 &lt;- pend_small2 %&gt;% slice(5624:5640)\npend_small2\n\n# A tibble: 17 × 5\n   palter    PEO0400a                         PEO0400b        PEO0400c statakt  \n   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;                        &lt;dbl+lbl&gt;       &lt;dbl+lb&gt; &lt;dbl+lbl&gt;\n 1 77         1 [Stimme voll und ganz zu]      3 [Stimme ehe…  3 [Sti… -10 [Ite…\n 2 78        -9 [Item in Welle nicht erhoben] -9 [Item in We… -9 [Ite… -10 [Ite…\n 3 51         2 [Stimme eher zu]               4 [Stimme ueb…  1 [Sti…  -9 [Ite…\n 4 23         3 [Stimme eher nicht zu]         3 [Stimme ehe…  2 [Sti…  -9 [Ite…\n 5 17         3 [Stimme eher nicht zu]         2 [Stimme ehe…  1 [Sti…  -9 [Ite…\n 6 47         3 [Stimme eher nicht zu]         2 [Stimme ehe…  2 [Sti…  -9 [Ite…\n 7 24         3 [Stimme eher nicht zu]         4 [Stimme ueb…  1 [Sti…   1 [Erw…\n 8 52         2 [Stimme eher zu]               3 [Stimme ehe…  1 [Sti…   1 [Erw…\n 9 19         2 [Stimme eher zu]               3 [Stimme ehe…  2 [Sti…   3 [Ina…\n10 48         2 [Stimme eher zu]               3 [Stimme ehe…  1 [Sti…   1 [Erw…\n11 49        -9 [Item in Welle nicht erhoben] -9 [Item in We… -9 [Ite…  -5 [Gen…\n12 47         2 [Stimme eher zu]               3 [Stimme ehe…  1 [Sti…  -9 [Ite…\n13 48         2 [Stimme eher zu]               3 [Stimme ehe…  1 [Sti…   1 [Erw…\n14 49        -9 [Item in Welle nicht erhoben] -9 [Item in We… -9 [Ite…   1 [Erw…\n15 39         4 [Stimme ueberhaupt nicht zu]   3 [Stimme ehe…  1 [Sti…  -9 [Ite…\n16 37         3 [Stimme eher nicht zu]         4 [Stimme ueb…  1 [Sti…  -9 [Ite…\n17 38         3 [Stimme eher nicht zu]         3 [Stimme ehe…  1 [Sti…   1 [Erw…\n\n\n\nNutzen Sie ifelse(), um Personen ab 50 Jahren mit “ü50” zu kennzeichnen - lassen Sie für Personen bis unter 50 Jahren “u50” eintragen.\nFühren Sie eine Dreiteilung durch: Personen bis unter 40 bekommen “u40”, Personen bis &lt;50 “u50” und Personen ab 50 Jahren “ü50”. Wie würden Sie mit case_when() vorgehen?\nNutzen Sie ifelse(), um Werte &lt; 0 in den Variablen PEO0400a, PEO0400b, PEO0400c und statakt in pend_small2 mit NA zu überschreiben.\nSchreiben Sie zunächst eine ifelse()-Funktion, die für PEO0400a alle Werte &lt; 0 mit NA überschreibt und ansonsten den Ausgangswert PEO0400a einsetzt.\nWie würde die Funktion aussehen, wenn Sie sie mit across() auf PEO0400a, PEO0400b, PEO0400c und statakt gleichzeitig anwenden?\n\nZurück nach oben",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#anhang",
    "href": "06_data_wrangle2_translated.html#anhang",
    "title": "5  Data Wrangling II",
    "section": "5.8 Anhang",
    "text": "5.8 Anhang\n\n5.8.1 Klassen bilden mit cut()\n\ndat3\n\n  studs profs gegr prom_recht                uni\n1 19173   322 1971       TRUE         Uni Bremen\n2  5333    67 1830       TRUE         Uni Vechta\n3 15643   210 1973       TRUE      Uni Oldenburg\n4 14954   250 1971      FALSE          FH Aachen\n5 47269   553 1870       TRUE        RWTH Aachen\n6 23659   438 1457       TRUE       Uni Freiburg\n7  9415   150 1818       TRUE           Uni Bonn\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg\n\n\nEine häufig Aufgabe in der Datenaufbereitung die Klassierung eines metrisches Merkmals, wie zum Beispiel die Professorenzahlen. Wir möchten also profs in 150er-Schritten zusammenfassen. Um die Klassen zu bilden, nutzen wir cut() und geben neben der zu unterteilenden Variable mit breaks die Klassengrenzen an. Für die Grenzen können wir seq() verwenden. Darin geben wir zunächst die obere und untere Grenze an und dann die Schrittbreiten.\n\ncut(dat3$profs,breaks = c(50, 200, 350, 500, 650))\n\n[1] (200,350] (50,200]  (200,350] (200,350] (500,650] (350,500] (50,200] \n[8] (500,650]\nLevels: (50,200] (200,350] (350,500] (500,650]\n\ncut(dat3$profs,breaks = seq(50,650,150))\n\n[1] (200,350] (50,200]  (200,350] (200,350] (500,650] (350,500] (50,200] \n[8] (500,650]\nLevels: (50,200] (200,350] (350,500] (500,650]\n\n\nDiese Werte legen wir in einer neuen Variable im Datensatz dat3 ab:\n\ndat3$prof_class &lt;- cut(dat3$profs,breaks = seq(50,650,150))\ndat3\n\n  studs profs gegr prom_recht                uni prof_class\n1 19173   322 1971       TRUE         Uni Bremen  (200,350]\n2  5333    67 1830       TRUE         Uni Vechta   (50,200]\n3 15643   210 1973       TRUE      Uni Oldenburg  (200,350]\n4 14954   250 1971      FALSE          FH Aachen  (200,350]\n5 47269   553 1870       TRUE        RWTH Aachen  (500,650]\n6 23659   438 1457       TRUE       Uni Freiburg  (350,500]\n7  9415   150 1818       TRUE           Uni Bonn   (50,200]\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg  (500,650]\n\n\nFür diese neue Variable können wir mit count() eine Häufigkeitstabelle anfordern:\n\ndat3 %&gt;% count(prof_class)\n\n  prof_class n\n1   (50,200] 2\n2  (200,350] 3\n3  (350,500] 1\n4  (500,650] 2\n\n\n( bedeutet dabei ausgeschlossen, ] inklusive. Es gibt also 3 Unis im Datensatz, die über 200 bis inklusive 350 Professuren unterhalten.\nFür die weiteren Beispiele löschen wir die prof_class wieder:\n\ndat3$prof_class &lt;- NULL\n\nEinige hilfreiche Optionen für cut() im Anhang\n\nbsp &lt;- c(1990,1998,2001,2009)\nbsp\n\n[1] 1990 1998 2001 2009\n\ncut(bsp,breaks = c(1990,2000,2010)) \n\n[1] &lt;NA&gt;             (1.99e+03,2e+03] (2e+03,2.01e+03] (2e+03,2.01e+03]\nLevels: (1.99e+03,2e+03] (2e+03,2.01e+03]\n\n# Anzahl der stellen in den labels\ncut(bsp,breaks = c(1990,2000,2010),dig.lab = 4) \n\n[1] &lt;NA&gt;        (1990,2000] (2000,2010] (2000,2010]\nLevels: (1990,2000] (2000,2010]\n\n# untere Grenze mit einbeziehen\ncut(bsp,breaks = c(1990,2000,2010),dig.lab = 4,include.lowest = T) \n\n[1] [1990,2000] [1990,2000] (2000,2010] (2000,2010]\nLevels: [1990,2000] (2000,2010]\n\n# durchnummerieren statt labels:\ncut(bsp,breaks = c(1990,2000,2010),labels = FALSE)\n\n[1] NA  1  2  2\n\n# eigene labels angeben:\ncut(bsp,breaks = c(1990,2000,2010),labels = c(\"90er\",\"00er\"))\n\n[1] &lt;NA&gt; 90er 00er 00er\nLevels: 90er 00er\n\n\n\n\n5.8.2 String-Funktionen für regex\n{stringr} stellt eine ganze Reihe an sehr hilfreichen String-Funktionen mit Regular Expressions zur Verfügung, einen Überblick bietet das Cheatsheet\n\ndat3 %&gt;% mutate(uni_fh = str_detect(uni,\"Uni\"))\n\n  studs profs gegr prom_recht                uni uni_fh\n1 19173   322 1971       TRUE         Uni Bremen   TRUE\n2  5333    67 1830       TRUE         Uni Vechta   TRUE\n3 15643   210 1973       TRUE      Uni Oldenburg   TRUE\n4 14954   250 1971      FALSE          FH Aachen  FALSE\n5 47269   553 1870       TRUE        RWTH Aachen  FALSE\n6 23659   438 1457       TRUE       Uni Freiburg   TRUE\n7  9415   150 1818       TRUE           Uni Bonn   TRUE\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg  FALSE\n\ndat3 %&gt;% mutate(bula = case_when(str_detect(uni,\"Bremen\")~ \"HB\",\n                                 str_detect(uni,\"Oldenb|Vechta\")~ \"NDS\",\n                                 str_detect(uni,\"Bonn|Aachen\")~ \"NRW\",\n                                 str_detect(uni,\"Freiburg\")~ \"BW\"\n                                 ))\n\n  studs profs gegr prom_recht                uni bula\n1 19173   322 1971       TRUE         Uni Bremen   HB\n2  5333    67 1830       TRUE         Uni Vechta  NDS\n3 15643   210 1973       TRUE      Uni Oldenburg  NDS\n4 14954   250 1971      FALSE          FH Aachen  NRW\n5 47269   553 1870       TRUE        RWTH Aachen  NRW\n6 23659   438 1457       TRUE       Uni Freiburg   BW\n7  9415   150 1818       TRUE           Uni Bonn  NRW\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg  NRW\n\ndat3 %&gt;% mutate(ort = str_remove(uni,\"Uni |FH |RWTH \"))\n\n  studs profs gegr prom_recht                uni             ort\n1 19173   322 1971       TRUE         Uni Bremen          Bremen\n2  5333    67 1830       TRUE         Uni Vechta          Vechta\n3 15643   210 1973       TRUE      Uni Oldenburg       Oldenburg\n4 14954   250 1971      FALSE          FH Aachen          Aachen\n5 47269   553 1870       TRUE        RWTH Aachen          Aachen\n6 23659   438 1457       TRUE       Uni Freiburg        Freiburg\n7  9415   150 1818       TRUE           Uni Bonn            Bonn\n8 38079   636 1995      FALSE FH Bonn-Rhein-Sieg Bonn-Rhein-Sieg",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "06_data_wrangle2_translated.html#footnotes",
    "href": "06_data_wrangle2_translated.html#footnotes",
    "title": "5  Data Wrangling II",
    "section": "",
    "text": "“Tilde” - Tastaturbefehle: Alt Gr + * auf Windows. Auf macOS Alt + N und anschließend ein Leerzeichen, damit die Tilde erscheint.↩︎\nDo not repeat yourself, siehe Wickham et al: “You should consider writing a function whenever you’ve copied and pasted a block of code more than twice (i.e. you now have three copies of the same code).”↩︎\n“Tilde” - Tastaturbefehle: Alt Gr + * auf Windows. Auf macOS Alt + N und anschließend ein Leerzeichen, damit die Tilde erscheint.↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Wrangling II</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html",
    "href": "04_viz_translated.html",
    "title": "6  Visualization with {ggplot2}",
    "section": "",
    "text": "6.1 ggplot2 and the Grammar of Graphics\nggplot2 is the implementation of the concept of “layered grammar of graphics” in R. The idea of this visualization system is to break down data visualization into parameters: the underlying dataset, the variables to be displayed, the choice of display shapes, the coordinate system, scales, and statistical transformations. A standard command in ggplot2 looks something like this:\nggplot(data = dataset, aes(x = var1, y = var2, color = var3)) +\n  geom_point() +\n  labs(title= \"Title\", subtitle = \"Subtitle\") +\n  theme_minimal()\nSo we first call up a plot with ggplot(). Further arguments then define additional aspects:\nNow we will work through the individual layers of the graphic:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#ggplot2-and-the-grammar-of-graphics",
    "href": "04_viz_translated.html#ggplot2-and-the-grammar-of-graphics",
    "title": "6  Visualization with {ggplot2}",
    "section": "",
    "text": "With data =, we specify the data.frame we want to visualize.\nThe aesthetics aes() specify which variables are to be displayed: here var1 on the x-axis, var2 on the y-axis, and var3 for coloring.\nThe layers geom_.. specify the type of display, e.g., geom_point() for point plots and geom_bar() for bar charts.\nWith labs, we can add labels, such as a title or axis labels.\nThe themes theme_... set the design of the graphic, e.g., black and white axes and background colors with theme_bw().\n\n\n\n6.1.1 data =\nIn data =, we specify the data.frame that contains the information to be visualized. We start our ggplot with:\n\nggplot(data = pend_small)\n\n\n\n\n\n\n\n\n\n\n6.1.2 aes\nWe want to visualize these values in a scatterplot, with age on the x-axis and weekly working hours on the y-axis:\n\nggplot(data = pend_small, aes(x = palter, y = azges1))\n\n\n\n\n\n\n\n\n\n\n6.1.3 geom\nIf we only provide these details, we will get an empty coordinate system—why? Because we haven’t yet specified what form of display we want. For this, we must specify a geom_, such as geom_col() for bar charts, which we attach to the ggplot command with +:\n\nggplot(data = pend_small, aes(x = palter, y = azges1)) + geom_point()\n\n\n\n\n\n\n\n\nWith color =, we can also change the color of the points:\n\nggplot(data = pend_small, aes(x = palter, y = azges1)) + geom_point(color = \"orange\")\n\n\n\n\n\n\n\n\nHere is an overview of all color names that are recognized, though there are many more colors—see Appendix.\n\n\n6.1.4 aes() Part II\nThis already looks pretty good, but the points are not yet separated by gender. To do this, we need to include the gender information (zpsex) in aes(). In addition to the axes, aes() also specifies the variables for the appearance of the geom_s—this can include not only color but also shape, size, or transparency. Here’s an overview.\nGender should determine the color of the points, which we can specify in aes with color:\n\n# results in an error due to labels:\nggplot(data = pend_small, aes(x = palter, y = azges1, color = zpsex )) + \n  geom_point()\n\nError in UseMethod(\"rescale\"): nicht anwendbare Methode für 'rescale' auf Objekt der Klasse \"c('haven_labelled', 'vctrs_vctr', 'double')\" angewendet\n\n\nA numeric variable for color = results in a color gradient, while a factor/character variable results in a discrete color scale:\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.numeric(zpsex))) + \n  geom_point()\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.factor(zpsex))) + \n  geom_point()\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.character(zpsex))) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also specify custom colors with scale_color_manual1, and a list of possible colors can be found here.\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.factor(zpsex))) + \n  geom_point() + \n  scale_color_manual(values = c(\"lightskyblue4\",\"navy\"))\n\n\n\n\n\n\n\n\n\n\n6.1.5 Labels\nWith the breaks and labels options, we can also edit the legend labels. To do this, we first specify the levels of the gender variable in breaks and then the corresponding labels in the same order:\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = as.factor(zpsex))) + \n  geom_point() + \n  scale_color_manual(values = c(\"lightskyblue4\",\"navy\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\n\n\n\n\n\n\n\n\nFinally, we adjust the labels with labs, where we have the following options:\n\ntitle: Title for the graphic\nsubtitle: Subtitle for the title\ncaption: Annotation below the graphic\nx: x-axis label\ny: y-axis label\nfill: Legend label when fill is specified in aes()\ncolor: Legend label when color is specified in aes()\nlinetype: Legend label when linetype is specified in aes()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#combination-of-all-options",
    "href": "04_viz_translated.html#combination-of-all-options",
    "title": "6  Visualization with {ggplot2}",
    "section": "6.2 Combination of all options",
    "text": "6.2 Combination of all options\n\nggplot(data = pend_small, aes(x = palter, y = azges1, \n                               shape = as.factor(zpsex),\n                               color = as.factor(zpsex))) + \n  geom_point(size = 4) + \n  scale_color_manual(values = c(\"lightskyblue\",\"orange\"),\n                     breaks = c(1,2), labels = c(\"Men\", \"Women\")\n                     ) +\n  scale_shape_manual(values = c(18,20),\n                     breaks = c(1,2), labels = c(\"Men\", \"Women\")\n                     ) +\n  labs(color = \"Gender\", \n       shape = \"Gender\",\n       y = \"Hours/Week\",\n       x = \"Age\",\n       title = \"Working hours and age\",\n       subtitle = \"By Gender\",\n       caption = \"Soruce: PASS CF 0619\"\n       ) \n\n\n\n\n\n\n\n\nÜbersicht zu shapes",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#visualizing-distributions",
    "href": "04_viz_translated.html#visualizing-distributions",
    "title": "6  Visualization with {ggplot2}",
    "section": "6.3 Visualizing distributions",
    "text": "6.3 Visualizing distributions\nWith the following syntax we can create a boxplot using ggplot2. Since we are only considering one variable, we only need to specify y = or x = depending on whether the box should be oriented vertically or horizontally.\nggplot(data = pend_small, aes(y = azges1)) + geom_boxplot()\nggplot(data = pend_small, aes(x = azges1)) + geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also create separate boxplots for men and women by specifying a variable for the other axis:\n\nggplot(data = pend_small, aes(y = azges1, x = factor(zpsex))) + geom_boxplot()\n\n\n\n\n\n\n\n\n\n6.3.1 Histogram\nWe can also describe distributions using a histogram using the geom_histogram() function. If we want to change the color, fill = is the correct option instead of color =:\nggplot(data = pend_small, aes(x = azges1)) + \n  geom_histogram()  \nggplot(data = pend_small, aes(x = azges1)) + \n  geom_histogram(fill = \"sienna1\")  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo split the histogram by gender, we can again specify fill as an aesthetic. With position = position_dodge(), we can place the bars side by side:\nggplot(data = pend_small, aes(x = azges1, fill = factor(zpsex))) + \n  geom_histogram() \nggplot(data = pend_small, aes(x = azges1, fill = factor(zpsex))) + \n  geom_histogram(position = position_dodge()) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe scale_...manual commands still work here, but as scale_fill_manual instead of scale_color_manual:\n\nggplot(data = pend_small, aes(x = azges1, fill = factor(zpsex))) + \n  geom_histogram(position = position_dodge()) +\n  scale_fill_manual(values = c(\"sienna1\",\"dodgerblue4\"),\n                    breaks = 1:2, labels = c(\"Männer\",\"Frauen\")) +\n  labs(fill = \"Geschlecht\")\n\n\n\n\n\n\n\n\n\n\n6.3.2 Exercise",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#categorical-features",
    "href": "04_viz_translated.html#categorical-features",
    "title": "6  Visualization with {ggplot2}",
    "section": "6.4 Categorical Features",
    "text": "6.4 Categorical Features\nNext, we’ll look at a way to visualize the contingency table from Chapter 2:\n\npend_small$PD0400[pend_small$PD0400&lt;0] &lt;- NA # exclude missings\npend_small %&gt;% \n  count(zpsex, PD0400) \n\n# A tibble: 10 × 3\n   zpsex         PD0400                              n\n   &lt;dbl+lbl&gt;     &lt;dbl+lbl&gt;                       &lt;int&gt;\n 1 1 [Maennlich]  1 [Ueberhaupt nicht religioes]    40\n 2 1 [Maennlich]  2 [Eher nicht religioes]          41\n 3 1 [Maennlich]  3 [Eher religioes]                49\n 4 1 [Maennlich]  4 [Sehr religioes]                22\n 5 1 [Maennlich] NA                                780\n 6 2 [Weiblich]   1 [Ueberhaupt nicht religioes]    26\n 7 2 [Weiblich]   2 [Eher nicht religioes]          34\n 8 2 [Weiblich]   3 [Eher religioes]                40\n 9 2 [Weiblich]   4 [Sehr religioes]                16\n10 2 [Weiblich]  NA                                816\n\n\nWith geom_bar(), we can create bars by setting the height as the count of observations with ..count.. for y:\n\npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(x = as_factor(PD0400), fill = factor(zpsex),\n                       y = ..count..)) +\n  geom_bar(position = position_dodge()) \n\n\n\n\n\n\n\n\nHow do we get relative frequencies? We adjust our aes to y = (..count..)/sum(..count..). With scale_y_continuous(labels = scales::label_percent(accuracy = 1)), we can also display percentages on the y-axis. To create a bar chart instead of a column chart, simply swap x and y and adjust the percentage labels using scale_x_continuous:\npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(x = as_factor(PD0400), fill = factor(zpsex),\n                       y = (..count..)/sum(..count..) )) +\n  geom_bar(position = position_dodge()) +\n  scale_y_continuous(labels = scales::label_percent(accuracy = 1)) \npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(y = as_factor(PD0400), fill = factor(zpsex),\n                       x = (..count..)/sum(..count..) )) +\n  geom_bar(position = position_dodge()) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese charts can also be customized with scale_... and labeled in detail using labs()—all options are consistent across different types of visualizations. Additionally, we can label the categories ourselves with breaks = and labels = if we don’t like the default labels:\n\npend_small %&gt;% \n  filter(!is.na(PD0400)) %&gt;% \n  ggplot(data = ., aes(y = PD0400, fill = factor(zpsex),\n                       x = (..count..)/sum(..count..) )) +\n  geom_bar(position=position_dodge()) +\n  scale_fill_manual(values = c(\"navajowhite\",\"navy\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\")) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  scale_y_continuous(breaks = 1:4, \n                     labels = c(\"Überhaupt nicht\",\n                                \"Eher nicht\",\n                                \"Eher schon\",\n                                \"Sehr\")) +\n  labs(title = \"Religiösität nach Geschlecht\",\n       subtitle = \"Relative Häufigkeiten\",\n       caption = \"Quelle: PASS-CF 0619\",\n       y = \"Religiösität\",\n       x = \"Relative Häufigkeit\",\n       fill = \"Geschlecht\" ) \n\n\n\n\n\n\n\n\n\n6.4.1 Exercise",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#exercises",
    "href": "04_viz_translated.html#exercises",
    "title": "6  Visualization with {ggplot2}",
    "section": "6.5 Exercises",
    "text": "6.5 Exercises\nFor all tasks, use the first 150 observations (pend_small) to keep the plot simple. Remember to exclude missing values with filter(); you can use the following command:\n\npend &lt;- \n  haven::read_dta(\"./orig/PENDDAT_cf_W13.dta\", \n    col_select = c(\"zpsex\", \"welle\", \"bilzeit\", \"PA0445\", \"PG1270\", \"PEO0400c\")\n  )\n\n\n6.5.1 Exercise 1\n\npend_u41 &lt;- \n  pend %&gt;% \n  filter(welle == 13, bilzeit &gt; 0, PA0445 &gt; 0) \n\n\nCreate a scatter plot for the variables “Duration of total unemployment experience in months” (PA0445, y-axis) and “Duration of education” (bilzeit, x-axis).\nSet the color to differentiate between men and women (zpsex).\nChange the colors to goldenrod1 and dodgerblue4 (or any other from this list).\nLabel the axes and legend!\n\nBack to top\n\n\n6.5.2 Exercise 2\n\npend_u42 &lt;- \n  pend %&gt;% \n  filter(welle == 9, PG1270 &gt; 0) \n\n\nCreate a boxplot or histogram for the distribution of the number of cigarettes and cigarillos smoked per day (in the last week) (PG1270).\nCustomize this graphic so that the distributions for men and women are shown separately.\nHow can you also set the colors based on gender? (Remember color = and fill =).\nChange the bar colors using scale_fill_manual, scale_fill_brewer, or scale_fill_viridis (see the sections Colors, ColorBrewer, and viridis under “other options”).\n\nBack to top\n\n\n6.5.3 Exercise 3\n\npend_u43 &lt;- \n  pend %&gt;% \n  filter(welle == 11, PEO0400c &gt; 0) \n\n\nCreate a bar chart for the responses to the question, “A working mother can have just as close a relationship with her children as a mother who is not employed.” (PEO0400c).\nCreate a bar chart for PEO0400c separated by the migration variable, so set the bar colors based on migration. The migration variable captures whether the respondents have a migration background:\n\n\n\nVariablevaluelabel`PEO0400c`1Stimme voll und ganz zu2Stimme eher zu3Stimme eher nicht zu4Stimme ueberhaupt nicht zu`migration`1Kein Migrationshintergrund2selbst / mind. 1 Elternteil zugezogen3Mind. 1 Elternteil zugezogen4Mind. 1 Grosselt. zugez., Elt. in D geb.\n\n\nBack to top",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#more-options-for-ggplot2",
    "href": "04_viz_translated.html#more-options-for-ggplot2",
    "title": "6  Visualization with {ggplot2}",
    "section": "6.6 More options for {ggplot2}",
    "text": "6.6 More options for {ggplot2}\n\n6.6.1 Aesthetics\n\n\n\n\n\n\n\n\n\n\n\n6.6.2 themes\nWith so-called themes, we can change the layout of the graphic. Other themes include theme_light(), theme_classic(), or theme_void(). A full list can be found here. Additionally, the {ggthemes} package (install.packages('ggthemes')) offers a wide selection.\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 2) + \n  theme_minimal()\n\nggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 2) +\n  theme_dark()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.6.3 Farben\n\np1 &lt;- ggplot(data = pend_small, aes(x = palter, y = azges1, color = factor(zpsex))) + \n  geom_point(size = 3) \n\nNeben den im Beispiel verwendeten Farben für fill können natürlich auch noch unzählige weitere Farben in scale_fill_manual und scale_color_manual verwendet werden:\n\nHier findet sich eine Übersicht mit allen Farbnamen, die verstanden werden\nAlternativ können auch sog. HEX-Codes angeben werden, die bspw. mit dem Adobe Color Wheel oder Color Hex erstellt werden können.\n\np1 +  scale_color_manual(values = c(\"dodgerblue4\",\"sienna1\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\np1 +  scale_color_manual(values = c(\"#005b96\",\"#6497b1\"),\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.6.3.1 ColorBreweR\nAlternativ zur manuellen Auswahl der Farben mit scale_fill_manual und scale_color_manual können mit scale_fill_brewer() auch vorgegebene Farbpaletten des colorbrewer verwendet werden. Dazu muss lediglich scale_fill_brewer() anstelle von scale_fill_manual angeben werden und statt values eine der Paletten - eine Übersicht findet sich hier. Die Farbpaletten von ColorBreweR sind alle in ggplot2 integriert.\n\np1 +\n  scale_color_brewer(palette = \"RdYlBu\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n6.6.3.2 viridis\nAnalog dazu gibt es auch die {viridis}-Paletten, welche durchgängig “colorblind-safe” und ebenfalls in {ggplot2} integriert sind. Allerdings ist hier zu beachten, dass für Farbauswahlen basierend auf einer kategorialen Variable scale_color_viridis_d() zu verwenden ist. Soll die Farbe entlang einer numerischen/metrischen Variable bestimmt werden, dann ist scale_color_viridis_c() zu verwenden. Außerdem kann mit begin und end die Breite der Farbskala angepasst werden:\np1 +\n  scale_color_viridis_d(option=\"magma\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \np1 +\n  scale_color_viridis_d(option=\"magma\",begin = .65,end = .85,\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.6.3.3 Weitere Farbpaletten\nDarüber hinaus gibt es unzählige Pakete, die ebenfalls scale_color_ und scale_fill_-Funktionen bieten: Hier noch zwei Beispiele mit {scico} und {MetBrewer}, welches Farben aus Bildern im Metropolitan Museum of Art enthält:\n\ninstall.packages('scico')\ninstall.packages(\"MetBrewer\")\n\n{scico} Farbpaletten\n\n\n\n\n\n\n\n\n\n{MetBrewer} Farbpaletten\n\n\n\n\n\n\n\n\n\nlibrary(scico)\np1 +\n  scale_color_scico_d(palette = \"oslo\",begin = .5,end = .8,\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \nlibrary(MetBrewer)\np1 +\n  scale_color_met_d(name = \"Kandinsky\",\n                    breaks = c(1,2), labels = c(\"Men\", \"Women\") ) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparable packages also exist for:\n\n{DutchMasters} - Color palettes from paintings by Dutch masters.\n{wesanderson} - Color palettes based on various Wes Anderson films (e.g., The Grand Budapest Hotel).\n{ochRe} - Color palettes “inspired by Australian art, landscapes, and wildlife.”\n{paletteer} offers a vast selection of various color palettes.\n\nCheck out the interactive color picker here\n\n\n\n6.6.4 Shapes\n\n\n\n\n\n\n\n\n\nZusätzlicher Überblick\n\n\n6.6.5 Linetypes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview\n\n\n\nShapes und Linetypes at a glance in the R Cookbook",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#useful-links",
    "href": "04_viz_translated.html#useful-links",
    "title": "6  Visualization with {ggplot2}",
    "section": "6.7 Useful links",
    "text": "6.7 Useful links\n\nThe Graphs chapter of the R Cookbook is an excellent resource for various options and a basic overview—for example, on adjusting the legend, line and point types, or the axes.\nAdjusting font size and color: This guide provides a good overview of how to modify font size and color in {ggplot2}.\nFrom Data to Viz offers a decision tree for various relationships and descriptions with example syntax.\n\n\n\n\n\n\n\n\n\n\n\nThe R Graph Gallery is even more extensive and offers additional visualization ideas.\nFor those who want to learn more about effective (and beautiful) data visualizations with {ggplot2}, Cédric Scherer’s tutorial is an excellent introduction. This workshop is great for further exploration.\nThis workshop offers additional insights on how to make data visualizations more appealing with {ggplot2}.\nA list of extensions for ggplot2.\nThe book on {ggplot2}.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "04_viz_translated.html#footnotes",
    "href": "04_viz_translated.html#footnotes",
    "title": "6  Visualization with {ggplot2}",
    "section": "",
    "text": "If we had specified color in aes, the corresponding command would be scale_color_manual.↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Visualization with `{ggplot2}`</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Links & Weiterführendes",
    "section": "",
    "text": "%&gt;% vs. |&gt;\nIn diesem Kurs haben wir die Pipe %&gt;% aus {tidyverse} (streng genommen aus dem Paket {magrittr}) kennen gelernt. Mit dem Update auf R 4.1 wurde in base R ebenfalls eine Pipe |&gt; eingeführt und Hilfeseiten usw. ersetzen langsam, aber sicher %&gt;% durch |&gt;. Für (nahezu) alle Anwendungen, die wir kennengelernt haben, verhalten sich beide Pipes identisch - und nachdem am IAB R teilweise noch alte R-Versionen installiert sind, haben wir uns an ‘alte Variante’ gehalten. Letztlich spricht aber nichts dagegen, nach einem Update auf |&gt; umzusteigen - oder einfach bei %&gt;% zu bleiben.\nUnter anderem steht hier mehr zu den Unterschieden zwischen beiden Pipes. Außerdem bietet dieser Blogbeitrag einen guten Überblick zu den Fallstricken beim Umstieg von %&gt;% auf |&gt;.",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#anonymfun",
    "href": "references.html#anonymfun",
    "title": "Links & Weiterführendes",
    "section": "Anonyme Funktionen: .x vs. /(x)",
    "text": "Anonyme Funktionen: .x vs. /(x)\nMit R 4.1.0 wurde in base R eine neue ‘anonymous function short hand’ eingeführt, welche die ‘formula syntax’ Schreibweise ~mean(.x) ablöst, die wir in Kapitel 6 kennen gelernt haben. In der neuen base R wäre das \\(x) mean(x) geschrieben.\nAus der {purrr} release notes für Version 1.0.0 (Dezember 2022): We believe that it’s better to use these new base tools because they work everywhere: the base pipe doesn’t require that you load magrittr and the new function shorthand works everywhere, not just in purrr functions. Additionally, being able to specify the argument name for the anonymous function can often lead to clearer code.\nDementsprechend würde die Anwendung in across() wie folgt aussehen:\n\nsat_small &lt;- haven::read_dta(\"./data/BIBBBAuA_2018_suf1.0.dta\",n_max = 16) %&gt;% \n    select(F1450_04,F1450_05,F1450_06) %&gt;% \n    slice(12:16)\n\n# formula syntax\nsat_small %&gt;% \n  mutate(across(matches(\"F1450\"),~mean(.x)))\n# anonymous function short hand\nsat_small %&gt;% \n  mutate(across(matches(\"F1450\"),\\(x) mean(x) ))\n\nIn diesem Skript habe ich auf die bisherige ‘formula syntax’ Schreibweise zurück gegriffen, da aktuell noch die meisten Hilfeseite mit dieser Syntax arbeiten.",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#einführungen-in-r",
    "href": "references.html#einführungen-in-r",
    "title": "Links & Weiterführendes",
    "section": "Einführungen in R",
    "text": "Einführungen in R\nEine Sammlung von Lehrskripten und Unterlagen aus verschiedenen Kontexten zum selbst weiter lernen:\nR for Data Science das Standardwerk für Datenanalysen mit {tidyverse} - sehr intuitive Einführung, Fokus auf Data Science\nProblemorientiere Einführungen in spezifische Anwendungen “do more with R”\nTen simple rules for teaching yourself R\nModerne Datenanalyse mit R: Deutschsprachige Einführung in {tidyverse}\nR for the Rest of Us bietet viele Tutorials und freie Kurse an, unter anderem auch viele YouTube Videos.\nStata 2 R richtet sich alle Anwender*innen von Stata, die auf R umsteigen möchten. Allerdings wird hier anstelle des {tidyverse} das Paket {data.table} für die Datenaufbereitung gezeigt. {data.table} ist auf der einen Seite sehr schnell, jedoch von der Syntaxlogik her etwas umständlicher als das {tidyverse}. Für alle, die mit sehr großen Datensätzen arbeiten lohnt es sich aber, {data.table} auszuprobieren.",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#rmarkdown",
    "href": "references.html#rmarkdown",
    "title": "Links & Weiterführendes",
    "section": "RMarkdown",
    "text": "RMarkdown\n{rmarkdown} ermöglich es, formatierte Textelemente mit Markdown und R code bzw. Output zu kombinieren. Anders als ein R Script enthält ein RMarkdown-Dokument nicht nur Befehle, sondern auch Text - welcher mit Hilfe von Markdown-Befehlen formatiert werden kann. So können Grafiken, Tabellen, usw. direkt und zeitgleich mit dem Begleittext erstellt werden. Mit R Markdown können wir HTML, PDF, Word Dokumente, PowerPoint und HTML Präsentationen, Webseiten und Bücher erstellen. Diese gesamte Webseite wurde mit {R Markdown} bzw. dem verwandten Paket {Quarto} erstellt.\nDie Hilfeseiten und Dokumentation für R Markdown ist extrem umfangreich und auch die Tutorials und Cheatsheets sind hervorragend. Daher hier nur eine kleiner Überblick.\n\nMarkdown Syntax\nEin RMarkdown-Dokument sieht in seiner Grundform ungefähr so aus:\n---\ntitle: \"Mein erstes RMarkdown-Dokument\"\nauthor: \"Mein Name\"\ndate: \"2022-09-11\"\noutput: pdf_document\n---\n  \n# Überschrift 1\n\n## Unterüberschrift 2\n\nDies ist ein R Markdown-Dokument. \nMarkdown ist eine einfache Syntax für die Erstellung von HTML-, PDF- und MS Word-Dokumenten. \nText kann **fett** und *kursiv* geschrieben werden. \n\nWenn wir auf die Schaltfläche **Knit** klicken, wird ein Dokument erstellt.\nDas sowohl den Inhalt als auch die Ausgabe aller eingebetteten R-Code-Bausteine innerhalb des Dokuments enthält. \nEin R-Code-Baustein (\"chunk\") sieht so aus:\n\n```{r cars}\n# hier kommt der R Code hin\nsummary(mtcars$qsec)\n```\n\n\n\n\n\n\n\n\n\n\n\nBeispiel\nPaper zu einem Beispieldatensatz, komplett in R Markdown geschrieben\nHier findet ihr den Source-Code",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#cheatsheets",
    "href": "references.html#cheatsheets",
    "title": "Links & Weiterführendes",
    "section": "Cheatsheets",
    "text": "Cheatsheets\nEine Sammlung an Cheatsheets für eine breite Palette an Anwendungen gibt es hier.\n\nDatenvisualisierung mit {ggplot2}\nDatensätze bearbeiten mit {dplyr}\nDatensätze erstellen/reshapen mit {tidyr}",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#ggplot2",
    "href": "references.html#ggplot2",
    "title": "Links & Weiterführendes",
    "section": "{ggplot2}",
    "text": "{ggplot2}\nEine große Stärke von ggplot2 sind die zahlreichen Erweiterungen, welche beispielsweise ermöglichen\n\nmehrere Grafiken zu kombinieren mit {patchwork}\nKarten zu erstellen mit sf, weitere Link\nfortgeschrittene Textformatierungen zu verwenden mit {ggtext}\nGrafiken als Animation zu erstellen {gganimate} - eine Einführung oder hier\nLogos in in {ggplot2} einfügen mit {ggpath}\n\nEine Übersicht zu Erweiterungspakteten für {ggplot2} findet sich hier\nAuch The R Graph Gallery bietet eine hervorragende Übersicht zu Darstellungsmöglichkeiten mit Syntaxbeispielen für {ggplot2}.\n\nTutorial von Cédric Scherer\nSession zu intuitiveren Grafiken von Cara Thompson",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#purrr",
    "href": "references.html#purrr",
    "title": "Links & Weiterführendes",
    "section": "Fortgeschrittene Anwendung von lapply()/map() mit selbstgeschriebenen Funktionen",
    "text": "Fortgeschrittene Anwendung von lapply()/map() mit selbstgeschriebenen Funktionen\n\nUmfangreiche Einführung in loops mit map() und weiteren Funktionen aus {purrr} Hendrik van Broekhuizen\nModellserien: Blog von Tim Tiefenbach zu eleganten Möglichkeiten",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#regex",
    "href": "references.html#regex",
    "title": "Links & Weiterführendes",
    "section": "regex",
    "text": "regex\nFür die Arbeit mit Textvariablen sind regular expressions (regex) eine große Hilfe. Damit lassen sich beispielsweise Textabschnitte nach bestimmten Zeichenfolgen durchsuchen, diese ersetzen usw. Der Blog von Joshua C. Fjelstul ist ein guter Einstieg. Darüber hinaus gibt es ein hilfreiches Cheatsheet zu regex in R und das regex -Paket {stringr}",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  },
  {
    "objectID": "references.html#weiteres",
    "href": "references.html#weiteres",
    "title": "Links & Weiterführendes",
    "section": "Weiteres",
    "text": "Weiteres\n{easystats} bietet eine Sammlung von Paketen, welche statische Auswertungen erleichtern und vereinheitlichen. Gleichzeitig geht diese Vereinheitlichung aber mit einer beschränkteren Flexibilität einher - das ist Geschmackssache und kommt auf den Anwendungsfall an. Wir haben aus dem easystats-Universum unter anderem {performance} und {effectsize} kennengelernt.\nEreigniszeitmodelle / Event History Modellung / Survival Analysis",
    "crumbs": [
      "Links & Weiterführendes"
    ]
  }
]